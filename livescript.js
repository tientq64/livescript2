// Generated by LiveScript 1.6.1

// LiveScript 1.6.1
// Copyright (c) Jeremy Ashkenas, Satoshi Murakami, George Zahariev
// Released under the MIT License
// https://raw.githubusercontent.com/gkz/LiveScript/master/LICENSE
(function() {

var isNode = typeof module !== 'undefined' && module.exports;
var require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by LiveScript 1.6.1
var fold, ref$, nameFromPath, stripString, SourceNode, SourceMapGenerator, sn, snEmpty, snSafe, snRemoveLeft, Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Yield, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, StepSlice, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, CopyL, DECLS, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, ID_INTERPOLATE, SIMPLENUM, slice$ = [].slice, arrayFrom$ = Array.from, toString$ = {}.toString;
function curry$(f, bound){
   var context,
   _curry = function(args) {
      return f.length > 1 ? function(){
         var params = args ? args.concat() : [];
         context = bound ? context || this : this;
         return params.push.apply(params, arguments) <
               f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
      } : f;
   };
   return _curry();
}
fold = curry$(function(f, memo, xs){
   var i$, len$, x;
   for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      memo = f(memo, x);
   }
   return memo;
});
stripString = function(val){
   var that;
   if (that = /^['"](.*)['"]$/.exec(val.trim())) {
      return that[1];
   } else {
      return val;
   }
};
nameFromPath = function(modulePath){
   return stripString(modulePath).split('/').pop().split('.')[0].replace(/-[a-z]/ig, function(it){
      return it.charAt(1).toUpperCase();
   });
};
ref$ = require('source-map'), SourceNode = ref$.SourceNode, SourceMapGenerator = ref$.SourceMapGenerator;
sn = function(node){
   var parts = [], i$, to$, result;
   node == null && (node = {});
   for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      parts.push(arguments[i$]);
   }
   try {
      result = new SourceNode(node.line, node.column, null, parts);
      result.displayName = node.constructor.displayName;
      return result;
   } catch (e) {
      console.dir(parts);
      throw e;
   }
};
snEmpty = function(node){
   var i$, ref$, len$;
   if (node instanceof SourceNode) {
      for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
         if (!snEmpty(ref$[i$])) {
            return false;
         }
      }
      return true;
   } else {
      return !node;
   }
};
snSafe = function(code){
   if (code instanceof SourceNode) {
      return code;
   } else {
      return code.toString();
   }
};
snRemoveLeft = function(node, count){
   var to$, i, child;
   for (i = 0, to$ = node.children.length; i < to$; ++i) {
      child = node.children[i];
      if (child instanceof SourceNode) {
         count = snRemoveLeft(child, count);
      } else {
         child = child.toString();
         node.children[i] = child.slice(count);
         count -= child.length;
      }
      if (count <= 0) {
         return 0;
      }
   }
   return count;
};
SourceNode.prototype.replace = function(...args){
   return new SourceNode(
      this.line, this.column, this.source,
      this.children.map(x => x.replace(...args)),
      this.name
   );
};
SourceNode.prototype.setFile = function(filename){
   var i$, ref$, len$, child, results$ = [];
   this.source = filename;
   for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
      child = ref$[i$];
      if (child instanceof SourceNode) {
         results$.push(child.setFile(filename));
      }
   }
   return results$;
};
SourceNode.prototype.toStringWithSourceMap = function(...args){
   var gen, genLine = 1, genColumn = 0, stack = [], code = '',
      debugOutput = '', debugIndent = '', debugIndentStr = '  ', genForNode;
   gen = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args), t;
      return (t = typeof result)  == "object" || t == "function" ? result || child : child;
   })(SourceMapGenerator, args, function(){});
   genForNode = function(node){
      var valid, i$, ref$, len$, child, cur, to$, i, c, results$ = [];
      if (node instanceof SourceNode) {
         debugOutput += debugIndent + node.displayName;
         valid = node.line && 'column' in node;
         if (valid) {
            stack.push(node);
            debugOutput += '!';
         }
         debugOutput += " " + node.line + ":" + node.column + " " + genLine + ":" + genColumn + "\n";
         debugIndent += debugIndentStr;
         for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
            child = ref$[i$];
            genForNode(child);
         }
         debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
         if (valid) {
            return stack.pop();
         }
      } else {
         debugOutput += debugIndent + "" + JSON.stringify(node) + "\n";
         code += node;
         cur = stack[stack.length - 1];
         if (cur) {
            gen.addMapping({
               source: cur.source,
               original: {
                  line: cur.line,
                  column: cur.column
               },
               generated: {
                  line: genLine,
                  column: genColumn
               },
               name: cur.name
            });
         }
         for (i$ = 0, to$ = node.length; i$ < to$; ++i$) {
            i = i$;
            c = node.charAt(i);
            if (c === "\n") {
               genColumn = 0;
               ++genLine;
               if (cur) {
                  results$.push(gen.addMapping({
                     source: cur.source,
                     original: {
                        line: cur.line,
                        column: cur.column
                     },
                     generated: {
                        line: genLine,
                        column: genColumn
                     },
                     name: cur.name
                  }));
               }
            } else {
               results$.push(++genColumn);
            }
         }
         return results$;
      }
   };
   genForNode(this);
   return {
      code: code,
      map: gen,
      debug: debugOutput
   };
};
/* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost
tmp-to-string = SourceNode::to-string
SourceNode::to-string = (...args) ->
      console.log("toString(): ", new Error().stack)
      tmp-to-string.apply this, args
*/
(Node = function(){
   throw Error('unimplemented');
}).prototype = {
   compile: function(options, level){
      var o, code, that, i$, len$;
      o = import$({}, options);
      if (level != null) {
         o.level = level;
      }
      if (o.level && this.isStatement()) {
         return this.compileClosure(o);
      }
      code = (this.tab = o.indent, this).compileNode(o);
      if (that = this.temps) {
         for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
            o.scope.free(that[i$]);
         }
      }
      return code;
   },
   compileClosure: function(o){
      var that, fun, call, hasArgs, hasThis, out;
      if (that = this.getJump()) {
         that.carp('inconvertible statement');
      }
      fun = Fun([], Block(this));
      call = Call();
      if (o.inAsync) {
         fun.async = true;
      }
      if (o.inGenerator) {
         fun.generator = true;
      }
      this.traverseChildren(function(it){
         switch (it.value) {
         case 'this':
            hasThis = true;
            break;
         case 'arguments':
            hasArgs = it.value = 'args$';
         }
      });
      if (hasThis) {
         call.args.push(Literal('this'));
         call.method = '.call';
      }
      if (hasArgs) {
         call.args.push(Literal('arguments'));
         fun.params.push(Var('args$'));
      }
      out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
      if (o.inGenerator) {
         out = new Yield('yieldfrom', out);
      } else if (o.inAsync) {
         out = new Yield('await', out);
      }
      return out.compile(o);
   },
   compileBlock: function(o, node){
      var code;
      if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
         return sn(null, "{\n", code, "\n" + this.tab + "}");
      } else {
         return sn(node, '{}');
      }
   },
   compileSpreadOver: function(o, list, transform){
      var ob, them, i$, len$, node, sp, lat, ref$;
      ob = list instanceof Obj;
      them = list.items;
      for (i$ = 0, len$ = them.length; i$ < len$; ++i$) {
         node = them[i$];
         if (sp = node instanceof Splat) {
            node = node.it;
         }
         if (ob && !sp) {
            node = node.val;
         }
         node = transform(node);
         if (sp) {
            node = lat = Splat(node);
         }
         if (ob && !sp) {
            them[i$].val = node;
         } else {
            them[i$] = node;
         }
      }
      if (!lat && (this['void'] || !o.level)) {
         list = (ref$ = Block(ob ? (function(){
            var i$, x$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = them).length; i$ < len$; ++i$) {
               x$ = ref$[i$];
               results$.push(x$.val);
            }
            return results$;
         }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
      }
      return list.compile(o, LEVEL_PAREN);
   },
   cache: function(o, once, level, tempName){
      var ref$, ref, sub, tempvars;
      if (!this.isComplex()) {
         return [ref$ = level != null ? this.compile(o, level) : this, ref$];
      }
      if (ref = this.getRef()) {
         sub = this;
      } else {
         sub = Assign(ref = Var(o.scope.temporary(tempName)), this);
         if (once) {
            ref.temp = true;
         } else {
            tempvars = [ref.value];
         }
      }
      if (level != null) {
         sub = sub.compile(o, level);
         if (once && tempvars) {
            o.scope.free(ref.value);
         }
         return [sub, ref.value];
      }
      return [sub, ref, tempvars];
   },
   compileLoopReference: function(o, name, ret, safeAccess){
      var ref$, code, asn, tmp;
      if (this instanceof Var && o.scope.check(this.value) || this instanceof Unary && ((ref$ = this.op) === '+' || ref$ === '-') && (-1 / 0 < (ref$ = +this.it.value) && ref$ < 1 / 0) || this instanceof Literal && !this.isComplex()) {
         code = this.compile(o, LEVEL_PAREN);
         if (safeAccess && !(this instanceof Var)) {
            code = "(" + code + ")";
         }
         return [code, code];
      }
      asn = Assign(Var(tmp = o.scope.temporary(name)), this);
      ret || (asn['void'] = true);
      return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
   },
   eachChild: function(fn){
      var i$, ref$, len$, name, child, j$, len1$, that;
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
         name = ref$[i$];
         if (child = this[name]) {
            if ('length' in child) {
               for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
                  if (that = fn(child[j$], name, j$)) {
                     return that;
                  }
               }
            } else {
               if ((that = fn(child, name)) != null) {
                  return that;
               }
            }
         }
      }
   },
   traverseChildren: function(fn, xscope){
      return this.eachChild((node, name, index) => {
         var ref$;
         return (ref$ = fn(node, this, name, index)) != null
            ? ref$
            : node.traverseChildren(fn, xscope);
      });
   },
   rewriteShorthand: function(o, assign){
      var i$, ref$, len$, name, child, j$, len1$, that;
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
         name = ref$[i$];
         if (child = this[name]) {
            if ('length' in child) {
               for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
                  if (that = child[j$].rewriteShorthand(o, assign)) {
                     child[j$] = that;
                  }
               }
            } else if (that = child.rewriteShorthand(o, assign)) {
               this[name] = that;
            }
         }
      }
   },
   anaphorize: function(){
      var name, ref$;
      this.children = this.aTargets;
      if (this.eachChild(hasThat)) {
         if (this[name = this.aSource] instanceof Existence) {
            this[name].doAnaphorize = true;
         } else if (this[name].value !== 'that') {
            this[name] = Assign(Var('that'), this[name]);
         }
      }
      function hasThat(it){
         var that;
         return it.value === 'that' || ((that = it.aSource)
            ? (that = it[that]) ? hasThat(that) : void 8
            : it.eachChild(hasThat));
      }
      delete this.children;
      return ref$ = this[this.aSource], ref$.cond = true, ref$;
   },
   carp: function(msg, type){
      type == null && (type = SyntaxError);
      throw type(msg + " " + this.lineMsg());
   },
   warn: function(msg){
      if (typeof console != 'undefined' && console !== null) {
         console.warn("WARNING: " + msg + " " + this.lineMsg());
      }
   },
   lineMsg: function(){
      return "on line " + (this.line || this.traverseChildren(it => it.line));
   },
   delegate: function(names, fn){
      var i$, len$;
      for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {
         fn$.call(this, names[i$]);
      }
      function fn$(name){
         this[name] = function(it){
            return fn.call(this, name, it);
         };
      }
   },
   children: [],
   terminator: ';',
   isComplex: YES,
   isStatement: NO,
   isAssignable: NO,
   isCallable: NO,
   isEmpty: NO,
   isArray: NO,
   isString: NO,
   isRegex: NO,
   isMatcher: function(){
      return this.isString() || this.isRegex();
   },
   assigns: NO,
   ripName: VOID,
   getRef: VOID,
   unfoldSoak: VOID,
   unfoldAssign: VOID,
   unparen: THIS,
   unwrap: THIS,
   maybeKey: VOID,
   varName: String,
   getAccessors: VOID,
   getCall: VOID,
   getDefault: VOID,
   getJump: VOID,
   isNextUnreachable: NO,
   extractKeyRef: function(o, assign){
      return this.maybeKey() || this.carp(assign ? "invalid assign" : "invalid property shorthand");
   },
   invert: function(){
      return Unary('!', this, true);
   },
   invertCheck: function(it){
      return it.inverted ? this.invert() : this;
   },
   addElse: function($else){
      this['else'] = $else;
      return this;
   },
   makeReturn: function(ref, obj){
      var items, kv;
      if (obj) {
         items = this instanceof Arr
            ? (this.items[0] == null || this.items[1] == null && this.carp('must specify both key and value for object comprehension'), this.items)
            : (kv = 'keyValue$', [Assign(Var(kv), this), Var(kv)].map((v, i) => Chain(v).add(Index(Literal(i)))));
         return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
      } else if (ref) {
         return Call.make(JS(ref + '.push'), [this]);
      } else {
         return Return(this);
      }
   },
   show: String,
   toString: function(idt){
      var tree, that;
      idt || (idt = '');
      tree = '\n' + idt + this.constructor.displayName;
      if (that = this.show()) {
         tree += ' ' + that;
      }
      this.eachChild(function(it){
         tree += it.toString(idt + TAB);
      });
      return tree;
   },
   stringify: function(space){
      return JSON.stringify(this, null, space);
   },
   toJSON: function(){
      return import$({
         type: this.constructor.displayName
      }, this);
   }
};
exports.parse = function(json){
   return exports.fromJSON(JSON.parse(json));
};
exports.fromJSON = (function(){
   return function fromJSON(it){
      var node, key, i$, len$;
      if (!(it && typeof it === 'object')) {
         return it;
      }
      if (it.type) {
         node = clone$(exports[it.type].prototype);
         for (key in it) {
            node[key] = fromJSON(it[key]);
         }
         return node;
      }
      return it.length != null ? it.map(v => fromJSON(v)) : it;
   }
}());
Negatable = {
   show: function(){
      return this.negated && '!';
   },
   invert: function(){
      this.negated = !this.negated;
      return this;
   }
};
exports.Block = Block = (function(superclass){
   var prototype = extend$((import$(Block, superclass).displayName = 'Block', Block), superclass).prototype, constructor = Block;
   function Block(body){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      body || (body = []);
      if ('length' in body) {
         this$.lines = body;
      } else {
         this$.lines = [];
         this$.add(body);
      }
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Block.prototype.children = ['lines'];
   Block.prototype.toJSON = function(){
      delete this.back;
      return superclass.prototype.toJSON.call(this);
   };
   Block.prototype.add = function(it){
      var that, ref$;
      it = it.unparen();
      switch (false) {
      case !(that = this.back):
         that.add(it);
         break;
      case !(that = it.lines):
         (ref$ = this.lines).push.apply(ref$, that);
         break;
      default:
         this.lines.push(it);
         if (that = (ref$ = it.back, delete it.back, ref$)) {
            this.back = that;
         }
      }
      return this;
   };
   Block.prototype.prepend = function(...args){
      this.lines.splice(this.neck(), 0, ...args);
      return this;
   };
   Block.prototype.pipe = function(target, type){
      var args;
      args = type === '|>' ? this.lines.pop() : target;
      if (toString$.call(args).slice(8, -1) !== 'Array') {
         args = [args];
      }
      switch (type) {
      case '|>':
         this.lines.push(Call.make(target, args, {
            pipe: true
         }));
         break;
      case '<|':
         this.lines.push(Call.make(this.lines.pop(), args));
      }
      return this;
   };
   Block.prototype.unwrap = function(){
      return this.lines.length === 1 ? this.lines[0] : this;
   };
   Block.prototype.chomp = function(){
      var lines, i, that;
      lines = this.lines;
      i = lines.length;
      while (that = lines[--i]) {
         if (!that.comment) {
            break;
         }
      }
      lines.length = i + 1;
      return this;
   };
   Block.prototype.neck = function(){
      var pos, i$, ref$, len$, x;
      pos = 0;
      for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
         x = ref$[i$];
         if (!(x.comment || x instanceof Literal)) {
            break;
         }
         ++pos;
      }
      return pos;
   };
   Block.prototype.isComplex = function(){
      var ref$;
      return this.lines.length > 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
   };
   prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it) {
      var ref$, ref1$;
      return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
   });
   Block.prototype.getJump = function(it){
      var i$, ref$, len$, that;
      for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
         if (that = ref$[i$].getJump(it)) {
            return that;
         }
      }
   };
   Block.prototype.isNextUnreachable = function(){
      var i$, ref$, len$;
      for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
         if (ref$[i$].isNextUnreachable()) {
            return true;
         }
      }
      return false;
   };
   Block.prototype.makeReturn = function(){
      var ref$, key$, that;
      this.chomp();
      if (that = (ref$ = this.lines)[key$ = ref$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref$, arguments) : void 8) {
         if (that instanceof Return && !that.it) {
            --this.lines.length;
         }
      }
      return this;
   };
   Block.prototype.compile = function(o, level){
      var tab, codes, i$, ref$, len$, node, that, code;
      level == null && (level = o.level);
      if (level) {
         return this.compileExpressions(o, level);
      }
      o.block = this;
      tab = o.indent;
      codes = [];
      for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
         node = ref$[i$];
         if (!node.evalResult) {
            node['void'] = true;
         }
         if (that = node.rewriteShorthand(o)) {
            node = that;
         }
         if (snEmpty(code = (node.front = true, node).compile(o, level))) {
            continue;
         }
         codes.push(tab, code);
         node.isStatement() || codes.push(node.terminator);
         codes.push('\n');
      }
      codes.pop();
      return sn(null, ...codes)
   };
   Block.prototype.compileRoot = function(options){
      var o, that, ref$, bare, prefix, ref1$, ref2$, comment, ref3$, code;
      o = (import$({
         level: LEVEL_TOP,
         scope: this.scope = Scope.root = new Scope
      }, options));
      if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
         this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
      }
      delete o.filename;
      // o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
      bare = o.bare;
      delete o.bare;
      o.indent = '';
      if (/^\s*(?:#!|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
         prefix = this.lines.shift().code + '\n';
      }
      if (((ref1$ = this.lines[0]) != null ? (ref2$ = ref1$.code) != null ? ref2$[0] : void 8 : void 8) === '/') {
         comment = this.lines.shift().code + '\n';
      }
      if ((ref3$ = o.eval, delete o.eval, ref3$) && this.chomp().lines.length) {
         if (bare) {
            this.lines.push((ref3$ = Parens(this.lines.pop()), ref3$.evalResult = true, ref3$));
         } else {
            this.makeReturn();
         }
      }
      code = [this.compileWithDeclarations(o)];
      return sn(null, prefix || [], options.header || [], comment || [], code);
   };
   Block.prototype.compileWithDeclarations = function(o){
      var pre, i, rest, post;
      o.level = LEVEL_TOP;
      pre = [];
      if (i = this.neck()) {
         rest = this.lines.splice(i, 9e9);
         pre = [this.compile(o), "\n"];
         this.lines = rest;
      }
      if (snEmpty(post = this.compile(o))) {
         return sn(this, pre[0] || []);
      }
      return sn.apply(null, [null].concat(arrayFrom$(pre), [this.scope ? this.scope.emit(post, o.indent) : post]));
   };
   Block.prototype.compileExpressions = function(o, level){
      var lines, i, that, line, code, last, i$, len$, node;
      lines = this.chomp().lines;
      i = -1;
      while (that = lines[++i]) {
         if (that.comment) {
            lines.splice(i--, 1);
         }
      }
      if (!lines.length) {
         lines.push(Literal('void'));
      }
      lines[0].front = this.front;
      lines[lines.length - 1]['void'] = this['void'];
      if (!lines[1]) {
         line = lines[0];
         if (that = line.rewriteShorthand(o)) {
            line = that;
         }
         return line.compile(o, level);
      }
      code = [];
      last = lines.pop();
      for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
         node = lines[i$];
         if (that = node.rewriteShorthand(o)) {
            node = that;
         }
         code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
      }
      if (that = last.rewriteShorthand(o)) {
         last = that;
      }
      code.push(last.compile(o, LEVEL_PAREN));
      return level < LEVEL_LIST
         ? sn.apply(null, [null].concat(arrayFrom$(code)))
         : sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
   };
   Block.prototype.rewriteShorthand = VOID;
   return Block;
}(Node));
Atom = (function(superclass){
   var prototype = extend$((import$(Atom, superclass).displayName = 'Atom', Atom), superclass).prototype, constructor = Atom;
   Atom.prototype.show = function(){
      return this.value;
   };
   Atom.prototype.isComplex = NO;
   function Atom(...args){
      Atom.superclass(...args);
   }
   return Atom;
}(Node));
exports.Literal = Literal = (function(superclass){
   var prototype = extend$((import$(Literal, superclass).displayName = 'Literal', Literal), superclass).prototype, constructor = Literal;
   function Literal(value){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.value = value;
      if (value.js) {
         return JS(value + "", true);
      }
      if (value === 'super') {
         return new Super;
      }
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Literal.prototype.isEmpty = function(){
      return this.value === 'void' || this.value === 'null';
   };
   Literal.prototype.isCallable = function(){
      var ref$;
      return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
   };
   Literal.prototype.isString = function(){
      return '\'"'.indexOf((this.value + "")[0]) >= 0;
   };
   Literal.prototype.isRegex = function(){
      return (this.value + "")[0] === '/';
   };
   Literal.prototype.isComplex = function(){
      return this.isRegex() || this.value === 'debugger';
   };
   Literal.prototype.isWhat = function(){
      switch (false) {
      case !this.isEmpty():
         return 'empty';
      case !this.isCallable():
         return 'callable';
      case !this.isString():
         return 'string';
      case !this.isRegex():
         return 'regex';
      case !this.isComplex():
         return 'complex';
      }
   };
   Literal.prototype.varName = function(){
      return /^\w+$/.test(this.value) ? '$' + this.value : '';
   };
   Literal.prototype.makeReturn = function(it){
      return !it && this.value === 'debugger' ? this : superclass.prototype.makeReturn.apply(this, arguments);
   };
   Literal.prototype.maybeKey = function(){
      return ID.test(this.value)
         ? Key(this.value, this.value !== 'arguments' && this.value !== 'eval')
         : this;
   };
   Literal.prototype.compile = function(o, level){
      var val, ref$;
      level == null && (level = o.level);
      switch (val = this.value + "") {
      case 'this':
         return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
      case 'void':
         if (!level) {
            return sn(this, '');
         }
         val += ' 8';
         // fallthrough
      case 'null':
         if (level === LEVEL_CALL) {
            this.carp('invalid use of ' + this.value);
         }
         break;
      case 'on':
      case 'yes':
         val = 'true';
         break;
      case 'off':
      case 'no':
         val = 'false';
         break;
      case '*':
         this.carp('stray star');
         break;
      case '..':
         if (!(val = o.ref)) {
            this.carp('stray reference');
         }
         this.cascadee || (val.erred = true);
         break;
      case 'debugger':
         if (level) {
            return sn(this, "(function(){ debugger; }())");
         }
      }
      return sn(this, snSafe(val));
   };
   return Literal;
}(Atom));
exports.Var = Var = (function(superclass){
   var prototype = extend$((import$(Var, superclass).displayName = 'Var', Var), superclass).prototype, constructor = Var;
   function Var(value){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.value = value;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   prototype.isAssignable = prototype.isCallable = YES;
   Var.prototype.assigns = function(){
      return [this.value];
   };
   Var.prototype.maybeKey = function(){
      var ref$;
      return ref$ = Key(this.value), ref$.line = this.line, ref$;
   };
   Var.prototype.varName = prototype.show;
   Var.prototype.compile = function(o){
      return sn(this, this.temp
         ? o.scope.free(this.value)
         : this.value);
   };
   return Var;
}(Atom));
exports.Key = Key = (function(superclass){
   var prototype = extend$((import$(Key, superclass).displayName = 'Key', Key), superclass).prototype, constructor = Key;
   function Key(name, reserved){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.reserved = reserved || name.reserved;
      this$.name = '' + name;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Key.prototype.isComplex = NO;
   Key.prototype.assigns = function(){
      return [this.name];
   };
   Key.prototype.maybeKey = THIS;
   Key.prototype.varName = function(){
      var name;
      name = this.name;
      if (this.reserved || (name === 'arguments' || name === 'eval')) {
         return "$" + name;
      } else {
         return name;
      }
   };
   Key.prototype.show = function(){
      return this.reserved ? "'" + this.name + "'" : this.name;
   };
   Key.prototype.compile = function(){
      return sn(this, this.show());
   };
   return Key;
}(Node));
exports.Index = Index = (function(superclass){
   var prototype = extend$((import$(Index, superclass).displayName = 'Index', Index), superclass).prototype, constructor = Index;
   function Index(key, symbol, init){
      var k, this$ = this instanceof ctor$ ? this : new ctor$;
      symbol || (symbol = '.');
      if (init && key instanceof Arr) {
         switch (key.items.length) {
         case 1:
            if (!((k = key.items[0]) instanceof Splat)) {
               key = Parens(k);
            }
         }
      }
      switch (symbol) {
      case '[]':
         this$.vivify = Arr;
         break;
      case '{}':
         this$.vivify = Obj;
         break;
      default:
         if ('=' === symbol.slice(-1)) {
            this$.assign = symbol.slice(1);
         }
      }
      this$.key = key;
      this$.symbol = symbol;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Index.prototype.children = ['key'];
   Index.prototype.show = function(){
      return [this.soak ? '?' : void 8] + this.symbol;
   };
   Index.prototype.isComplex = function(){
      return this.key.isComplex() || this.vivify != null;
   };
   Index.prototype.varName = function(){
      var ref$;
      return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) && this.key.varName();
   };
   Index.prototype.compile = function(o){
      var code;
      code = this.key.compile(o, LEVEL_PAREN);
      if (this.key instanceof Key && "'" !== code.toString().charAt(0)) {
         return sn(this, ".", code);
      } else {
         return sn(this, "[", code, "]");
      }
   };
   return Index;
}(Node));
exports.Slice = Slice = (function(superclass){
   var prototype = extend$((import$(Slice, superclass).displayName = 'Slice', Slice), superclass).prototype, constructor = Slice;
   function Slice(arg$){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
      this$.from == null && (this$.from = Literal(0));
      if (this$.to && this$.type === 'to') {
         this$.to = Binary('+', this$.to, Literal('1'));
      }
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Slice.prototype.children = ['target', 'from', 'to'];
   Slice.prototype.show = function(){
      return this.type;
   };
   Slice.prototype.compileNode = function(o){
      var args;
      if (this.to && this.type === 'to') {
         this.to = Binary('||', this.to, Literal('9e9'));
      }
      args = [this.target, this.from];
      if (this.to) {
         args.push(this.to);
      }
      return Chain(JS('[].slice')).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
   };
   return Slice;
}(Node));
exports.Chain = Chain = (function(superclass){
   var prototype = extend$((import$(Chain, superclass).displayName = 'Chain', Chain), superclass).prototype, constructor = Chain;
   function Chain(head, tails){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      if (!tails && head instanceof Chain) {
         return head;
      }
      this$.head = head;
      this$.tails = tails || [];
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Chain.prototype.children = ['head', 'tails'];
   Chain.prototype.add = function(it){
      var last, ref$, index, ref1$, bi, logics, call, f;
      if (this.tails.length) {
         last = (ref$ = this.tails)[ref$.length - 1];
         if (last instanceof Call && ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 && it.args.length === 1) {
            index = last.partialized[0].head.value;
            delete last.partialized;
            last.args[index] = it.args[0];
            return this;
         }
      }
      if (this.head instanceof Existence) {
         ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
         it.soak = true;
      }
      this.tails.push(it);
      bi = this.head instanceof Parens && this.head.it instanceof Binary && !this.head.it.partial
         ? this.head.it
         : this.head instanceof Binary && !this.head.partial ? this.head : void 8;
      if (this.head instanceof Super) {
         if (!this.head.called && it instanceof Call && !it.method) {
            it.method = '.call';
            it.args.unshift(Literal('this'));
            this.head.called = true;
         } else if (!this.tails[1] && ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
            this.head.sproto = true;
         }
      } else if (it instanceof Call && this.tails.length === 1 && bi && (logics = ['&&', '||', 'xor']).includes(bi.op)) {
         call = it;
         f = function(x, key){
            var y;
            y = x[key];
            if (y instanceof Binary && logics.includes(y.op)) {
               f(y, 'first');
               return f(y, 'second');
            } else {
               return x[key] = Chain(y).autoCompare(call.args);
            }
         };
         f(bi, 'first');
         f(bi, 'second');
         return bi;
      }
      return this;
   };
   Chain.prototype.autoCompare = function(target){
      var test;
      if (!this.tails.length) {
         test = this.head;
      }
      switch (false) {
      case !(test instanceof Literal):
         return Binary('===', test, target[0]);
      case !(test instanceof Unary && test.it instanceof Literal):
         return Binary('===', test, target[0]);
      case !(test instanceof Arr || test instanceof Obj):
         return Binary('====', test, target[0]);
      case !(test instanceof Var && test.value === '_'):
         return Literal('true');
      default:
         return this.add(Call(target)) || [];
      }
   };
   Chain.prototype.flipIt = function(){
      this.flip = true;
      return this;
   };
   Chain.prototype.unwrap = function(){
      return this.tails.length ? this : this.head;
   };
   prototype.delegate(['getJump', 'assigns', 'isStatement', 'isString'], function(it, arg){
      return !this.tails.length && this.head[it](arg);
   });
   Chain.prototype.isComplex = function(){
      return this.tails.length || this.head.isComplex();
   };
   Chain.prototype.isCallable = function(){
      var that, ref$;
      if (that = (ref$ = this.tails)[ref$.length - 1]) {
         return !((ref$ = that.key) != null && ref$.items);
      } else {
         return this.head.isCallable();
      }
   };
   Chain.prototype.isArray = function(){
      var that, ref$;
      if (that = (ref$ = this.tails)[ref$.length - 1]) {
         return that.key instanceof Arr;
      } else {
         return this.head.isArray();
      }
   };
   Chain.prototype.isRegex = function(){
      return this.head.value === 'RegExp' && !this.tails[1] && this.tails[0] instanceof Call;
   };
   Chain.prototype.isAssignable = function(){
      var tail, ref$, i$, len$;
      if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
         return this.head.isAssignable();
      }
      if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
         return false;
      }
      for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
         if (ref$[i$].assign) {
            return false;
         }
      }
      return true;
   };
   Chain.prototype.isSimpleAccess = function(){
      return this.tails.length === 1 && !this.head.isComplex() && !this.tails[0].isComplex();
   };
   Chain.prototype.makeReturn = function(){
      var ref$;
      if (this.tails.length) {
         return superclass.prototype.makeReturn.apply(this, arguments);
      } else {
         return (ref$ = this.head).makeReturn.apply(ref$, arguments);
      }
   };
   Chain.prototype.getCall = function(){
      var tail, ref$;
      return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call && tail;
   };
   Chain.prototype.varName = function(){
      var ref$, ref1$;
      return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
   };
   Chain.prototype.cacheReference = function(o){
      var name, ref$, base, bref, nref, key;
      name = (ref$ = this.tails)[ref$.length - 1];
      if (!this.isAssignable()) {
         return this.unwrap().cache(o, true);
      }
      if (this.tails.length < 2 && !this.head.isComplex() && !(name != null && name.isComplex())) {
         return [this, this];
      }
      base = Chain(this.head, this.tails.slice(0, -1));
      if (base.isComplex()) {
         ref$ = base.unwrap().cache(o, true), base = ref$[0], bref = ref$[1];
         base = Chain(base);
      }
      if (!name) {
         return [base, bref];
      }
      nref = name;
      if (name.symbol !== '.') {
         nref = name;
         name = Index(name.key, '.');
      }
      if (name.isComplex()) {
         ref$ = name.key.unwrap().cache(o, true, void 8, 'key'), key = ref$[0], nref.key = ref$[1];
         name = Index(key);
      }
      return [base.add(name), Chain(bref || base.head, [nref])];
   };
   Chain.prototype.compileNode = function(o){
      var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
      if (this.flip) {
         util('flip');
         util('curry');
      }
      head = this.head, tails = this.tails;
      head.front = this.front;
      head.newed = this.newed;
      if (!tails.length) {
         return head.compile(o);
      }
      if (that = this.unfoldAssign(o)) {
         return that.compile(o);
      }
      for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
         t = tails[i$];
         if (t.partialized) {
            hasPartial = true;
            break;
         }
      }
      if (hasPartial) {
         // util('slice');
         pre = [];
         rest = [];
         for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
            t = tails[i$];
            broken = broken || t.partialized != null;
            if (broken) {
               rest.push(t);
            } else {
               pre.push(t);
            }
         }
         if (rest != null) {
            partial = rest[0], post = slice$.call(rest, 1);
         }
         this.tails = pre;
         context = pre.length
            ? Chain(head, slice$.call(pre, 0, -1))
            : Literal('this');
         return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial.partialized)])])), post).compile(o);
      }
      if (tails[0] instanceof Call && !head.isCallable()) {
         this.carp('invalid callee');
      }
      this.expandVivify();
      this.expandBind(o);
      this.expandSplat(o);
      this.expandStar(o);
      if (this.splattedNewArgs) {
         idt = o.indent + TAB;
         func = Chain(this.head, tails.slice(0, -1));
         return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
      }
      if (!this.tails.length) {
         return this.head.compile(o);
      }
      base = [this.head.compile(o, LEVEL_CALL)];
      news = [];
      rest = [];
      for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
         t = ref$[i$];
         if (t['new']) {
            news.push('new ');
         }
         rest.push(t.compile(o));
      }
      if ('.' === rest.join("").charAt(0) && SIMPLENUM.test(base[0].toString())) {
         base.push(' ');
      }
      return sn.apply(null, [null].concat(arrayFrom$(news), arrayFrom$(base), arrayFrom$(rest)));
   };
   Chain.prototype.unfoldSoak = function(o){
      var that, ref$, i$, len$, node, ref1$, bust, test;
      if (that = this.head.unfoldSoak(o)) {
         (ref$ = that.then.tails).push.apply(ref$, this.tails);
         return that;
      }
      for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
         node = ref$[i$];
         if (ref1$ = node.soak, delete node.soak, ref1$) {
            bust = Chain(this.head, this.tails.splice(0, i$));
            if (node.assign && !bust.isAssignable()) {
               node.carp('invalid accessign');
            }
            if (i$ && (node.assign || node instanceof Call)) {
               ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
               if (bust instanceof Chain) {
                  (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
                  bust = bust.head;
               }
               this.head = bust;
            } else {
               ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
            }
            test = node instanceof Call
               ? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
               : Existence(test);
            return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
         }
      }
   };
   Chain.prototype.unfoldAssign = function(o){
      var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
      if (that = this.head.unfoldAssign(o)) {
         (ref$ = that.right.tails).push.apply(ref$, this.tails);
         return that;
      }
      for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
         i = i$;
         index = ref$[i$];
         if (op = index.assign) {
            index.assign = '';
            left = Chain(this.head, this.tails.splice(0, i)).unwrap();
            if (left instanceof Arr) {
               lefts = left.items;
               rites = (this.head = Arr()).items;
               for (j$ = 0, len1$ = lefts.length; j$ < len1$; ++j$) {
                  i = j$;
                  node = lefts[j$];
                  ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
               }
            } else {
               ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
            }
            if (op === '=') {
               op = ':=';
            }
            return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
         }
      }
   };
   Chain.prototype.expandSplat = function(o){
      var tails, i, call, args, ctx, ref$;
      tails = this.tails;
      i = -1;
      while (call = tails[++i]) {
         if (!(args = call.args)) {
            continue;
         }
         ctx = call.method === '.call' && (args = args.concat()).shift();
         if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
            continue;
         }
         if (call['new']) {
            this.splattedNewArgs = args;
         } else {
            if (!ctx && tails[i - 1] instanceof Index) {
               ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
               i = 0;
            }
            call.method = '.apply';
            call.args = [ctx || Literal('null'), JS(args)];
         }
      }
   };
   Chain.prototype.expandVivify = function(){
      var tails, i, that, ref$, ref1$;
      tails = this.tails;
      i = 0;
      while (i < tails.length) {
         if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
            this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
            i = 0;
         }
      }
   };
   Chain.prototype.expandBind = function(o){
      var tails, i, that, obj, key, call;
      tails = this.tails;
      i = -1;
      while (that = tails[++i]) {
         if (that.symbol !== '.~') {
            continue;
         }
         that.symbol = '';
         obj = Chain(this.head, tails.splice(0, i)).unwrap();
         key = tails.shift().key;
         call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
         this.head = this.newed ? Parens(call, true) : call;
         i = -1;
      }
   };
   Chain.prototype.expandStar = function(o){
      var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
      tails = this.tails;
      i = -1;
      while (that = tails[++i]) {
         if (that.args || that.stars || that.key instanceof Key) {
            continue;
         }
         stars = that.stars = [];
         that.eachChild(seek);
         if (!stars.length) {
            continue;
         }
         ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
         value = Chain(ref, [Index(Key('length'))]).compile(o);
         for (i$ = 0, len$ = stars.length; i$ < len$; ++i$) {
            star = stars[i$];
            star.value = value;
            star.isAssignable = YES;
         }
         this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
         if (temps) {
            o.scope.free(temps[0]);
         }
         i = -1;
      }
      function seek(it){
         if (it.value === '*') {
            stars.push(it);
         } else if (!(it instanceof Index)) {
            it.eachChild(seek);
         }
      }
   };
   Chain.prototype.rewriteShorthand = function(o, assign){
      var that, lastI, i$, ref$, len$, i, item;
      if (that = this.unfoldSoak(o)) {
         return that.rewriteShorthand(o, assign) || that;
      }
      if (that = this.head.rewriteShorthand(o)) {
         this.head = that;
      }
      lastI = this.tails.length - 1;
      for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
         i = i$;
         item = ref$[i$];
         if (that = item.rewriteShorthand(o, assign && i === lastI)) {
            this.tails[i] = that;
         }
      }
      this.expandSlice(o, assign);
      return this.unwrap();
   };
   Chain.prototype.expandSlice = function(o, assign){
      var tails, i, tail, ref$, x;
      tails = this.tails;
      i = -1;
      while (tail = tails[++i]) {
         if ((ref$ = tail.key) != null && ref$.items) {
            if (tails[i + 1] instanceof Call) {
               tail.carp('calling a slice');
            }
            x = tails.splice(0, i + 1);
            x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
            this.head = (x.front = this.front, x);
            i = -1;
         }
      }
      return this;
   };
   Chain.prototype.extractKeyRef = function(o, assign){
      var ref$, ref1$, ref2$;
      return ((ref$ = (ref2$ = this.tails)[ref2$.length - 1]) != null ? (ref1$ = ref$.key) != null ? ref1$.extractKeyRef(o, assign) : void 8 : void 8) || superclass.prototype.extractKeyRef.apply(this, arguments);
   };
   return Chain;
}(Node));
exports.Call = Call = (function(superclass){
   var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;
   function Call(args){
      var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
      args || (args = []);
      if (args.length === 1 && (splat = args[0]) instanceof Splat) {
         if (splat.filler) {
            this$.method = '.call';
            args[0] = Literal('this');
            args[1] = Splat(Literal('arguments'));
         } else if (splat.it instanceof Arr) {
            args = splat.it.items;
         }
      } else {
         for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
            i = i$;
            a = args[i$];
            if (a.value === '_') {
               args[i] = Chain(Literal('void'));
               args[i].placeholder = true;
               ((ref$ = this$.partialized) != null
                  ? ref$
                  : this$.partialized = []).push(Chain(Literal(i)));
            }
         }
      }
      this$.args = args;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Call.prototype.children = ['args'];
   Call.prototype.show = function(){
      return [this.new] + [this.method] + [this.soak ? '?' : void 8];
   };
   Call.prototype.compile = function(o){
      var code, i$, ref$, len$, i, a;
      code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
      for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {
         i = i$;
         a = ref$[i$];
         code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
      }
      code.push(sn(this, ')'));
      return sn.apply(null, [null].concat(arrayFrom$(code)));
   };
   Call.make = function(callee, args, opts){
      var call;
      call = Call(args);
      if (opts) {
         import$(call, opts);
      }
      return Chain(callee).add(call);
   };
   Call.block = function(fun, args, method){
      var ref$, ref1$;
      return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
   };
   Call.back = function(params, node, bound, curried, hushed, generator){
      var fun, ref$, args, index, i$, len$;
      fun = Fun(params, void 8, bound, curried, hushed, generator);
      if (node instanceof Label) {
         fun.name = node.label;
         fun.labeled = true;
         node = node.it;
      }
      if (!fun.hushed && (fun.hushed = node.op === '!')) {
         node = node.it;
      }
      if ((ref$ = node.getCall()) != null) {
         ref$.partialized = null;
      }
      args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
      index = 0;
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
         if (args[i$].placeholder) {
            break;
         }
         ++index;
      }
      return node.back = (args[index] = fun).body, node;
   };
   Call.let = function(args, body){
      var hasYield, hasAwait, params, i$, len$, a, that, gotThis;
      hasYield = false;
      hasAwait = false;
      body.traverseChildren(child => {
         if (child instanceof Yield) {
            switch (child.op) {
            case 'yield':
            case 'yieldfrom':
               hasYield = true;
               break;
            case 'await':
               hasAwait = true;
            }
         }
         if (hasYield && hasAwait) {
            return true;
         }
      });
      params = [];
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
         a = args[i$];
         if (that = a.op === '=' && !a.logic && a.right) {
            args[i$] = that;
            if (i$ === 0 && (gotThis = a.left.value === 'this')) {
               continue;
            }
            params.push(a.left);
         } else {
            params.push(Var(a.varName() || a.carp('invalid "let" argument')));
         }
      }
      gotThis || args.unshift(Literal('this'));
      body = this.block(Fun(params, body, null, null, null, hasYield, hasAwait), args, '.call');
      return hasYield || hasAwait
         ? Block(Yield(hasYield ? 'yieldfrom' : 'await', body))
         : body;
   };
   return Call;
}(Node));
List = (function(superclass){
   var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List;
   List.prototype.children = ['items'];
   List.prototype.show = function(){
      return this.name;
   };
   List.prototype.named = function(name){
      this.name = name;
      return this;
   };
   List.prototype.isEmpty = function(){
      return !this.items.length;
   };
   List.prototype.assigns = function(){
      var x$, i$, ref$, len$, that, j$, len1$;
      x$ = [];
      for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
         if (that = ref$[i$].assigns()) {
            for (j$ = 0, len1$ = that.length; j$ < len1$; ++j$) {
               x$.push(that[j$]);
            }
         }
      }
      if (that = this.name) {
         x$.push(that);
      }
      return x$;
   };
   List.compile = function(o, items, deepEq){
      var indent, level, code, i, that, target;
      switch (items.length) {
      case 0:
         return '';
      case 1:
         return items[0].compile(o, LEVEL_LIST);
      }
      indent = o.indent, level = o.level;
      o.indent = indent + TAB;
      o.level = LEVEL_LIST;
      code = [items[i = 0].compile(o)];
      while (that = items[++i]) {
         code.push(', ');
         target = that;
         if (deepEq) {
            if (target instanceof Var && target.value === '_') {
               target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
            } else if (target instanceof Obj || target instanceof Arr) {
               target.deepEq = true;
            }
         }
         code.push(target.compile(o));
      }
      if (~code.join("").indexOf('\n')) {
         code = ["\n" + o.indent].concat(arrayFrom$(code), ["\n" + indent]);
      }
      o.indent = indent;
      o.level = level;
      return sn.apply(null, [this].concat(arrayFrom$(code)));
   };
   List.prototype.toSlice = function(o, base, symbol, assign){
      var items, isObj, ref$, ref, temps, i$, len$, i, item, val, splat, chain;
      items = this.items;
      isObj = this instanceof Obj;
      if (items.length > 1) {
         ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
      } else {
         ref = base;
      }
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
         i = i$;
         item = items[i$];
         if (!item.comment) {
            if (isObj) {
               val = item.val;
               if (!(val instanceof List)) {
                  (val = val.maybeKey()) || this.carp("value in object slice is not a key");
               }
            } else {
               val = item;
               if (splat = val instanceof Splat) {
                  val = val.it;
               }
               if (val.isEmpty()) {
                  continue;
               }
            }
            chain = val instanceof List
               ? val.toSlice(o, base, symbol, assign)
               : Chain(base, [Index(val, symbol)]);
            if (isObj) {
               item.val = chain;
            } else {
               items[i] = splat ? Splat(chain) : chain;
            }
            base = ref;
         }
      }
      chain || this.carp('empty slice');
      if (temps) {
         (this.temps || (this.temps = [])).push(temps[0]);
      }
      return this;
   };
   List.prototype.extractKeyRef = function(){
      return this.name != null ? key(this.name) : superclass.prototype.extractKeyRef.apply(this, arguments);
   };
   function List(){
      List.superclass.apply(this, arguments);
   }
   return List;
}(Node));
exports.Obj = Obj = (function(superclass){
   var prototype = extend$((import$(Obj, superclass).displayName = 'Obj', Obj), superclass).prototype, constructor = Obj;
   function Obj(items){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.items = items || [];
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Obj.prototype.asObj = THIS;
   Obj.prototype.compileNode = function(o){
      var items, code, idt, dic, i$, len$, node, ref$, rest, multi, key, val;
      if (this.name != null) {
         this.carp("unexpected label");
      }
      items = this.items;
      if (!items.length) {
         return sn(this, this.front ? '({})' : '{}');
      }
      code = [];
      idt = '\n' + (o.indent += TAB);
      dic = {};
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
         node = items[i$];
         if (node.comment) {
            code.push(idt, node.compile(o));
            continue;
         }
         if ((ref$ = node.key) instanceof Splat || ref$ instanceof Parens) {
            rest = items.slice(i$);
            break;
         }
         if (node.logic) {
            node.val = (ref$ = node.logic, ref$.first = node.val, ref$);
         }
         if (this.deepEq) {
            if (node.val instanceof Var && node.val.value === '_') {
               node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
            } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
               node.val.deepEq = true;
            }
         }
         if (multi) {
            code.push(',');
         } else {
            multi = true;
         }
         code.push(idt);
         key = node.key, val = node.val;
         if (node.accessor) {
            code.push(node.compileAccessor(o, key = key.compile(o)));
         } else {
            val.ripName(key);
            code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
         }
         ID.test(key) || (key = Function("return " + key)());
         if (!(dic[key + "."] ^= 1)) {
            node.carp("duplicate property \"" + key + "\"");
         }
      }
      if (code.join("")) {
         code.push('\n' + this.tab);
      }
      code = sn.apply(null, [null, sn(this, "{")].concat(arrayFrom$(code), [sn(this, "}")]));
      rest && (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
      if (this.front && '{' === code.toString().charAt()) {
         return sn(null, "(", code, ")");
      } else {
         return code;
      }
   };
   return Obj;
}(List));
exports.Prop = Prop = (function(superclass){
   var prototype = extend$((import$(Prop, superclass).displayName = 'Prop', Prop), superclass).prototype, constructor = Prop;
   function Prop(key, val){
      var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.key = key;
      this$.val = val;
      if ((key != null ? key.value : void 8) === '...') {
         this$.key = Splat();
      }
      if (that = val.getAccessors()) {
         this$.val = that;
         for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
            fun = that[i$];
            fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
         }
         this$['accessor'] = 'accessor';
      }
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Prop.prototype.children = ['key', 'val', 'logic'];
   Prop.prototype.show = function(){
      return this.accessor;
   };
   Prop.prototype.assigns = function(){
      var ref$;
      return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns() : void 8;
   };
   Prop.prototype.compileAccessor = function(o, key){
      var funs, code, i$, len$, fun, body;
      funs = this.val;
      if (funs[1] && funs[0].params.length + funs[1].params.length !== 1) {
         funs[0].carp('invalid accessor parameter');
      }
      code = [];
      for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
         fun = funs[i$];
         if (fun.bound) {
            fun.carp("can't use arrow function for accessor")
         }
         fun.accessor = true;
         body = fun.compile(o, LEVEL_LIST).toString().slice(8);
         code.push(fun.x, "et ", key, body, ',\n' + o.indent);
      }
      code.pop();
      return sn.apply(null, [null].concat(arrayFrom$(code)));
   };
   Prop.prototype.compileDescriptor = function(o){
      var obj, i$, ref$, len$, fun;
      obj = Obj();
      for (i$ = 0, len$ = (ref$ = this.val).length; i$ < len$; ++i$) {
         fun = ref$[i$];
         obj.items.push(Prop(Key(fun.x + 'et'), fun));
      }
      obj.items.push(Prop(Key('configurable'), Literal(true)), Prop(Key('enumerable'), Literal(true)));
      return obj.compile(o);
   };
   Prop.prototype.rewriteShorthand = function(o, assign){
      var ref$, that;
      superclass.prototype.rewriteShorthand.apply(this, arguments);
      if (this.key == null && this.val instanceof Assign) {
         this.val = this.val.maybeLogic();
      }
      if (this.key == null && this.val instanceof Unary && ((ref$ = this.val.op) === '+' || ref$ === '-')) {
         this.key = this.val.it.maybeKey() || this.carp("invalid property flag shorthand");
         this.val = Literal(this.val.op === '+');
      }
      if (that = this.val instanceof Binary && this.val.getDefault()) {
         this.val = this.val.first;
         this.logic = (that.first = null, that);
      }
      this.key == null && (this.key = this.val.extractKeyRef(o, assign));
   };
   return Prop;
}(Node));
exports.Arr = Arr = (function(superclass){
   var prototype = extend$((import$(Arr, superclass).displayName = 'Arr', Arr), superclass).prototype, constructor = Arr;
   function Arr(items){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.items = items || [];
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Arr.prototype.isArray = YES;
   Arr.prototype.asObj = function(){
      return Obj(this.items.map((item, i) => Prop(Literal(i), item)))
   };
   Arr.prototype.compile = function(o){
      var items, code;
      if (this.name != null) {
         this.carp("unexpected label");
      }
      items = this.items;
      if (!items.length) {
         return sn(this, '[]');
      }
      if (!snEmpty(code = Splat.compileArray(o, items))) {
         return this.newed ? sn(this, "(", code, ")") : sn(this, code);
      }
      return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
   };
   Arr.maybe = function(nodes){
      if (nodes.length === 1 && !(nodes[0] instanceof Splat)) {
         return nodes[0];
      }
      return constructor(nodes);
   };
   Arr.wrap = function(it){
      return constructor([Splat((it.isArray = YES, it))]);
   };
   return Arr;
}(List));
exports.Yield = Yield = (function(superclass){
   var prototype = extend$((import$(Yield, superclass).displayName = 'Yield', Yield), superclass).prototype, constructor = Yield;
   function Yield(op, it){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.op = op;
      this$.it = it;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Yield.prototype.children = ['it'];
   Yield.prototype.show = function(){
      switch (this.op) {
      case 'yield':
         return '';
      case 'yieldfrom':
         return 'from';
      case 'await':
         return 'await';
      }
   };
   prototype.delegate(['isCallable'], function(){
      return true;
   });
   Yield.prototype.compileNode = function(o){
      var code;
      code = [(() => {
         switch (this.op) {
         case 'yield':
            return 'yield';
         case 'yieldfrom':
            return 'yield*';
         case 'await':
            return 'await';
         }
      })()];
      if (this.it) {
         code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
      }
      return sn(this, "(", ...code, ")");
   };
   return Yield;
}(Node));
exports.Unary = Unary = (function(superclass){
   var prototype = extend$((import$(Unary, superclass).displayName = 'Unary', Unary), superclass).prototype, constructor = Unary;
   function Unary(op, it, flag){
      var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
      if (it != null) {
         if (that = !flag && it.unaries) {
            that.push(op);
            return it;
         }
         switch (op) {
         case '!':
            if (flag) {
               break;
            }
            if (it instanceof Fun && !it.hushed) {
               return it.hushed = true, it;
            }
            return it.invert();
         case '++':
         case '--':
            if (flag) {
               this$.post = true;
            }
            break;
         case 'new':
            if (it instanceof Existence && !it.negated) {
               it = Chain(it).add(Call());
            }
            it.newed = true;
            for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ < len$; ++i$) {
               node = ref$[i$];
               if (node instanceof Call && !node['new']) {
                  if (node.method === '.call') {
                     node.args.shift();
                  }
                  node['new'] = 'new';
                  node.method = '';
                  return it;
               }
            }
            break;
         case '~':
            if (it instanceof Fun && it.statement && !it.bound) {
               return it.bound = 'this', it;
            }
            break;
         case 'do':
            if (it instanceof Existence && !it.negated) {
               return Chain(it).add(Call());
            }
         }
      }
      this$.op = op;
      this$.it = it;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Unary.prototype.children = ['it'];
   Unary.prototype.show = function(){
      return [this.post ? '@' : void 8] + this.op;
   };
   Unary.prototype.isCallable = function(){
      var ref$;
      return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
   };
   Unary.prototype.isArray = function(){
      return this.it instanceof Arr && this.it.items.length || this.it instanceof Chain && this.it.isArray();
   };
   Unary.prototype.isString = function(){
      return this.op === 'typeof' || this.op === 'classof';
   };
   Unary.prototype.invert = function(){
      var ref$;
      if (this.op === '!' && ((ref$ = this.it.op) === '!' || ref$ === '<' || ref$ === '>' || ref$ === '<=' || ref$ === '>=' || ref$ === 'of' || ref$ === 'instanceof')) {
         return this.it;
      }
      return constructor('!', this, true);
   };
   Unary.prototype.unfoldSoak = function(o){
      var ref$;
      return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete' || ref$ === 'jsdelete') && this.it != null && If.unfoldSoak(o, this, 'it');
   };
   Unary.prototype.getAccessors = function(){
      var items;
      if (this.op !== '~') {
         return;
      }
      if (this.it instanceof Fun) {
         return [this.it];
      }
      if (this.it instanceof Arr) {
         items = this.it.items;
         if (!items[2] && items[0] instanceof Fun && items[1] instanceof Fun) {
            return items;
         }
      }
   };
   function crement(it){
      return {
         '++': 'in',
         '--': 'de'
      }[it] + 'crement';
   }
   Unary.prototype.compileNode = function(o){
      var that, op, it, x, code;
      if (this.it == null) {
         return this.compileAsFunc(o);
      }
      if (that = this.compileSpread(o)) {
         return that;
      }
      op = this.op, it = this.it;
      switch (op) {
      case '!':
         it.cond = true;
         break;
      case 'new':
         it.isCallable() || it.carp('invalid constructor');
         break;
      case 'do':
         if (o.level === LEVEL_TOP && it instanceof Fun && it.isStatement()) {
            return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
         }
         x = Parens(Call.make(it));
         return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
      case 'delete':
         if (it instanceof Var || !it.isAssignable()) {
            this.carp('invalid delete');
         }
         if (o.level && !this['void']) {
            return this.compilePluck(o);
         }
         break;
      case '++':
      case '--':
         it.isAssignable() || this.carp('invalid ' + crement(op));
         if (that = it instanceof Var && o.scope.checkReadOnly(it.value)) {
            this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
         }
         if (this.post) {
            it.front = this.front;
         }
         break;
      case '^^':
         return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
      case 'jsdelete':
         return sn(this, "delete ", it.compile(o, LEVEL_LIST));
      case 'classof':
         return sn(this, this.front ? "({})" : "{}", ".toString.call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
      }
      code = [it.compile(o, LEVEL_OP + PREC.unary)];
      if (this.post) {
         code.push(op);
      } else {
         if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') && op === code.join("").charAt()) {
            op += ' ';
         }
         code.unshift(op);
      }
      if (o.level < LEVEL_CALL) {
         return sn(this, code);
      } else {
         return sn(this, "(", code, ")");
      }
   };
   Unary.prototype.compileSpread = function(o){
      var it, ops;
      it = this.it;
      ops = [this];
      for (; it instanceof constructor; it = it.it) {
         ops.push(it);
      }
      if (!(it instanceof Splat && (it = it.it) instanceof List)) {
         return '';
      }
      return this.compileSpreadOver(o, it, function(node){
         var i$, ref$, op;
         for (i$ = (ref$ = ops).length - 1; i$ >= 0; --i$) {
            op = ref$[i$];
            node = constructor(op.op, node, op.post);
         }
         return node.unfoldSoak(o) || node;
      });
   };
   Unary.prototype.compilePluck = function(o){
      var ref$, get, del, code, ref;
      ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
      code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free(ref)];
      if (o.level < LEVEL_LIST) {
         return sn(this, code);
      } else {
         return sn(this, "(", code, ")");
      }
   };
   Unary.prototype.compileAsFunc = function(o){
      if (this.op === '!') {
         return sn(this, "(x => !x)");
      } else {
         return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
      }
   };
   Unary.prototype.rewriteShorthand = function(o, assign){
      var that, ref$;
      if (that = this.unfoldSoak(o)) {
         return that.rewriteShorthand(o, assign) || that;
      }
      return superclass.prototype.rewriteShorthand.call(this, o, assign || ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete' || ref$ === 'jsdelete'));
   };
   return Unary;
}(Node));
exports.Binary = Binary = (function(superclass){
   var COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = 'Binary', Binary), superclass).prototype, constructor = Binary;
   function Binary(op, first, second){
      var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.partial = first == null || second == null;
      if (!this$.partial) {
         if ('=' === op.charAt(op.length - 1) && ((ref$ = op.charAt(op.length - 2)) !== '=' && ref$ !== '<' && ref$ !== '>' && ref$ !== '!')) {
            return Assign(first.unwrap(), second, op);
         }
         switch (op) {
         case 'in':
            return new In(first, second);
         case 'with':
            return new Import(Unary('^^', first), second, false);
         case '<<<':
         case '<<<<':
            return Import(first, second, op === '<<<<');
         case '<|':
            return Block(first).pipe(second, op);
         case '|>':
            return Block(second).pipe(first, '<|');
         case '.':
         case '.~':
            return Chain(first).add(Index(second, op));
         }
      }
      this$.op = op;
      this$.first = first;
      this$.second = second;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Binary.prototype.children = ['first', 'second'];
   Binary.prototype.show = function(){
      return this.op;
   };
   Binary.prototype.isCallable = function(){
      var ref$;
      return this.partial || ((ref$ = this.op) === '&&' || ref$ === '||' || ref$ === '?' || ref$ === '<<' || ref$ === '>>') && this.first.isCallable() && this.second.isCallable();
   };
   Binary.prototype.isArray = function(){
      switch (this.op) {
      case '*':
         return this.first.isArray();
      case '/':
         return this.second.isMatcher();
      }
   };
   Binary.prototype.isString = function(){
      switch (this.op) {
      case '+':
      case '*':
         return this.first.isString() || this.second.isString();
      case '-':
         return this.second.isMatcher();
      }
   };
   COMPARER = /^(?:[!=]=|[<>])=?$/;
   INVERSIONS = {
      '===': '!==',
      '!==': '===',
      '==': '!=',
      '!=': '=='
   };
   Binary.prototype.invert = function(){
      var that;
      if (that = !COMPARER.test(this.second.op) && INVERSIONS[this.op]) {
         this.op = that;
         this.wasInverted = true;
         return this;
      }
      return Unary('!', Parens(this), true);
   };
   Binary.prototype.invertIt = function(){
      this.inverted = true;
      return this;
   };
   Binary.prototype.getDefault = function(){
      switch (this.op) {
      case '?':
      case '||':
      case '&&':
         return this;
      }
   };
   Binary.prototype.assigns = function(){
      var ref$;
      return (ref$ = this.getDefault()) != null ? ref$.first.assigns() : void 8;
   };
   Binary.prototype.xorChildren = function(test){
      var ref$, first;
      if (!(!(first = test(this.first)) !== !(ref$ = test(this.second)) && (first || ref$))) {
         return false;
      }
      return first
         ? [this.first, this.second]
         : [this.second, this.first];
   };
   Binary.prototype.compileNode = function(o){
      var top, rite, items, that, ref$, code, level;
      if (this.partial) {
         return this.compilePartial(o);
      }
      switch (this.op) {
      case '?':
         return this.compileExistence(o);
      case '*':
         if (this.second.isString()) {
            return this.compileJoin(o);
         }
         if (this.first.isString() || this.first.isArray()) {
            return this.compileRepeat(o);
         }
         break;
      case '-':
         if (this.second.isMatcher()) {
            return this.compileRemove(o);
         }
         break;
      case '/':
         if (this.second.isMatcher()) {
            return this.compileSplit(o);
         }
         break;
      case '**':
      case '^':
         return this.compilePow(o);
      case '<?':
      case '>?':
         return this.compileMinMax(o);
      case '<<':
      case '>>':
         return this.compileCompose(o);
      case '++':
         return this.compileConcat(o);
      case '%%':
         return this.compileMod(o);
      case 'xor':
         return this.compileXor(o);
      case '&&':
      case '||':
         if (top = this['void'] || !o.level) {
            this.second['void'] = true;
         }
         if (top || this.cond) {
            this.first.cond = true;
            this.second.cond = true;
         }
         break;
      case 'instanceof':
         rite = this.second, items = rite.items;
         if (rite instanceof Arr) {
            if (items[1]) {
               return this.compileAnyInstanceOf(o, items);
            }
            this.second = items[0] || rite;
         }
         this.second.isCallable() || this.second.carp('invalid instanceof operand');
         break;
      case '====':
      case '!===':
         this.op = this.op.slice(0, 3);
         // fallthrough
      case '<==':
      case '>==':
      case '<<=':
      case '>>=':
         return this.compileDeepEq(o);
      default:
         if (COMPARER.test(this.op)) {
            if (that = ((ref$ = this.op) === '===' || ref$ === '!==') && this.xorChildren(function(it){
               return it.isRegex();
            })) {
               return this.compileRegexEquals(o, that);
            }
            if (this.op === '===' && (this.first instanceof Literal && this.second instanceof Literal) && this.first.isWhat() !== this.second.isWhat()) {
               if (o.warn) {
                  this.warn("strict comparison of two different types will always be false: " + this.first.value + " == " + this.second.value);
               }
            }
         }
         if (COMPARER.test(this.op) && COMPARER.test(this.second.op)) {
            return this.compileChain(o);
         }
      }
      this.first.front = this.front;
      code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
      if (o.level <= level) {
         return sn.apply(null, [this].concat(arrayFrom$(code)));
      } else {
         return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
      }
   };
   Binary.prototype.mapOp = function(op){
      var that;
      switch (false) {
      case !(that = op.match(/\.([&\|\^]|<<|>>>?)\./)):
         return that[1];
      case op !== 'of':
         return 'in';
      default:
         return op;
      }
   };
   Binary.prototype.compileChain = function(o){
      var code, level, ref$, sub;
      code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
      ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
      code.push(" ", this.op, " ", sub.compile(o, level), " && ", this.second.compile(o, LEVEL_OP));
      if (o.level <= LEVEL_OP) {
         return sn.apply(null, [this].concat(arrayFrom$(code)));
      } else {
         return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
      }
   };
   Binary.prototype.compileExistence = function(o){
      var x;
      if (this['void'] || !o.level) {
         x = Binary('&&', Existence(this.first, true), Parens(this.second.unwrap()));
         return (x['void'] = true, x).compileNode(o);
      }
      x = this.first.cache(o, true);
      return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
   };
   Binary.prototype.compileAnyInstanceOf = function(o, items){
      var ref$, sub, ref, test, i$, len$, item;
      ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
      test = Binary('instanceof', sub, items.shift());
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
         item = items[i$];
         test = Binary('||', test, Binary('instanceof', ref, item));
      }
      return sn(this, Parens(test).compile(o));
   };
   Binary.prototype.compileMinMax = function(o){
      var lefts, rites, x;
      lefts = this.first.cache(o, true);
      rites = this.second.cache(o, true);
      x = Binary(this.op.charAt(), lefts[0], rites[0]);
      return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
   };
   Binary.prototype.compileMethod = function(o, klass, literal, method, arg){
      var args;
      args = [this.second].concat(arg || []);
      if (this.first["is" + klass]()) {
         return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
      } else {
         args.unshift(this.first);
         return sn(this, Call.make(JS(literal + '.' + method + '.call'), args).compile(o));
      }
   };
   Binary.prototype.compileJoin = function(it){
      return this.compileMethod(it, 'Array', '[]', 'join');
   };
   Binary.prototype.compileRemove = function(it){
      return this.compileMethod(it, 'String', '""', 'replace', JS("''"));
   };
   Binary.prototype.compileSplit = function(it){
      return this.compileMethod(it, 'String', '""', 'split');
   };
   Binary.prototype.compileRepeat = function(o){
      var x, items, n, arr, arrCode, refs, i$, len$, i, item, ref$, q;
      x = this.first, items = x.items, n = this.second;
      arr = x.isArray() && 'Array';
      if (items && !snEmpty(arrCode = Splat.compileArray(o, items))) {
         x = JS(arrCode);
         items = null;
      }
      if (arr && !items || !(n instanceof Literal && n.value < 2)) {
         return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
      }
      n = +n.value;
      if (1 <= n && n < 2) {
         return sn(this, x.compile(o));
      }
      if (items) {
         if (n < 1) {
            return sn(this, Block(items).add(JS('[]')).compile(o));
         }
         refs = [];
         for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
            i = i$;
            item = items[i$];
            ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
         }
         items.push((ref$ = JS(), ref$.compile = function(){
            return sn.apply(null, [this].concat(arrayFrom$((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
         }, ref$));
         return sn(this, x.compile(o));
      } else if (x instanceof Literal) {
         return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
      } else {
         if (n < 1) {
            return sn(this, Block(x.it).add(JS("''")).compile(o));
         }
         x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
         if (o.level < LEVEL_OP + PREC['+']) {
            return sn(this, x);
         } else {
            return sn(this, "(", x, ")");
         }
      }
   };
   Binary.prototype.compilePow = function(o){
      return sn(null, this.first.compile(o), ' ** ', this.second.compile(o));
   };
   Binary.prototype.compileConcat = function(o){
      var f;
      f = function(x){
         switch (false) {
         case !(x instanceof Binary && x.op === '++'):
            return f(x.first).concat(f(x.second));
         default:
            return [x];
         }
      };
      return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
   };
   Binary.prototype.compileCompose = function(o){
      var op, functions, x;
      op = this.op;
      functions = [this.first];
      x = this.second;
      while (x instanceof Binary && x.op === op && !x.partial) {
         functions.push(x.first);
         x = x.second;
      }
      functions.push(x);
      if (op === '<<') {
         functions.reverse();
      }
      return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
   };
   Binary.prototype.compileMod = function(o){
      var ref, code;
      ref = o.scope.temporary();
      code = [sn(this, "(("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ", ref, ") % ", ref)];
      o.scope.free(ref);
      if (o.level < LEVEL_OP + PREC['%']) {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      } else {
         return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
      }
   };
   Binary.prototype.compilePartial = function(o){
      var vit, x, y;
      vit = Var('it');
      switch (false) {
      case !(this.first == null && this.second == null):
         x = Var('x$');
         y = Var('y$');
         return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), true).compile(o));
      case this.first == null:
         return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
      default:
         return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
      }
   };
   Binary.prototype.compileRegexEquals = function(o, arg$){
      var regex, target, method;
      regex = arg$[0], target = arg$[1];
      if (this.op === '===') {
         method = this.wasInverted ? 'test' : 'exec';
         return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
      } else {
         return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
      }
   };
   Binary.prototype.compileDeepEq = function(o){
      var ref$, negate, i$, len$, x, r;
      if ((ref$ = this.op) === '>==' || ref$ === '>>=') {
         ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
         this.op = this.op === '>==' ? '<==' : '<<=';
      }
      if (this.op === '!==') {
         this.op = '===';
         negate = true;
      }
      for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ < len$; ++i$) {
         x = ref$[i$];
         if (x instanceof Obj || x instanceof Arr) {
            x.deepEq = true;
         }
      }
      r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
      return sn(this, (negate ? Unary('!', r) : r).compile(o));
   };
   Binary.prototype.compileXor = function(o){
      var left, right;
      left = Chain(this.first).cacheReference(o);
      right = Chain(this.second).cacheReference(o);
      return sn(this, Binary('&&', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).compile(o));
   };
   Binary.prototype.rewriteShorthand = function(o, assign){
      var that;
      if (this.partial) {
         return superclass.prototype.rewriteShorthand.apply(this, arguments);
      }
      if (that = this.first.rewriteShorthand(o, assign)) {
         this.first = that;
      }
      if (that = this.second.rewriteShorthand(o)) {
         this.second = that;
      }
   };
   return Binary;
}(Node));
exports.Assign = Assign = (function(superclass){
   var prototype = extend$((import$(Assign, superclass).displayName = 'Assign', Assign), superclass).prototype, constructor = Assign;
   function Assign(left, rite, op, logic, defParam){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.left = left;
      this$.op = op || '=';
      this$.logic = logic || this$.op.logic;
      this$.defParam = defParam;
      this$.opLoc = this$.op;
      this$.op += '';
      this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Assign.prototype.children = ['left', 'right'];
   Assign.prototype.show = function(){
      return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
   };
   Assign.prototype.assigns = function(){
      return this.left.assigns();
   };
   Assign.prototype.getRef = function(){
      if (!this.left.isComplex()) {
         return this.left;
      }
   };
   prototype.delegate(['isCallable', 'isRegex'], function(it){
      var ref$;
      return ((ref$ = this.op) === '=' || ref$ === ':=') && this.right && this.right[it]();
   });
   Assign.prototype.isArray = function(){
      switch (this.op) {
      case '=':
      case ':=':
         return this.right && this.right.isArray();
      case '/=':
         return this.right && this.right.isMatcher();
      }
   };
   Assign.prototype.isString = function(){
      switch (this.op) {
      case '=':
      case ':=':
      case '+=':
      case '*=':
         return this.right && this.right.isString();
      case '-=':
         return this.right && this.right.isMatcher();
      }
   };
   Assign.prototype.unfoldSoak = function(o){
      var that, ref$, ref1$, rite, temps;
      if (this.left instanceof Existence) {
         if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
            rite = this.right;
            rite = Assign(this.right = Var(that), rite);
         } else {
            ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
         }
         return ref$ = If(Existence(rite), this), ref$.soak = true, ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
      }
      return If.unfoldSoak(o, this, 'left');
   };
   Assign.prototype.unfoldAssign = function(){
      return this.access && this;
   };
   Assign.prototype.compileNode = function(o){
      var that, left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, protoSplit, dotSplit, code, empty, res;
      if (that = this.unfoldSoak(o)) {
         return that.compile(o);
      }
      if (this.left instanceof Slice && this.op === '=') {
         return this.compileSplice(o);
      }
      left = this.left;
      if (sp = this.left instanceof Splat) {
         left = left.it;
      }
      if (sp) {
         left instanceof List || this.left.carp('invalid splat');
         return this.compileSpread(o, left);
      }
      if (!this.right) {
         left.isAssignable() || left.carp('invalid unary assign');
         ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
         for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ < len$; ++i$) {
            op = ref$[i$];
            this.right = Unary(op, this.right);
         }
      }
      if (left.isEmpty()) {
         return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
      }
      if (left.getDefault()) {
         this.right = Binary(left.op, this.right, left.second);
         left = left.first;
      }
      if (left.soak) {
         this.left = left.then;
         left.then = this;
         return left.compile(o);
      }
      if (left.items) {
         return this.compileDestructuring(o, left);
      }
      left.isAssignable() || left.carp('invalid assign');
      if (this.logic) {
         return this.compileConditional(o, left);
      }
      op = this.op, right = this.right;
      if (op === '<?=' || op === '>?=') {
         return this.compileMinMax(o, left, right);
      }
      if ((op === '**=' || op === '^=' || op === '//=' || op === '%%=' || op === '++=' || op === '|>=') || op === '*=' && right.isString() || (op === '-=' || op === '/=') && right.isMatcher()) {
         ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
         right = Binary(op.slice(0, -1), reft, right);
         op = ':=';
      }
      if (op === '.&.=' || op === '.|.=' || op === '.^.=' || op === '.<<.=' || op === '.>>.=' || op === '.>>>.=') {
         op = op.slice(1, -2) + '=';
      }
      (right = right.unparen()).ripName(left = left.unwrap());
      if (left instanceof Chain) {
         left.expandVivify();
         if ((left = left.unwrap()) instanceof Assign) {
            ref$ = Chain(left.left).cacheReference(o), left.left = ref$[0], this.left = ref$[1];
            return Block([left, (ref$ = clone$(this), ref$.terminator = '', ref$)]).compile(o);
         }
      }
      sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
      name = (left.front = true, left).compile(o, LEVEL_LIST);
      if (lvar = left instanceof Var) {
         if (op === '=') {
            o.scope.declare(name.toString(), left, this['const'] || !this.defParam && o['const'] && '$' !== name.toString().slice(-1));
         } else if (that = o.scope.checkReadOnly(name.toString())) {
            left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
         }
      }
      if (left instanceof Chain && right instanceof Fun) {
         protoSplit = name.toString().split('.prototype.');
         dotSplit = name.toString().split('.');
         if (protoSplit.length > 1) {
            right.inClass = protoSplit[0];
         } else if (dotSplit.length > 1) {
            right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
         }
      }
      code = !o.level && right instanceof While && !right['else'] && (lvar || left instanceof Chain && left.isSimpleAccess())
         ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
         : [name, sign, right.compile(o, LEVEL_LIST)];
      if (o.level > LEVEL_LIST) {
         code = ["("].concat(arrayFrom$(code), [")"]);
      }
      return sn.apply(null, [null].concat(arrayFrom$(code)));
   };
   Assign.prototype.compileConditional = function(o, left){
      var ref$, lcache, morph;
      if (left instanceof Var && this.logic === '?' && this.op === '=') {
         o.scope.declare(left.value, left);
      }
      ref$ = Chain(left).cacheReference(o), lcache = ref$[0], left = ref$[1];
      o.level += LEVEL_OP < o.level;
      if (this.logic === '?' && ((ref$ = this.op) !== '=' && ref$ !== ':=')) {
         this.logic = '&&';
         lcache = Existence(lcache);
      }
      morph = Binary(this.logic, lcache, (this.logic = false, this.left = left, this));
      return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
   };
   Assign.prototype.compileMinMax = function(o, left, right){
      var lefts, rites, test, put, ref$;
      lefts = Chain(left).cacheReference(o);
      rites = right.cache(o, true);
      test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
      put = Assign(lefts[1], rites[1], ':=');
      if (this['void'] || !o.level) {
         return Parens(Binary('||', test, put)).compile(o);
      }
      ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
      return sn(this, If(test, left).addElse(put).compileExpression(o));
   };
   Assign.prototype.compileDestructuring = function(o, left){
      var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
      items = left.items, len = items.length;
      ret = o.level && !this['void'];
      rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
      if (that = left.name) {
         cache = sn(this, that, " = ", rite);
         o.scope.declare(rite = that, left);
      } else if ((ret || len > 1) && (!ID.test(rite.toString()) || ((that = left.assigns()) && that.includes(rite.toString())))) {
         cache = sn(this, rref = o.scope.temporary(), " = ", rite);
         rite = rref;
      }
      if (rite.toString() === 'arguments' && !ret) {
         destructureArgs = true;
         if (!(left instanceof Arr)) {
            this.carp('arguments can only destructure to array');
         }
      }
      list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
      if (rref) {
         o.scope.free(rref);
      }
      if (cache) {
         list.unshift(cache);
      }
      if (ret || !list.length) {
         list.push(rite);
      }
      code = [];
      sep = destructureArgs ? '; ' : ', ';
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
         item = list[i$];
         code.push(item, sep);
      }
      code.pop();
      if ((o.level < LEVEL_OP && list.length < 2) || o.level < LEVEL_LIST) {
         return sn.apply(null, [this].concat(arrayFrom$(code)));
      } else {
         return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
      }
   };
   Assign.prototype.compileSplice = function(o){
      var ref$, fromExpNode, fromExp, rightNode, right, toExp;
      ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
      ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
      toExp = Binary('-', this.left.to, fromExp);
      return sn(this, Block([Chain(JS('[].splice')).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(fromExpNode).add(Literal(', ')).add(toExp).add(Literal(', ')).add(rightNode)])), right]).compile(o, LEVEL_LIST));
   };
   Assign.prototype.compileSpread = function(o, left){
      var that, ref$, rite, rref, this$ = this;
      ref$ = (that = this.unaries)
         ? [that, that]
         : left.items.length <= 1
            ? [ref$ = this.right, ref$]
            : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
      return this.compileSpreadOver(o, left, function(it){
         var result;
         result = constructor(it, rite, this$.op, this$.logic);
         rite = rref;
         return result;
      });
   };
   Assign.prototype.rendArr = function(o, nodes, rite, destructureArgs){
      var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$;
      function argsSlice(begin, end){
         return new For({
            ref: true,
            from: begin,
            op: 'til',
            to: end
         }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
      }
      ret = [];
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
         i = i$;
         node = nodes[i$];
         if (node.isEmpty()) {
            continue;
         }
         if (node instanceof Splat) {
            len && node.carp('multiple splat in an assignment');
            skip = (node = node.it).isEmpty();
            if (i + 1 === (len = nodes.length)) {
               if (skip) {
                  break;
               }
               if (destructureArgs) {
                  val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
               } else {
                  val = Arr.wrap(JS('[].slice.call(' + rite + (i ? ", " + i + ")" : ')')));
               }
            } else {
               val = ivar = rite + ".length - " + (len - i - 1);
               if (skip && i + 2 === len) {
                  continue;
               }
               start = i + 1;
               (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
               val = (fn$());
            }
         } else {
            (inc = ivar) && start < i && (inc += " + " + (i - start));
            val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
         }
         if (destructureArgs) {
            if (!(node instanceof Var) && val instanceof For) {
               (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
               vtmp = Var(tmp);
               ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
               ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
            } else {
               ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
            }
         } else {
            ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
         }
      }
      return ret;
      function fn$(){
         switch (false) {
         case !skip:
            return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
         case !destructureArgs:
            return argsSlice(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
         default:
            return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ") ? " + "[].slice.call(" + rite + ", " + i + ", " + ivar + ") : (" + ivar + " = " + i + ", [])"));
         }
      }
   };
   Assign.prototype.rendObj = function(o, nodes, rite){
      var keys, pairs, rvar, i$, len$, ref$, key, lval, logic, excludes, val, left, right, results$ = [];
      keys = [];
      pairs = [];
      rvar = Var(rite);
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
         ref$ = nodes[i$], key = ref$.key, lval = ref$.val, logic = ref$.logic;
         lval = lval.unparen();
         if (key instanceof Splat) {
            logic != null && this.carp("invalid assign");
            excludes = Obj((fn$.call(this)));
            val = Chain(Var(util('copyWithout'))).add(Call([rvar, excludes]));
         } else {
            keys.push(key);
            if (logic) {
               lval = (logic.first = lval, logic);
            }
            val = Chain(rvar, [Index(key)]);
         }
         pairs.push([lval, val]);
      }
      for (i$ = 0, len$ = pairs.length; i$ < len$; ++i$) {
         ref$ = pairs[i$], left = ref$[0], right = ref$[1];
         results$.push((ref$ = clone$(this), ref$.left = left, ref$.right = right, ref$['void'] = true, ref$.temps = [], ref$).compile(o, LEVEL_PAREN));
      }
      return results$;
      function fn$(){
         var i$, x$, ref$, len$, results$ = [];
         for (i$ = 0, len$ = (ref$ = keys).length; i$ < len$; ++i$) {
            x$ = ref$[i$];
            results$.push(Prop(x$.extractKeyRef(o, true, this), Literal(0)));
         }
         return results$;
      }
   };
   Assign.prototype.rewriteShorthand = function(o, assign){
      var bin, ref$, that, ref1$;
      if (assign) {
         if (this === (bin = this.maybeLogic())) {
            this.carp("invalid assign");
         }
         return (ref$ = bin.rewriteShorthand(o, true)) != null ? ref$ : bin;
      }
      if (that = this.unfoldSoak(o)) {
         return that.rewriteShorthand(o, assign) || that;
      }
      if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, true) : void 8) {
         this.left = that;
      }
      if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
         this.right = that;
      }
   };
   Assign.prototype.maybeLogic = function(){
      if (this.op === '=') {
         return Binary(this.logic || '?', this.left, this.right);
      } else {
         return this;
      }
   };
   return Assign;
}(Node));
exports.Import = Import = (function(superclass){
   var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor = Import;
   function Import(left, right, all){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.left = left;
      this$.right = right;
      this$.all = all && 'All';
      if (!all && left instanceof Obj && right.items) {
         return Obj(left.items.concat(right.asObj().items));
      }
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Import.prototype.children = ['left', 'right'];
   Import.prototype.show = function(){
      return this.all;
   };
   prototype.delegate(['isCallable', 'isArray'], function(it){
      return this.left[it]();
   });
   Import.prototype.unfoldSoak = function(o){
      var left, value, ref$, temps;
      left = this.left;
      if (left instanceof Existence && !left.negated) {
         if ((left = left.it) instanceof Var) {
            value = (this.left = left).value;
            if (!o.scope.check(value, true)) {
               left = JS("typeof " + value + " != 'undefined' && " + value);
            }
         } else {
            ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
         }
         return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
      }
      return If.unfoldSoak(o, this, 'left') || this['void'] && If.unfoldSoak(o, this, 'right');
   };
   Import.prototype.compileNode = function(o){
      var right;
      right = this.right;
      if (!this.all) {
         if (right instanceof Chain) {
            right = right.unfoldSoak(o) || right.unfoldAssign(o) || right;
         }
         if (right instanceof List) {
            return this.compileAssign(o, right.asObj().items);
         }
      }
      // return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
      return CopyL(this, Call.make(JS("Object.assign"), [this.left, right])).compileNode(o);
   };
   Import.prototype.compileAssign = function(o, items){
      var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, key, val, logic;
      if (!items.length) {
         return this.left.compile(o);
      }
      top = !o.level;
      if (this.proto || (items.length < 2 && (top || this['void'] || items[0].key instanceof Splat))) {
         reft = this.left;
         if (reft.isComplex()) {
            reft = Parens(reft);
         }
      } else {
         ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
      }
      ref$ = top
         ? [';', '\n' + this.tab]
         : [',', ' '], delim = ref$[0], space = ref$[1];
      delim += space;
      code = this.temps
         ? [left.compile(o, LEVEL_PAREN), delim]
         : [];
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
         i = i$;
         node = items[i$];
         i && code.push(com ? space : delim);
         if (com = node.comment) {
            code.push(node.compile(o));
            continue;
         }
         key = node.key, val = node.val, logic = node.logic;
         if (key instanceof Splat) {
            code.push(CopyL(this, Import(reft, val)).compile(o));
            continue;
         }
         if (node.accessor) {
            if (key instanceof Key) {
               key = JS("'" + key.name + "'");
            }
            code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor(o), ")");
            continue;
         }
         logic && (val = (logic.first = val, logic));
         code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
      }
      if (top) {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      }
      this['void'] || key instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
      if (o.level < LEVEL_LIST) {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      } else {
         return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
      }
   };
   Import.prototype.rewriteShorthand = function(o, assign){
      var that, ref$, ref1$;
      if (that = this.unfoldSoak(o)) {
         return that.rewriteShorthand(o, assign) || that;
      }
      if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, assign) : void 8) {
         this.left = that;
      }
      if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
         this.right = that;
      }
   };
   return Import;
}(Node));
exports.In = In = (function(superclass){
   var prototype = extend$((import$(In, superclass).displayName = 'In', In), superclass).prototype, constructor = In;
   Object.assign(prototype, arguments[1]);
   function In(item, array){
      this.item = item;
      this.array = array;
   }
   In.prototype.children = ['item', 'array'];
   In.prototype.compileNode = function(o){
      var array, items, value, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
      items = (array = this.array).items;
      if (!(array instanceof Arr)) {
         return sn(this, this.negated ? '!' : '', "[].includes.call(", array.compile(o, LEVEL_LIST), ", ", this.item.compile(o, LEVEL_LIST), ")");
      }
      if (items.length === 0) {
         if (o.warn) {
            this.warn("value can never be `in` an empty array");
         }
         value = !!this.negated + "";
         return this.item.isComplex()
            ? sn(this, "(", this.item.compile(o, LEVEL_LIST), ", ", value, ")")
            : sn(this, value);
      }
      code = [];
      ref$ = items.length === 1
         ? [ref$ = this.item.compile(o, LEVEL_PAREN), ref$]
         : this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
      ref$ = this.negated
         ? [' !== ', ' && ']
         : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
         i = i$;
         test = items[i$];
         if (code.length > 0) {
            code.push(cnj);
         }
         if (test instanceof Splat) {
            code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
            if (!(i || sub === ref)) {
               code = ["(" + sub + ", "].concat(arrayFrom$(code), [")"]);
            }
         } else {
            code.push(i || sub === ref
               ? ref
               : "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
         }
      }
      sub === ref || o.scope.free(ref);
      if (o.level < LEVEL_OP + PREC[items.length === 1 ? '===' : '||']) {
         return sn.apply(null, [this].concat(arrayFrom$(code)));
      } else {
         return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
      }
   };
   return In;
}(Node, Negatable));
exports.Existence = Existence = (function(superclass){
   var prototype = extend$((import$(Existence, superclass).displayName = 'Existence', Existence), superclass).prototype, constructor = Existence;
   Object.assign(prototype, arguments[1]);
   function Existence(it, negated){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.it = it;
      this$.negated = negated;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Existence.prototype.children = ['it'];
   Existence.prototype.compileNode = function(o){
      var node, ref$, code, op, eq, anaphPre, anaphPost, that;
      node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
      code = [node.compile(o, LEVEL_OP + PREC['=='])];
      if (this.doAnaphorize) {
         o.scope.declare('that', Var('that'));
      }
      if (node instanceof Var && !o.scope.check(code.join(""), true)) {
         ref$ = this.negated
            ? ['||', '=']
            : ['&&', '!'], op = ref$[0], eq = ref$[1];
         if (this.doAnaphorize) {
            ref$ = this.negated
               ? [["(that = undefined) || "], []]
               : [[], [" && (that = "].concat(arrayFrom$(code), [", true)"])], anaphPre = ref$[0], anaphPost = ref$[1];
         }
         code = ["typeof "].concat(arrayFrom$(code), [" " + eq + "= 'undefined' " + op + " "], arrayFrom$(code), [" " + eq + "== null"]);
         if ((that = anaphPre) != null) {
            code = that.concat(code);
         }
         if ((that = anaphPost) != null) {
            code = code.concat(that);
         }
      } else {
         if (this.doAnaphorize) {
            code = ["(that = "].concat(arrayFrom$(code), [")"]);
         }
         code.push(" " + (op = this.negated ? '==' : '!=') + " null");
      }
      if (o.level < LEVEL_OP + PREC[op]) {
         return sn.apply(null, [this].concat(arrayFrom$(code)));
      } else {
         return sn(this, "(", code, ")");
      }
   };
   return Existence;
}(Node, Negatable));
exports.Fun = Fun = (function(superclass){
   var prototype = extend$((import$(Fun, superclass).displayName = 'Fun', Fun), superclass).prototype, constructor = Fun;
   function Fun(params, body, bound, curried, hushed, generator, async){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.params = params || [];
      this$.body = body || Block();
      this$.bound = bound && 'this';
      this$.curried = curried || false;
      this$.hushed = hushed != null ? hushed : false;
      this$.generator = generator != null ? generator : false;
      this$.async = async != null ? async : false;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Fun.prototype.children = ['params', 'body'];
   Fun.prototype.show = function(){
      var that;
      return [this.name] + [(that = this.bound) ? "~" + that : void 8];
   };
   Fun.prototype.named = function(it){
      return this.name = it, this.statement = true, this;
   };
   Fun.prototype.isCallable = YES;
   Fun.prototype.isStatement = function(){
      return !!this.statement;
   };
   Fun.prototype.traverseChildren = function(arg$, xscope){
      if (xscope) {
         return superclass.prototype.traverseChildren.apply(this, arguments);
      }
   };
   Fun.prototype.rewriteShorthand = VOID;
   Fun.prototype.makeReturn = function(){
      if (this.statement) {
         return this.returns = true, this;
      } else {
         return superclass.prototype.makeReturn.apply(this, arguments);
      }
   };
   Fun.prototype.ripName = function(it){
      this.name || (this.name = it.varName());
   };
   Fun.prototype.compileNode = function(o){
      var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this, isBound = this.bound === 'this', param;
      pscope = o.scope;
      sscope = pscope.shared || pscope;
      scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper && sscope);
      scope.fun = this;
      if (that = this.proto) {
         scope.assign('prototype', that.compile(o) + ".prototype");
      }
      if (that = this.cname) {
         scope.assign('constructor', that);
      }
      if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
         o.indent = this.tab = '';
      }
      o.indent += TAB;
      body = this.body, name = this.name, tab = this.tab;
      if (isBound) {
         code = ['('];
      } else {
         code = [];
      }
      if (
         this.async ||
         this.body.traverseChildren(t => t.op === "await" || null)
      ) {
         this.ctor && this.carp("a constructor can't be async");
         o.inAsync = true;
         code.push('async ');
      } else if (!this.wrapper) {
         o.inAsync = false;
      }
      if (!isBound) {
         code.push('function');
      }
      if (
         this.generator ||
         this.body.traverseChildren(t => t.op === "yield" || t.op === "yieldfrom" || null)
      ) {
         this.ctor && this.carp("a constructor can't be a generator");
         o.inGenerator = true;
         code.push('*');
      } else if (!this.wrapper) {
         o.inGenerator = false;
      }
      if (isBound) {
         if (this.ctor) {
            scope.assign('this', 'this instanceof ctor$ ? this : new ctor$');
            body.lines.push(Return(Literal('this')));
         } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
            this.bound = that;
         // } else if (this.usesThis()) {
         // 	sscope.assign('this', 'this');
         }
      }
      if (this.statement) {
         name || this.carp('nameless function declaration');
         pscope === o.block.scope || this.carp('misplaced function declaration');
         this.accessor && this.carp('named accessor');
         pscope.add(name, 'function', this);
      }
      if (this.statement || name && this.labeled) {
         code.push(' ', scope.add(name, 'function', this));
      }
      this.hushed || this.ctor || this.newed || body.makeReturn();
      param = this.compileParams(o, scope);
      if (isBound && param.children.length === 1 && !param.children[0].startsWith('...')) {
         code.push(param);
      }
      else {
         code.push("(", param, ")");
      }
      if (isBound) {
         code.push(' =>');
      }
      code = [sn.apply(null, [this].concat(arrayFrom$(code)))];
      code.push(" {");
      if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
         code.push("\n", bodyCode, "\n" + tab);
      }
      code.push(isBound && '})' || '}');
      curryCodeCheck = function(){
         if (this$.curried && this$.hasSplats) {
            this$.carp('cannot curry a function with a variable number of arguments');
         }
         if (this$.curried && this$.params.length > 1 && !this$.classBound) {
            if (this$.bound) {
               return ['((', code, '), true)'];
            } else {
               return ['(', code, ')'];
            }
         } else {
            return code;
         }
      };
      if (inLoop) {
         return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(arrayFrom$(curryCodeCheck()))));
      }
      if (this.returns) {
         code.push("\n" + tab + "return ", name, ";");
      } else if (this.bound && this.ctor) {
         code.push(' function ctor$(){} ctor$.prototype = prototype;');
      }
      code = curryCodeCheck();
      if (this.front && !this.statement) {
         return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
      } else {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      }
   };
   Fun.prototype.compileParams = function(o, scope){
      var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
      params = this.params, length = params.length, body = this.body;
      for (i$ = params.length - 1; i$ >= 0; --i$) {
         p = params[i$];
         if (!(p.isEmpty() || p.filler)) {
            break;
         }
         --params.length;
      }
      for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
         i = i$;
         p = params[i$];
         if (p.left instanceof Splat) {
            p.carp('invalid splat');
         }
         if (p instanceof Splat) {
            if (i < params.length - 1) {
               this.hasSplats = true;
               splace = i;
            } else {
               params[i] = Var("..." + p.it.value);
            }
         } else if (p instanceof Arr || p instanceof Obj) {
            params[i] = Binary('=', p, new p.constructor());
         } else if (p.op === '=') {
            params[i] = Binary(p.logic || '?', p.left, p.right);
         }
      }
      if (splace != null) {
         rest = params.splice(splace, 9e9);
      } else if (this.accessor) {
         if (that = params[1]) {
            that.carp('excess accessor parameter');
         }
      } else if (!(length || this.wrapper)) {
         if (body.traverseChildren(function(it){
            return it.value === 'it' || null;
         })) {
            params[0] = Var('it');
         }
      }
      names = [];
      assigns = [];
      for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
         p = params[i$];
         vr = p;
         if (df = vr.getDefault()) {
            vr = vr.first;
         }
         if (vr.isEmpty()) {
            vr = Var(scope.temporary('arg'));
         } else if (vr.value === '..') {
            vr = Var(o.ref = scope.temporary());
         } else if (!(vr instanceof Var)) {
            unaries = [];
            while (vr instanceof Unary) {
               hasUnary = true;
               unaries.push(vr);
               vr = vr.it;
            }
            v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
            assigns.push(Assign(vr, (fn$())));
            vr = v;
         } else if (df) {
            assigns.push(Assign(vr, p.second, '=', p.op, true));
         }
         names.push(scope.add(vr.value, 'arg', p), ', ');
      }
      if (rest) {
         while (splace--) {
            rest.unshift(Arr());
         }
         assigns.push(Assign(Arr(rest), Literal('arguments')));
      }
      if (assigns.length) {
         (ref$ = this.body).prepend.apply(ref$, assigns);
      }
      names.pop();
      return sn.apply(null, [null].concat(arrayFrom$(names)));
      function fn$(){
         switch (false) {
         case !df:
            return Binary(p.op, v, p.second);
         case !hasUnary:
            return fold(function(x, y){
               y.it = x;
               return y;
            }, v, unaries.reverse());
         default:
            return v;
         }
      }
   };
   Fun.prototype.usesThis = function(){
      return Node.prototype.traverseChildren.call(this, function(it){
         switch (false) {
         case !(it instanceof Literal && it.value === 'this'):
            return true;
         case !(it instanceof Fun && it.bound && it.usesThis()):
            return true;
         }
      });
   };
   return Fun;
}(Node));
exports.Class = Class = (function(superclass){
   var prototype = extend$((import$(Class, superclass).displayName = 'Class', Class), superclass).prototype, constructor = Class;
   function Class(arg$){
      var body;
      this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
      this.fun = Fun([], body);
   }
   Class.prototype.children = ['title', 'sup', 'mixins', 'fun'];
   Class.prototype.isCallable = YES;
   Class.prototype.ripName = function(it){
      this.name = it.varName();
   };
   Class.prototype.getRef = function(){
      var ref$, that;
      if (that = ((ref$ = this.title) != null ? ref$.varName() : void 8) || this.name) {
         return Var(that);
      }
   };
   Class.prototype.compile = function(o, level){
      var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
      fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
      CopyL(this, fun);
      boundFuncs = [];
      curriedBoundFuncs = [];
      decl = title != null ? title.varName() : void 8;
      name = decl || this.name;
      if (ID.test(name || '')) {
         fun.cname = name;
      } else {
         name = 'constructor';
      }
      proto = Var('prototype');
      vname = fun.proto = Var(fun.bound = name);
      ctorName = 'constructor$$';
      importProtoObj = function(node, i){
         var j, prop, key, i$, ref$, len$, v;
         j = 0;
         for (; j < node.items.length; j++) {
            prop = node.items[j];
            key = prop.key;
            if ((key instanceof Key && key.name === ctorName) || (key instanceof Literal && key.value === "'" + ctorName + "'")) {
               if (ctor) {
                  node.carp('redundant constructor');
               }
               ctor = prop.val;
               node.items.splice(j--, 1);
               ctorPlace = i;
            }
            if (!(prop.val instanceof Fun || prop.accessor)) {
               continue;
            }
            // if (key.isComplex()) {
            // 	key = Var(o.scope.temporary('key'));
            // 	prop.key = Assign(key, prop.key);
            // }
            // if (prop.val.bound) {
            // 	if (prop.val.curried) {
            // 		curriedBoundFuncs.push(prop.key);
            // 	} else {
            // 		boundFuncs.push(prop.key);
            // 	}
            // 	prop.val.bound = false;
            // 	prop.val.classBound = true;
            // }
            for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ < len$; ++i$) {
               v = ref$[i$];
               v.meth = key;
            }
         }
         if (node.items.length) {
            return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
         } else {
            return Literal('void');
         }
      };
      for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
         i = i$;
         node = lines[i$];
         if (node instanceof Obj) {
            lines[i] = importProtoObj(node, i);
         } else if (node instanceof Fun && !node.statement) {
            ctor && node.carp('redundant constructor');
            ctor = node;
         } else if (node instanceof Assign && node.left instanceof Chain && node.left.head.value === 'this' && node.right instanceof Fun) {
            node.right.stat = node.left.tails[0].key;
         } else {
            node.traverseChildren(fn$);
         }
      }
      ctor || (ctor = lines[lines.length] = this.sup
         ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
         : Fun());
      if (!(ctor instanceof Fun)) {
         lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
         lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
      }
      ctor.name = name;
      ctor.ctor = true;
      ctor.statement = true;
      // for (i$ = 0, len$ = boundFuncs.length; i$ < len$; ++i$) {
      // 	f = boundFuncs[i$];
      // 	ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Literal('this')).add(Index(f)).add(Index(Key('bind'))).add(Call([Literal('this')]))));
      // }
      // for (i$ = 0, len$ = curriedBoundFuncs.length; i$ < len$; ++i$) {
      // 	f = curriedBoundFuncs[i$];
      // 	ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'_" + f.name + "'")]))));
      // }
      lines.push(vname);
      args = [];
      if (that = this.sup) {
         args.push(that);
         imports = Chain(Import(Literal('this'), Var('superclass')));
         fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
      }
      if (that = this.mixins) {
         res$ = [];
         for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
            args[args.length] = that[i$];
            res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
         }
         imports = res$;
         body.prepend.apply(body, imports);
      }
      if (fun.cname && !this.sup) {
         body.prepend(Literal(name + ".displayName = '" + name + "'"));
      }
      clas = Parens(Call.make(fun, args), true);
      if (decl && title.isComplex()) {
         clas = Assign(vname, clas);
      }
      if (title) {
         clas = Assign(title, clas);
      }
      return sn(null, clas.compile(o, level));
      function fn$(it){
         var i$, ref$, len$, k, child;
         if (it instanceof Block) {
            for (i$ = 0, len$ = (ref$ = it.lines).length; i$ < len$; ++i$) {
               k = i$;
               child = ref$[i$];
               if (child instanceof Obj) {
                  it.lines[k] = importProtoObj(child, i);
               }
            }
         }
      }
   };
   return Class;
}(Node));
exports.Super = Super = (function(superclass){
   var prototype = extend$((import$(Super, superclass).displayName = 'Super', Super), superclass).prototype, constructor = Super;
   function Super(){}
   Super.prototype.isCallable = YES;
   Super.prototype.compile = function(o){
      var scope, that, result, ref$;
      scope = o.scope;
      if (!this.sproto) {
         for (; that = !scope.get('superclass') && scope.fun; scope = scope.parent) {
            result = that;
            if (that = result.meth) {
               return sn(this, 'superclass.prototype', Index(that).compile(o));
            }
            if (that = result.stat) {
               return sn(this, 'superclass', Index(that).compile(o));
            }
            if (that = scope.fun.inClass) {
               return sn(this, that, ".superclass.prototype.", scope.fun.name);
            } else if (that = scope.fun.inClassStatic) {
               return sn(this, that, ".superclass.", scope.fun.name);
            }
         }
         if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
            return sn(this, that, ".superclass");
         }
      }
      return sn(this, 'superclass');
   };
   Super.prototype.maybeKey = function(){
      return Key('super', true);
   };
   return Super;
}(Node));
exports.Parens = Parens = (function(superclass){
   var prototype = extend$((import$(Parens, superclass).displayName = 'Parens', Parens), superclass).prototype, constructor = Parens;
   function Parens(it, keep, string, lb, rb){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.it = it;
      this$.keep = keep;
      this$.string = string;
      this$.lb = lb;
      this$.rb = rb;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Parens.prototype.children = ['it'];
   Parens.prototype.show = function(){
      return this.string && '""';
   };
   prototype.delegate(['isComplex', 'isCallable', 'isArray', 'isRegex', 'isNextUnreachable', 'getRef'], function(it){
      return this.it[it]();
   });
   Parens.prototype.isString = function(){
      return this.string || this.it.isString();
   };
   Parens.prototype.unparen = function(){
      if (this.keep) {
         return this;
      } else {
         return this.it.unparen();
      }
   };
   Parens.prototype.compile = function(o, level){
      var it;
      level == null && (level = o.level);
      it = this.it;
      it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
      if (this.calling && (!level || this['void'])) {
         it.head.hushed = true;
      }
      if (!(this.keep || this.newed || level >= LEVEL_OP + PREC[it.op])) {
         return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
      }
      if (it.isStatement()) {
         return it.compileClosure(o);
      } else {
         return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
      }
   };
   Parens.prototype.maybeKey = THIS;
   Parens.prototype.extractKeyRef = function(o, assign, tempOwner){
      var v, ref$, ref, key, val;
      if (tempOwner != null && (v = this.it) instanceof Var && (ref$ = v.temp, delete v.temp, ref$)) {
         (tempOwner.temps || (tempOwner.temps = [])).push(v.value);
      }
      if (this.it instanceof Chain && assign) {
         ref$ = this.it.cacheReference(o), this.it = ref$[0], ref = ref$[1];
         return Parens(ref);
      }
      ref$ = this.it.cache(o, true), key = ref$[0], val = ref$[1];
      if (assign) {
         ref$ = [val, key], key = ref$[0], val = ref$[1];
      }
      this.it = val.unparen();
      return Parens(key);
   };
   Parens.prototype.rewriteShorthand = function(o){
      var that;
      if (that = this.it.rewriteShorthand(o)) {
         this.it = that;
      }
   };
   return Parens;
}(Node));
exports.Splat = Splat = (function(superclass){
   var ref$, prototype = extend$((import$(Splat, superclass).displayName = 'Splat', Splat), superclass).prototype, constructor = Splat;
   function Splat(it, filler){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.it = it;
      this$.filler = filler;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;
   Splat.prototype.isAssignable = YES;
   Splat.prototype.assigns = function(){
      return this.it.assigns();
   };
   Splat.prototype.compile = function(){
      return this.carp('invalid splat');
   };
   Splat.compileArray = function(o, list, apply){
      var index, i$, len$, node, args, atoms, ref$;
      expand(list);
      index = 0;
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
         node = list[i$];
         if (node instanceof Splat) {
            break;
         }
         ++index;
      }
      if (index >= list.length) {
         return sn(this, '');
      }
      if (!list[1]) {
         return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
      }
      args = [];
      atoms = [];
      for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ < len$; ++i$) {
         node = ref$[i$];
         if (node instanceof Splat) {
            if (atoms.length) {
               args.push(Arr(atoms.splice(0, 9e9)));
            }
            args.push(ensureArray(node.it));
         } else {
            atoms.push(node);
         }
      }
      if (atoms.length) {
         args.push(Arr(atoms));
      }
      return sn(null, (index
         ? Arr(list)
         : args.shift()).compile(o, LEVEL_CALL), sn(this, ".concat("), List.compile(o, args), sn(this, ")"));
   };
   function expand(nodes){
      var index, node, it;
      index = -1;
      while (node = nodes[++index]) {
         if (node instanceof Splat) {
            it = node.it;
            if (it.isEmpty()) {
               nodes.splice(index--, 1);
            } else if (it instanceof Arr) {
               nodes.splice(index, 1, ...expand(it.items));
               index += it.items.length - 1;
            }
         }
      }
      return nodes;
   }
   function ensureArray(node){
      if (node.isArray()) {
         return node;
      }
      return Call.make(JS('Array.from'), [node]);
   }
   return Splat;
}(Node));
exports.Jump = Jump = (function(superclass){
   var prototype = extend$((import$(Jump, superclass).displayName = 'Jump', Jump), superclass).prototype, constructor = Jump;
   function Jump(verb, label){
      this.verb = verb;
      this.label = label;
   }
   Jump.prototype.show = function(){
      var that;
      return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
   };
   Jump.prototype.isStatement = YES;
   Jump.prototype.makeReturn = THIS;
   Jump.prototype.isNextUnreachable = YES;
   Jump.prototype.getJump = function(ctx){
      ctx || (ctx = {});
      if (!ctx[this.verb]) {
         return this;
      }
      if (this.label) {
         return !(ctx.labels != null ? ctx.labels : ctx.labels = []).includes(this.label) && this;
      }
   };
   Jump.prototype.compileNode = function(o){
      if (this.label) {
         (o.labels != null ? o.labels : o.labels = []).includes(this.label) || this.carp("unknown label \"" + this.label + "\"");
      } else {
         o[this.verb] || this.carp("stray " + this.verb);
      }
      return sn(this, this.show() + ';');
   };
   Jump.extended = function(sub){
      sub.prototype.children = ['it'];
      this[sub.displayName.toLowerCase()] = sub;
   };
   return Jump;
}(Node));
exports.Throw = Throw = (function(superclass){
   var prototype = extend$((import$(Throw, superclass).displayName = 'Throw', Throw), superclass).prototype, constructor = Throw;
   function Throw(it){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.it = it;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Throw.prototype.getJump = VOID;
   Throw.prototype.compileNode = function(o){
      var ref$;
      return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
   };
   return Throw;
}(Jump));
exports.Return = Return = (function(superclass){
   var prototype = extend$((import$(Return, superclass).displayName = 'Return', Return), superclass).prototype, constructor = Return;
   function Return(it){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      if (it && it.value !== 'void') {
         this$.it = it;
      }
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Return.prototype.getJump = THIS;
   Return.prototype.compileNode = function(o){
      var that;
      return sn.apply(null, [this, "return"].concat(
         (that = this.it)
            ? [' ', that.compile(o, LEVEL_PAREN)]
            : [], [";"]
      ));
   };
   return Return;
}(Jump));
exports.While = While = (function(superclass){
   var prototype = extend$((import$(While, superclass).displayName = 'While', While), superclass).prototype, constructor = While;
   function While(test, un, mode){
      this.un = un;
      mode && (mode instanceof Node
         ? this.update = mode
         : this.post = true);
      if (this.post || test.value !== '' + !un) {
         this.test = test;
      }
   }
   While.prototype.children = ['test', 'body', 'update', 'else'];
   While.prototype.aSource = 'test';
   While.prototype.aTargets = ['body', 'update'];
   While.prototype.show = function(){
      return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
   };
   prototype.isStatement = prototype.isArray = YES;
   While.prototype.makeComprehension = function(toAdd, loops){
      this.isComprehension = true;
      while (loops.length) {
         toAdd = loops.pop().addBody(Block(toAdd));
         if (!toAdd.isComprehension) {
            toAdd.inComprehension = true;
         }
      }
      return this.addBody(Block(toAdd));
   };
   While.prototype.getJump = function(ctx){
      var ref$, i$, ref1$, len$, node;
      ctx || (ctx = {});
      ctx['continue'] = true;
      ctx['break'] = true;
      for (i$ = 0, len$ = (ref1$ = ((ref$ = this.body) != null ? ref$.lines : void 8) || []).length; i$ < len$; ++i$) {
         node = ref1$[i$];
         if (node.getJump(ctx)) {
            return node;
         }
      }
   };
   While.prototype.addBody = function(body){
      var top;
      this.body = body;
      if (this.guard) {
         this.body = Block(If(this.guard, this.body));
      }
      top = this.body.lines[0];
      if ((top != null ? top.verb : void 8) === 'continue' && !top.label) {
         this.body.lines.length = 0;
      }
      return this;
   };
   While.prototype.addGuard = function(guard){
      this.guard = guard;
      return this;
   };
   While.prototype.addObjComp = function(objComp){
      this.objComp = objComp != null ? objComp : true;
      return this;
   };
   While.prototype.makeReturn = function(it){
      var ref$, last, ref1$, ref2$;
      if (this.hasReturned) {
         return this;
      }
      if (it) {
         if (this.objComp) {
            this.body = Block(this.body.makeReturn(it, true));
         } else {
            if (!(this.body || this.index)) {
               this.addBody(Block(Var(this.index = 'ridx$')));
            }
            last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
            if ((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension)) {
               (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
               if ((ref1$ = this['else']) != null) {
                  ref1$.makeReturn.apply(ref1$, arguments);
               }
               this.hasReturned = true;
            } else {
               this.resVar = it;
               if ((ref2$ = this['else']) != null) {
                  ref2$.makeReturn.apply(ref2$, arguments);
               }
            }
         }
      } else {
         this.getJump() || (this.returns = true);
      }
      return this;
   };
   While.prototype.compileNode = function(o){
      var ref$, test, head, that;
      o.loop = true;
      this.test && (this.un
         ? this.test = this.test.invert()
         : this.anaphorize());
      if (this.post) {
         return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
      }
      test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
      if (!(this.update || this['else'])) {
         head = !snEmpty(test)
            ? [sn(this, "while ("), test]
            : [sn(this, 'for (;;')];
      } else {
         head = [sn(this, 'for (')];
         if (this['else']) {
            head.push(this.yet = o.scope.temporary('yet'), " = true");
         }
         head.push(sn(this, ";"), test.toString() && ' ', test, sn(this, ";"));
         if (that = this.update) {
            head.push(' ', that.compile(o, LEVEL_PAREN));
         }
      }
      return sn.apply(null, [null].concat(arrayFrom$(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
   };
   While.prototype.compileBody = function(o){
      var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ = this;
      o['break'] = o['continue'] = true;
      lines = this.body.lines, yet = this.yet, tab = this.tab;
      code = [];
      ret = [];
      mid = [];
      empty = this.objComp ? '{}' : '[]';
      getResultName = function(){
         return _resultName != null
            ? _resultName
            : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
      };
      last = lines != null ? lines[lines.length - 1] : void 8;
      if (!(this.isComprehension || this.inComprehension) || (last != null && last.isComprehension)) {
         hasLoop = false;
         if (last != null) {
            last.traverseChildren(function(it){
               var ref$;
               if (it instanceof Block && (ref$ = it.lines)[ref$.length - 1] instanceof While) {
                  hasLoop = true;
               }
            });
         }
         if (this.returns && !this.resVar) {
            this.resVar = res = o.scope.assign(getResultName(), empty);
         }
         if (this.resVar && (last instanceof While || hasLoop)) {
            temp = o.scope.temporary('lresult');
            lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
               ? Obj()
               : Arr(), '='));
            if (lines[key$ = lines.length - 1] != null) {
               lines[key$] = lines[key$].makeReturn(temp);
            }
            mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" + this.tab);
         } else {
            this.hasReturned = true;
            if (this.resVar) {
               this.body.makeReturn(this.resVar);
            }
         }
      }
      if (this.returns) {
         if ((!last instanceof While && !this.hasReturned) || this.isComprehension || this.inComprehension) {
            if (lines[key$ = lines.length - 1] != null) {
               lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
            }
         }
         ret.push("\n" + this.tab + "return ", res || empty, ";");
         if ((ref$ = this['else']) != null) {
            ref$.makeReturn();
         }
      }
      yet && lines.unshift(JS(yet + " = false;"));
      if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
         code.push("\n", bodyCode, "\n" + tab);
      }
      code.push.apply(code, mid);
      code.push('}');
      if (this.post) {
         code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
      }
      if (yet) {
         code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
         o.scope.free(yet);
      }
      return sn.apply(null, [null].concat(arrayFrom$(code), arrayFrom$(ret)));
   };
   return While;
}(Node));
exports.For = For = (function(superclass){
   var prototype = extend$((import$(For, superclass).displayName = 'For', For), superclass).prototype, constructor = For;
   function For(it){
      var i$, x$, ref$, len$;
      Object.assign(this, it);
      if (this.item instanceof Var && !this.item.value) {
         this.item = null;
      }
      for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ < len$; ++i$) {
         x$ = ref$[i$];
         this[x$] = true;
      }
      if (this.own && !this.object) {
         this.carp('`for own` requires `of`');
      }
   }
   For.prototype.children = ['item', 'source', 'from', 'to', 'step', 'body'];
   For.prototype.aSource = null;
   For.prototype.show = function(){
      return ((this.kind || []).concat(this.index)).join(' ');
   };
   For.prototype.addBody = function(body){
      var ref$, assignments, x$, that, assigned, name;
      if (this['let']) {
         if (ref$ = this.ref, delete this.ref, ref$) {
            this.item = Literal('..');
         }
         assignments = (x$ = [], (that = this.index) && x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) && x$.push(Assign(that, Literal('item$$'))), x$);
         body = Block(this.guard
            ? (assigned = (function(){
               var i$, x$, ref$, len$, j$, ref1$, len1$, results$ = [];
               for (i$ = 0, len$ = (ref$ = assignments).length; i$ < len$; ++i$) {
                  x$ = ref$[i$];
                  if (that = x$.assigns()) {
                     for (j$ = 0, len1$ = (ref1$ = that).length; j$ < len1$; ++j$) {
                        name = ref1$[j$];
                        results$.push(Var(name));
                     }
                  }
               }
               return results$;
            }()), assignments.concat([If((ref$ = this.guard, delete this.guard, ref$), Call['let'](assigned, body))]))
            : Call['let'](assignments, body));
      }
      superclass.prototype.addBody.call(this, body);
      if (this['let']) {
         delete this.index;
         delete this.item;
      }
      return this;
   };
   For.prototype.isNextUnreachable = NO;
   For.prototype.compileNode = function(o){
      var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body, isCharArr, sfvar, stvar, cfvar, ctvar;
      o.loop = true;
      temps = this.temps = [];
      if (this.object && this.index) {
         o.scope.declare(idx = this.index);
      } else {
         temps.push(idx = o.scope.temporary('i'));
      }
      if (!this.object) {
         ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
         pvar === step || temps.push(pvar);
      }
      if (this.from) {
         if (this.ref) {
            this.item = Var(idx);
         }
         ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
         fvar = this.from.compile(o, LEVEL_LIST);
         sfvar = fvar + '';
         stvar = tvar + '';
         if (isCharArr = '"\''.includes(sfvar[0]) && '"\''.includes(stvar[0]) && +pvar) {
            cfvar = Function("return " + sfvar)();
            ctvar = Function("return " + stvar)();
         }
         vars = idx + " = " + (isCharArr ? cfvar.charCodeAt() : sfvar);
         if (tail !== tvar) {
            vars += ", " + tail;
            temps.push(tvar);
         }
         if (!this.step) {
            if (isCharArr && cfvar > ctvar || !isCharArr && +fvar > +tvar) {
               pvar = step = -1;
            }
         }
         eq = this.op === 'til' ? '' : '=';
         cond = +pvar
            ? idx + " " + '<>'.charAt(pvar < 0) + eq + " " + (isCharArr ? ctvar.charCodeAt() : stvar)
            : pvar + " < 0 ? " + idx + " >" + eq + " " + stvar + " : " + idx + " <" + eq + " " + stvar;
      } else {
         if (this.ref) {
            this.item = Var(o.scope.temporary('x'));
         }
         if (this.item || this.object && this.own || this['let']) {
            ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
            svar === srcPart || temps.push(svar);
         } else {
            svar = srcPart = this.source.compile(o, this.object ? LEVEL_PAREN : LEVEL_CALL);
         }
         if (!this.object) {
            if (0 > pvar && ~~pvar === +pvar) {
               vars = idx + " = " + srcPart + ".length - 1";
               cond = idx + " >= 0";
            } else {
               temps.push(lvar = o.scope.temporary('len'));
               vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
               cond = idx + " < " + lvar;
            }
         }
      }
      if (!this.body) {
         this.addBody(Block(Var(isCharArr ? 'String.fromCharCode(' + idx + ')' : idx)));
      }
      this['else'] && (this.yet = o.scope.temporary('yet'));
      head = [sn(this, this.let ? 'for (let ' : 'for (')];
      if (this.object) {
         head.push(idx, " in ");
      }
      if (that = this.yet) {
         head.push(that, " = true, ");
      }
      if (this.object) {
         head.push(srcPart);
      } else {
         step === pvar || (vars += ', ' + step);
         head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
            ? (pvar < 0 ? '--' : '++') + idx
            : idx + (pvar < 0
               ? ' -= ' + pvar.toString().slice(1)
               : ' += ' + pvar)));
      }
      this.own && head.push(sn(this, ") if ("), "{}.hasOwnProperty.call(", svar, ", ", idx, ")");
      head.push(sn(this, ') {'));
      if (this['let']) {
         this.body.traverseChildren(function(it){
            switch (it.value) {
            case 'index$$':
               it.value = idx;
               break;
            case 'item$$':
               it.value = svar + "[" + idx + "]";
            }
         });
      }
      o.indent += TAB;
      if (this.index && !this.object) {
         head.push('\n' + o.indent, Assign(Var(this.index), JS(isCharArr ? 'String.fromCharCode(' + idx + ')' : idx)).compile(o, LEVEL_TOP), ';');
      }
      if (this.item && !this.item.isEmpty() && !this.from) {
         head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
      }
      if (this.ref) {
         o.ref = this.item.value;
      }
      body = this.compileBody(o);
      if ((this.item || (this.index && !this.object)) && '}' === body.toString().charAt(0)) {
         head.push('\n' + this.tab);
      }
      return sn.apply(null, [null].concat(arrayFrom$(head), [body]));
   };
   return For;
}(While));
exports.StepSlice = StepSlice = (function(superclass){
   var prototype = extend$((import$(StepSlice, superclass).displayName = 'StepSlice', StepSlice), superclass).prototype, constructor = StepSlice;
   StepSlice.prototype.makeReturn = function(makeReturnArg){
      this.makeReturnArg = makeReturnArg;
      return superclass.prototype.makeReturn.apply(this, arguments);
   };
   StepSlice.prototype.compileNode = function(o){
      var ref$, sub, ref, temps, code;
      this.index = o.scope.temporary('x');
      ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
      this.guard = Binary('<', Literal(this.index), Chain(ref).add(Index(Key('length'))));
      this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
      if (this.makeReturnArg != null) {
         this.makeReturn(this.makeReturnArg);
      }
      code = [];
      if (temps) {
         code.push(sub.compile(o), ';' + '\n' + o.indent);
      }
      code.push(superclass.prototype.compileNode.apply(this, arguments));
      return sn.apply(null, [this].concat(arrayFrom$(code)));
   };
   function StepSlice(){
      StepSlice.superclass.apply(this, arguments);
   }
   return StepSlice;
}(For));
exports.Try = Try = (function(superclass){
   var prototype = extend$((import$(Try, superclass).displayName = 'Try', Try), superclass).prototype, constructor = Try;
   function Try(attempt, thrown, recovery, ensure){
      var ref$;
      this.attempt = attempt;
      this.thrown = thrown;
      this.recovery = recovery;
      this.ensure = ensure;
      if ((ref$ = this.recovery) != null) {
         ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
      }
   }
   Try.prototype.children = ['attempt', 'recovery', 'ensure'];
   Try.prototype.show = function(){
      return this.thrown;
   };
   Try.prototype.isStatement = YES;
   Try.prototype.isCallable = function(){
      var ref$;
      return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) && this.attempt.isCallable();
   };
   Try.prototype.getJump = function(it){
      var ref$;
      return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
   };
   Try.prototype.isNextUnreachable = function(){
      var ref$, that;
      return ((ref$ = this.ensure) != null ? ref$.isNextUnreachable() : void 8) || this.attempt.isNextUnreachable() && ((that = this.recovery) != null ? that.isNextUnreachable() : true);
   };
   Try.prototype.makeReturn = function(){
      var ref$;
      this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
      if (this.recovery != null) {
         this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
      }
      return this;
   };
   Try.prototype.compileNode = function(o){
      var code, that;
      o.indent += TAB;
      code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
      if (that = this.recovery || !this.ensure && JS('')) {
         code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
      }
      if (that = this.ensure) {
         code.push(sn(that, ' finally '), this.compileBlock(o, that));
      }
      return sn.apply(null, [null].concat(arrayFrom$(code)));
   };
   return Try;
}(Node));
exports.Switch = Switch = (function(superclass){
   var prototype = extend$((import$(Switch, superclass).displayName = 'Switch', Switch), superclass).prototype, constructor = Switch;
   function Switch(type, topic, cases, $default){
      var last, ref$;
      this.type = type;
      this.topic = topic;
      this.cases = cases;
      this['default'] = $default;
      if (type === 'match') {
         if (topic) {
            this.topic = Arr(topic);
         }
      } else {
         if (topic) {
            if (topic.length > 1) {
               throw "can't have more than one topic in switch statement";
            }
            this.topic = this.topic[0];
         }
      }
      if (this.cases.length && (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 && last.tests[0] instanceof Var && last.tests[0].value === '_') {
         this.cases.pop();
         this['default'] = last.body;
      }
   }
   Switch.prototype.children = ['topic', 'cases', 'default'];
   Switch.prototype.aSource = 'topic';
   Switch.prototype.aTargets = ['cases', 'default'];
   Switch.prototype.show = function(){
      return this.type;
   };
   Switch.prototype.isStatement = YES;
   Switch.prototype.isCallable = function(){
      var i$, ref$, len$, c;
      for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
         c = ref$[i$];
         if (!c.isCallable()) {
            return false;
         }
      }
      if (this['default']) {
         return this['default'].isCallable();
      } else {
         return true;
      }
   };
   Switch.prototype.getJump = function(ctx){
      var i$, ref$, len$, c, that;
      ctx || (ctx = {});
      ctx['break'] = true;
      for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
         c = ref$[i$];
         if (that = c.body.getJump(ctx)) {
            return that;
         }
      }
      return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
   };
   Switch.prototype.isNextUnreachable = function(){
      var i$, ref$, len$, c;
      for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
         c = ref$[i$];
         if (!c.body.isNextUnreachable()) {
            return false;
         }
      }
      return (ref$ = this['default']) != null ? ref$.isNextUnreachable() : void 8;
   };
   Switch.prototype.makeReturn = function(){
      var i$, ref$, len$, c;
      for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
         c = ref$[i$];
         c.makeReturn.apply(c, arguments);
      }
      if ((ref$ = this['default']) != null) {
         ref$.makeReturn.apply(ref$, arguments);
      }
      return this;
   };
   Switch.prototype.compileNode = function(o){
      var tab, topic, ref$, targetNode, target, t, code, stop, i$, len$, i, c, that;
      tab = this.tab;
      topic = this.type === 'match'
         ? (this.topic && (ref$ = Chain(this.topic).cacheReference(o), targetNode = ref$[0], target = ref$[1]), t = target
            ? [targetNode]
            : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
         : !!this.topic && this.anaphorize().compile(o, LEVEL_PAREN);
      code = [sn(this, "switch (", snSafe(topic), ") {\n")];
      stop = this['default'] || this.cases.length - 1;
      o['break'] = true;
      for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
         i = i$;
         c = ref$[i$];
         code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
      }
      if (this['default']) {
         o.indent = tab + TAB;
         if (that = this['default'].compile(o, LEVEL_TOP)) {
            code.push(tab + "default:\n", that, "\n");
         }
      }
      return sn.apply(null, [null].concat(arrayFrom$(code), [tab + '}']));
   };
   return Switch;
}(Node));
exports.Case = Case = (function(superclass){
   var prototype = extend$((import$(Case, superclass).displayName = 'Case', Case), superclass).prototype, constructor = Case;
   function Case(tests, body){
      this.tests = tests;
      this.body = body;
   }
   Case.prototype.children = ['tests', 'body'];
   Case.prototype.isCallable = function(){
      return this.body.isCallable();
   };
   Case.prototype.makeReturn = function(){
      var ref$, ref1$;
      if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
         (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
      }
      return this;
   };
   Case.prototype.compileCase = function(o, tab, nobr, bool, type, target){
      var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
      tests = [];
      for (i$ = 0, len$ = (ref$ = this.tests).length; i$ < len$; ++i$) {
         test = ref$[i$];
         if (test instanceof Arr && type !== 'match') {
            for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ < len1$; ++j$) {
               t = ref1$[j$];
               tests.push(t);
            }
         } else {
            tests.push(test);
         }
      }
      tests.length || tests.push(Literal('void'));
      if (type === 'match') {
         for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
            i = i$;
            test = tests[i$];
            tar = Chain(target).add(Index(Literal(i), '.', true));
            tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
         }
      }
      if (bool) {
         binary = type === 'match' ? '&&' : '||';
         t = tests[0];
         i = 0;
         while (that = tests[++i]) {
            t = Binary(binary, t, that);
         }
         tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
      }
      code = [];
      for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
         t = tests[i$];
         code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
      }
      lines = this.body.lines;
      last = lines[lines.length - 1];
      if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
         lines[lines.length - 1] = JS('// fallthrough');
      }
      o.indent = tab += TAB;
      if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
         code.push(bodyCode, '\n');
      }
      if (!(nobr || ft || (last != null && last.isNextUnreachable()))) {
         code.push(tab + 'break;\n');
      }
      return sn.apply(null, [null].concat(arrayFrom$(code)));
   };
   return Case;
}(Node));
exports.If = If = (function(superclass){
   var prototype = extend$((import$(If, superclass).displayName = 'If', If), superclass).prototype, constructor = If;
   function If($if, then, un){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$['if'] = $if;
      this$.then = then;
      this$.un = un;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   If.prototype.children = ['if', 'then', 'else'];
   If.prototype.aSource = 'if';
   If.prototype.aTargets = ['then'];
   If.prototype.show = function(){
      return this.un && '!';
   };
   If.prototype.terminator = '';
   prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex', 'isNextUnreachable'], function(it){
      var ref$;
      return ((ref$ = this['else']) != null ? ref$[it]() : void 8) && this.then[it]();
   });
   If.prototype.getJump = function(it){
      var ref$;
      return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
   };
   If.prototype.makeReturn = function(){
      var ref$;
      this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
      if (this['else'] != null) {
         this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
      }
      return this;
   };
   If.prototype.compileNode = function(o){
      if (this.un) {
         this['if'] = this['if'].invert();
      } else {
         this.soak || this.anaphorize();
      }
      if (o.level) {
         return this.compileExpression(o);
      } else {
         return this.compileStatement(o);
      }
   };
   If.prototype.compileStatement = function(o){
      var code, els;
      code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
      o.indent += TAB;
      code.push(this.compileBlock(o, Block(this.then)));
      if (!(els = this['else'])) {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      }
      return sn.apply(null, [null].concat(
         arrayFrom$(code), [
            sn(els, ' else '), els instanceof constructor
               ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
               : this.compileBlock(o, els)
         ]
      ));
   };
   If.prototype.compileExpression = function(o){
      var thn, els, code, pad;
      thn = this.then, els = this['else'] || Literal('void');
      this['void'] && (thn['void'] = els['void'] = true);
      if (!this['else'] && (this.cond || this['void'])) {
         return Parens(Binary('&&', this['if'], Parens(thn.unwrap()))).compile(o);
      }
      code = [sn(this, this['if'].compile(o, LEVEL_COND))];
      pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
      code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
      if (o.level < LEVEL_COND) {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      } else {
         return sn(null, "(", code, ")");
      }
   };
   If.unfoldSoak = function(o, parent, name){
      var that;
      if (that = parent[name].unfoldSoak(o)) {
         parent[name] = that.then;
         return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;
      }
   };
   return If;
}(Node));
exports.Label = Label = (function(superclass){
   var ref$, prototype = extend$((import$(Label, superclass).displayName = 'Label', Label), superclass).prototype, constructor = Label;
   function Label(label, it){
      var fun;
      this.label = label || '_';
      this.it = it;
      if (this.it.curried) {
         this.carp("can't use label with a curried function (attempted label '" + this.label + "')");
      }
      if (fun = (it instanceof Fun || it instanceof Class) && it || it.calling && it.it.head) {
         fun.name || (fun.name = this.label, fun.labeled = true);
         return it;
      }
   }
   ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;
   Label.prototype.show = function(){
      return this.label;
   };
   Label.prototype.isStatement = YES;
   Label.prototype.getJump = function(ctx){
      var ref$;
      ctx || (ctx = {});
      ((ref$ = ctx.labels) != null
         ? ref$
         : ctx.labels = []).push(this.label);
      return this.it.getJump((ctx['break'] = true, ctx));
   };
   Label.prototype.makeReturn = function(){
      var ref$;
      this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
      return this;
   };
   Label.prototype.compileNode = function(o){
      var label, it, labels;
      label = this.label, it = this.it;
      labels = o.labels = arrayFrom$(o.labels || []);
      if (labels.includes(label)) {
         this.carp("duplicate label \"" + label + "\"");
      }
      labels.push(label);
      it.isStatement() || (it = Block(it));
      return sn(null, sn(this, label, ": "), it instanceof Block
         ? (o.indent += TAB, this.compileBlock(o, it))
         : it.compile(o));
   };
   return Label;
}(Node));
exports.Cascade = Cascade = (function(superclass){
   var prototype = extend$((import$(Cascade, superclass).displayName = 'Cascade', Cascade), superclass).prototype, constructor = Cascade;
   function Cascade(input, output, prog1){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.input = input;
      this$.output = output;
      this$.prog1 = prog1;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Cascade.prototype.show = function(){
      return this.prog1;
   };
   Cascade.prototype.children = ['input', 'output'];
   Cascade.prototype.terminator = '';
   prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
      return this[this.prog1 ? 'input' : 'output'][it]();
   });
   Cascade.prototype.getJump = function(it){
      return this.output.getJump(it);
   };
   Cascade.prototype.makeReturn = function(ret){
      this.ret = ret;
      return this;
   };
   Cascade.prototype.compileNode = function(o){
      var level, input, output, prog1, ref, ref$, code, out;
      level = o.level;
      input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
      if (prog1 && ('ret' in this || level && !this['void'])) {
         output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
      }
      if ('ret' in this) {
         output = output.makeReturn(this.ret);
      }
      if (ref) {
         prog1 || (output = Assign(Var(ref), output));
      } else {
         ref = o.scope.temporary('x');
      }
      if (input instanceof Cascade) {
         input.ref = ref;
      } else {
         input && (input = Assign(Var(ref), input));
      }
      o.level && (o.level = LEVEL_PAREN);
      code = [input.compile(o)];
      out = Block(output).compile((o.ref = new String(ref), o));
      if (prog1 === 'cascade' && !o.ref.erred) {
         this.carp("unreferred cascadee");
      }
      if (!level) {
         return sn.apply(null, [null].concat(arrayFrom$(code), [input.terminator, "\n", out]));
      }
      code.push(", ", out);
      if (level > LEVEL_PAREN) {
         return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
      } else {
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      }
   };
   return Cascade;
}(Node));
exports.JS = JS = (function(superclass){
   var prototype = extend$((import$(JS, superclass).displayName = 'JS', JS), superclass).prototype, constructor = JS;
   function JS(code, literal, comment){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.code = code;
      this$.literal = literal;
      this$.comment = comment;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   JS.prototype.show = function(){
      if (this.comment) {
         return this.code;
      } else {
         return "`" + this.code + "`";
      }
   };
   JS.prototype.terminator = '';
   prototype.isAssignable = prototype.isCallable = function(){
      return !this.comment;
   };
   JS.prototype.compile = function(it){
      return sn(this, snSafe(this.literal
         ? entab(this.code, it.indent)
         : this.code));
   };
   return JS;
}(Node));
exports.Require = Require = (function(superclass){
   var prototype = extend$((import$(Require, superclass).displayName = 'Require', Require), superclass).prototype, constructor = Require;
   function Require(body){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.body = body;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Require.prototype.children = ['body'];
   Require.prototype.compile = function(o){
      var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
      getValue = function(item, throwError){
         switch (false) {
         case !(item instanceof Key):
            return item.name;
         case !(item instanceof Var):
            return item.value;
         case !(item instanceof Literal):
            return item.value;
         default:
            if (throwError) {
               return this$.carp('invalid require! argument');
            } else {
               return item;
            }
         }
      };
      processItem = function(item){
         var ref$, asg, value, asgValue, toAsg, main;
         ref$ = (function(){
            var ref$;
            switch (false) {
            case !(item instanceof Prop):
               return [
                  item.val, (ref$ = item.key) != null
                     ? ref$
                     : item.val
               ];
            default:
               return [item, item];
            }
         }()), asg = ref$[0], value = ref$[1];
         asgValue = getValue(asg);
         toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
         value = stripString(getValue(value, true));
         main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
         return sn(item, Assign(toAsg, main).compile(o));
      };
      if (this.body.items != null) {
         code = [];
         for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ < len$; ++i$) {
            item = ref$[i$];
            code.push(processItem(item), ";\n" + o.indent);
         }
         code.pop();
         return sn.apply(null, [null].concat(arrayFrom$(code)));
      } else {
         return sn(null, processItem(this.body));
      }
   };
   return Require;
}(Node));
exports.Util = Util = (function(superclass){
   var prototype = extend$((import$(Util, superclass).displayName = 'Util', Util), superclass).prototype, constructor = Util;
   function Util(verb){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.verb = verb;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Util.prototype.show = Jump.prototype.show;
   Util.prototype.isCallable = YES;
   Util.prototype.compile = function(){
      return sn(this, util(this.verb));
   };
   Util.Extends = function(){
      return Call.make(Util('extend'), [arguments[0], arguments[1]]);
   };
   return Util;
}(Node));
exports.Vars = Vars = (function(superclass){
   var prototype = extend$((import$(Vars, superclass).displayName = 'Vars', Vars), superclass).prototype, constructor = Vars;
   function Vars(vars){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.vars = vars;
      return this$;
   } function ctor$(){} ctor$.prototype = prototype;
   Vars.prototype.children = ['vars'];
   Vars.prototype.makeReturn = THIS;
   Vars.prototype.compile = function(o, level){
      var i$, ref$, len$, v, value;
      for (i$ = 0, len$ = (ref$ = this.vars).length; i$ < len$; ++i$) {
         v = ref$[i$], value = v.value;
         if (!(v instanceof Var)) {
            v.carp('invalid variable declaration');
         }
         if (o.scope.check(value)) {
            v.carp("redeclaration of \"" + value + "\"");
         }
         o.scope.declare(value, v);
      }
      return sn(this, Literal('void').compile(o, level));
   };
   return Vars;
}(Node));
exports.L = function(a, b, node){
   if (node && typeof node === "object") {
      node.first_line = a.first_line + 1;
      node.first_column = a.first_column;
      node.last_line = b.last_line + 1;
      node.last_column = b.last_column;
      node.line = a.first_line + 1;
      node.column = a.first_column;
   }
   return node;
};
exports.CopyL = CopyL = function(a, node){
   if (node && typeof node === "object") {
      node.first_line = a.first_line;
      node.first_column = a.first_column;
      node.last_line = a.last_line;
      node.last_column = a.last_column;
      node.line = a.line;
      node.column = a.column;
   }
   return node;
};
exports.Box = function(v){
   if (typeof v === "object") {
      return v;
   } else {
      return new v.constructor(v);
   }
};
exports.Decl = function(type, nodes, lno){
   if (!nodes[0]) {
      throw SyntaxError("empty " + type + " on line " + lno);
   }
   return DECLS[type](nodes);
};
DECLS = {
   'export': function(lines){
      var i, out, node, that, ref$;
      i = -1;
      out = Util('out');
      while (node = lines[++i]) {
         if (node instanceof Block) {
            lines.splice.apply(lines, [i--, 1].concat(arrayFrom$(node.lines)));
            continue;
         }
         if (that = node instanceof Fun && node.name) {
            lines.splice(i++, 0, Assign(Chain(out, [Index(Key(that))]), Var(that)));
            continue;
         }
         lines[i] = (that = node.varName() || node instanceof Assign && node.left.varName() || node instanceof Class && ((ref$ = node.title) != null ? ref$.varName() : void 8))
            ? Assign(Chain(out, [Index(Key(that))]), node)
            : Import(out, node);
      }
      return Block(lines);
   },
   'import': function(lines, all){
      var i$, len$, i, line;
      for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
         i = i$;
         line = lines[i$];
         lines[i] = Import(Literal('this'), line, all);
      }
      return Block(lines);
   },
   importAll: function(it){
      return this['import'](it, true);
   },
   'const': function(lines){
      var i$, len$, node;
      for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
         node = lines[i$];
         node.op === '=' || node.carp('invalid constant variable declaration');
         node['const'] = true;
      }
      return Block(lines);
   },
   'var': Vars
};
function Scope(parent, shared){
   this.parent = parent;
   this.shared = shared;
   this.variables = {};
}
ref$ = Scope.prototype;
ref$.READ_ONLY = {
   'const': 'constant',
   'function': 'function',
   undefined: 'undeclared'
};
ref$.add = function(name, type, node){
   var t, u, that;
   u = name.replace(/^\.\.\./, "")
   if (node && (t = this.variables[u + "."])) {
      if (that = this.READ_ONLY[t] || this.READ_ONLY[type]) {
         node.carp("redeclaration of " + that + " \"" + u + "\"");
      } else if (t === type && type === 'arg') {
         node.carp("duplicate parameter \"" + u + "\"");
      } else if (t === 'upvar') {
         node.carp("accidental shadow of \"" + u + "\"");
      }
      if (t === 'arg' || t === 'function') {
         return name;
      }
   }
   this.variables[u + "."] = type;
   return name;
};
ref$.get = function(name){
   return this.variables[name + "."];
};
ref$.declare = function(name, node, constant){
   var that, scope;
   if (that = this.shared) {
      if (this.check(name)) {
         return;
      }
      scope = that;
   } else {
      scope = this;
   }
   return scope.add(name, constant && name !== "that" ? 'const' : 'var', node);
};
ref$.assign = function(name, value){
   return this.add(name, {
      value: value
   });
};
ref$.temporary = function(name){
   var ref$;
   name || (name = 'ref');
   while ((ref$ = this.variables[name + "$."]) !== 'reuse' && ref$ !== void 8) {
      name = name.length < 2 && name < 'z'
         ? String.fromCharCode(name.charCodeAt() + 1)
         : name.replace(/\d*$/, it => ++it);
   }
   return this.add(name + '$', 'var');
};
ref$.free = function(name){
   return this.add(name, 'reuse');
};
ref$.check = function(name, above){
   var type, ref$;
   if ((type = this.variables[name + "."]) || !above) {
      return type;
   }
   return (ref$ = this.parent) != null ? ref$.check(name, above) : void 8;
};
ref$.checkReadOnly = function(name){
   var that, ref$, key$;
   if (that = this.READ_ONLY[this.check(name, true)]) {
      return that;
   }
   (ref$ = this.variables)[key$ = name + "."] || (ref$[key$] = 'upvar');
   return '';
};
ref$.emit = function(code, tab){
   var vrs, asn, fun, name, ref$, type, that, val, declCode;
   vrs = [];
   asn = [];
   fun = [];
   for (name in ref$ = this.variables) {
      type = ref$[name];
      name = name.slice(0, -1);
      if (type === 'var' || type === 'const' || type === 'reuse') {
         vrs.push(name, ", ");
      } else if (that = type.value) {
         if (~(val = entab(that, tab)).toString().lastIndexOf('function(', 0)) {
            if (val instanceof SourceNode) {
               snRemoveLeft(val, 8);
            } else {
               val = val.slice(8);
            }
            fun.push("function ", name, val, "\n" + tab);
         } else {
            asn.push(name, " = ", val, ", ");
         }
      }
   }
   declCode = vrs.concat(asn);
   declCode.pop();
   fun.pop();
   if (declCode.length > 0) {
      code = sn.apply(null, [this, tab + "var "].concat(arrayFrom$(declCode), [";\n", code]));
   }
   if (fun.length > 0) {
      return sn.apply(null, [this, code, "\n" + tab].concat(arrayFrom$(fun)));
   } else {
      return sn(this, code);
   }
};
function YES(){
   return true;
}
function NO(){
   return false;
}
function THIS(){
   return this;
}
function VOID(){}
UTILS = {
   clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
   extend: "function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",
   // bind: 'function(obj, key, target){\n  return (target || obj)[key].bind(obj);\n}',
   bind: 'function(obj, key){\n  return obj[key].bind(obj);\n}',
   // import: 'Object.assign',
   // importAll: 'Object.assign',
   copyWithout: 'function(src, ex){\n  var obj = {}, own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key) && !own.call(ex, key)) obj[key] = src[key];\n  return obj;\n}',
   repeatString: 'function(str, n){\n  return str.repeat(n < 0 ? 0 : n);\n}',
   repeatArray: 'function(arr, n){\n  for (var r = []; n-- > 0;) r.push(...arr);\n  return r;\n}',
   // in: 'function(x, xs){\n  return [].includes.call(xs, x);\n}',
   out: "typeof exports != 'undefined' && exports || this",
   // curry: 'function(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}',
   flip: 'function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}',
   partialize: 'function(f, args, where){\n  var context = this;\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len < wlen && len ?\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n  };\n}',
   // not: 'function(x){ return !x; }',
   compose: 'function() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}',
   deepEq: "function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  var first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case '[object String]': return a == String(b);\n      case '[object Number]':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        return +a == +b;\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == '[object Array]') {\n      alength = a.length;\n      blength = b.length;\n      if (first) {\n        switch (type) {\n        case '===': result = alength === blength; break;\n        case '<==': result = alength <= blength; break;\n        case '<<=': result = alength < blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === '<<=') {\n            result = size < sizeB;\n          } else if (type === '<==') {\n            result = size <= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}",
   // arrayFrom: 'Array.from',
   // split: "''.split",
   // replace: "''.replace",
   // toString: '{}.toString',
   // join: '[].join',
   // slice: '[].slice',
   // splice: '[].splice'
};
LEVEL_TOP = 0;
LEVEL_PAREN = 1;
LEVEL_LIST = 2;
LEVEL_COND = 3;
LEVEL_OP = 4;
LEVEL_CALL = 5;
(function(){
   this['&&'] = this['||'] = this['xor'] = 0.2;
   this['.&.'] = this['.^.'] = this['.|.'] = 0.3;
   this['=='] = this['!='] = this['~='] = this['!~='] = this['==='] = this['!=='] = 0.4;
   this['<'] = this['>'] = this['<='] = this['>='] = this.of = this['instanceof'] = 0.5;
   this['<<='] = this['>>='] = this['<=='] = this['>=='] = this['++'] = 0.5;
   this['.<<.'] = this['.>>.'] = this['.>>>.'] = 0.6;
   this['+'] = this['-'] = 0.7;
   this['*'] = this['/'] = this['%'] = 0.8;
}.call(PREC = {
   unary: 0.9
}));
TAB = '  ';
ID = /^(?!\d)[\w$\xAA-\uFFDC]+$/;
SIMPLENUM = /^\d+$/;
function util(it){
   return Scope.root.assign(it + '$', UTILS[it]);
}
function entab(code, tab){
   return code.replace(/\n/g, '\n' + tab);
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function repeatArray$(arr, n){
  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
    if (n & 1) r.push.apply(r, arr);
  return r;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
},{"source-map":31}],2:[function(require,module,exports){
(function (){
// Generated by LiveScript 1.6.1
var lexer, parser, ast, SourceNode, toString$ = {}.toString;
lexer = require('./lexer');
parser = require('./parser').parser;
ast = require('./ast');
SourceNode = require('source-map').SourceNode;
parser.yy = ast;
parser.lexer = {
   lex: function(){
      var ref$, tag, first_line, first_column, last_line, last_column;
      ref$ = this.tokens[++this.pos] || [''], tag = ref$[0], this.yytext = ref$[1], first_line = ref$[2], first_column = ref$[3];
      ref$ = this.tokens[this.pos + 1] || [''], last_line = ref$[2], last_column = ref$[3];
      this.yylineno = first_line;
      this.yylloc = {
         first_line: first_line,
         first_column: first_column,
         last_line: last_line,
         last_column: last_column
      };
      return tag;
   },
   setInput: function(it){
      this.pos = -1;
      return this.tokens = it;
   },
   upcomingInput: function(){
      return '';
   }
};
exports.VERSION = '1.5.0';
exports.compile = function(code, options){
   var result, ast, output, filename, outputFilename, mapPath, base64;
   options == null && (options = {});
   options.warn == null && (options.warn = true);
   options.header == null && (options.header = true);
   if (options.header === true) {
      options.header = "// Generated by LiveScript2 " + exports.VERSION + "\n";
   }
   try {
      if (options.json) {
         result = Function(exports.compile(code, {
            bare: true,
            run: true,
            print: true
         }))();
         return JSON.stringify(result, null, 2) + "\n";
      } else {
         code = code.replace(/(?<=^|\n)\t*(?!\n|$)/g, s => '  '.repeat(s.length + !options.bare))
         if (!options.bare) {
            code = "(!->\n" + code + "\n) @"
         }
         ast = parser.parse(lexer.lex(code));
         if (options.run && options.print) {
            ast.makeReturn();
         }
         output = ast.compileRoot(options);
         if (options.map && options.map !== 'none') {
            filename = options.filename, outputFilename = options.outputFilename;
            if (!filename) {
               filename = "unnamed-" + Math.floor(Math.random() * 4294967296).toString(16) + ".ls";
            }
            output.setFile(filename.replace(/\/+$/g).split('/').pop());
            result = output.toStringWithSourceMap();
            if (options.map === 'embedded') {
               result.map.setSourceContent(filename, code);
            }
            if (options.map === 'linked' || options.map === 'debug') {
               mapPath = outputFilename.replace(/\/+$/g).split('/').pop() + ".map";
               result.code += "\n//# sourceMappingURL=" + mapPath + "\n";
            } else {
               base64 = result.map.toString()
               if (isNode) {
                  base64 = require('buffer').Buffer.alloc(base64).toString('base64');
               } else {
                  base64 = btoa(base64);
               }
               result.code += "\n//# sourceMappingURL=data:application/json;base64," + base64 + "\n";
            }
            return result;
         } else {
            return output.toString() + "\n";
         }
      }
   } catch (e) {
      if (options.filename) {
         e.message += "\nat " + options.filename;
      }
      throw e;
   }
};
exports.ast = function(it){
   return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);
};
exports.tokens = lexer.lex;
exports.lex = function(it){
   return lexer.lex(it, {raw: true});
};
exports.run = function(code, options){
   var output;
   output = exports.compile(code, {bare: false, ...options, run: true});
   return globalThis.eval(typeof output === 'string' ? output : output.code);
};
exports.eval = function(code, options){
   return exports.run(code, {...options, print: true});
};
exports.tokens.rewrite = lexer.rewrite;
Object.assign(exports.ast, parser.yy);
if (require.extensions) {
   require('./node')(exports);
} else {
   exports.require = require;
}
}).call(this)
},{"./ast":1,"./lexer":3,"./node":4,"./parser":5,"source-map":31}],3:[function(require,module,exports){
// Generated by LiveScript 1.6.1
var string, TABS, unlines, enlines, enslash, reslash, camelize, deheregex, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, JS_KEYWORDS, LS_KEYWORDS, ID, ID_INTERPOLATE, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, slice$ = [].slice, arrayFrom$ = Array.from;
exports.lex = function(code, options){
   return clone$(exports).tokenize(code || '', options || {});
};
exports.rewrite = function(it){
   var ref$;
   it || (it = this.tokens);
   firstPass(it);
   addImplicitIndentation(it);
   rewriteBlockless(it);
   addImplicitParentheses(it);
   expandLiterals(it);
   addImplicitBraces(it);
   if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
      it.shift();
   }
   return it;
};
exports.tokenize = function(code, o){
   var i, prevIndex, c, charsConsumed, that;
   this.inter || (code = code.replace(/[\r\u2028\u2029\uFEFF]/g, ''));
   code = '\n' + code;
   this.tokens = [this.last = ['NEWLINE', '\n', 0, 0]];
   this.line = ~-o.line;
   this.column = o.column || 0;
   this.dents = [];
   this.closes = [];
   this.parens = [];
   this.flags = [];
   i = 0;
   prevIndex = i;
   this.charsCounted = 0;
   this.isAtPrefix = true;
   while (c = code.charAt(i)) {
      charsConsumed = i - prevIndex;
      prevIndex = i;
      if (this.charsCounted > charsConsumed) {
         throw new Error('Location information out-of-sync in lexer');
      }
      this.column += charsConsumed - this.charsCounted;
      this.charsCounted = 0;
      switch (c) {
      case ' ':
         i += this.doSpace(code, i);
         break;
      case '\n':
         i += this.doLine(code, i);
         break;
      case '\\':
         i += this.doBackslash(code, i);
         break;
      case "'":
      case '"':
         i += this.doString(code, i, c);
         break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
         i += this.doNumber(code, i);
         break;
      case '/':
         switch (code.charAt(i + 1)) {
         case '*':
            i += this.doComment(code, i);
            break;
         case '/':
            i += this.doHeregex(code, i);
            break;
         default:
            i += this.doRegex(code, i) || this.doLiteral(code, i);
         }
         break;
      case '`':
         if ('`' === code.charAt(i + 1)) {
            i += this.doJS(code, i);
         } else {
            i += this.doLiteral(code, i);
         }
         break;
      default:
         i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
      }
   }
   this.dedent(this.dent);
   if (that = this.closes.pop()) {
      this.carp("missing `" + that + "`");
   }
   if (this.inter) {
      this.rest == null && this.carp('unterminated interpolation');
   } else {
      this.last.spaced = true;
      this.newline();
   }
   o.raw || this.rewrite();
   return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.reset = function(){
   this.dent = 0;
   this.identifiers = {};
};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
   if (this.hasOwn.call(this.identifiers, camel) && this.identifiers[camel] !== id) {
      throw new ReferenceError("Inconsistent use of " + camel + " as " + id + " on line " + (-~this.line));
   } else {
      return this.identifiers[camel] = id;
   }
};
exports.doID = function(code, index){
   var regexMatch, input, id, last, ref$, tag, ref1$, that;
   input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
   if (!input) {
      return 0;
   }
   id = camelize(regexMatch[1]);
   if (/-/.test(regexMatch[1])) {
      this.checkConsistency(id, regexMatch[1]);
   }
   if (NONASCII.test(id)) {
      try {
         Function("var " + id);
      } catch (e) {
         this.carp("invalid identifier '" + id + "'");
      }
   }
   last = this.last;
   if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {
      this.token('ID', JS_KEYWORDS.includes(id) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
      if (regexMatch[2]) {
         this.token(':', ':');
      }
      return input.length;
   }
   switch (id) {
   case 'true':
   case 'false':
   case 'on':
   case 'off':
   case 'yes':
   case 'no':
   case 'null':
   case 'void':
   case 'arguments':
   case 'debugger':
      tag = 'LITERAL';
      break;
   case 'new':
   case 'do':
   case 'typeof':
   case 'delete':
      tag = 'UNARY';
      break;
   case 'yield':
   case 'await':
      tag = 'YIELD';
      break;
   case 'return':
   case 'throw':
      tag = 'HURL';
      break;
   case 'break':
   case 'continue':
      tag = 'JUMP';
      break;
   case 'this':
   case 'eval':
   case 'super':
      return this.token('LITERAL', id, true).length;
   case 'for':
      id = [];
      this.fset('for', true);
      this.fset('to', false);
      this.fset('by', true);
      break;
   case 'then':
      this.fset('for', false);
      this.fset('to', false);
      break;
   case 'catch':
   case 'function':
      id = '';
      break;
   case 'in':
   case 'of':
      if (this.fget('for')) {
         this.fset('for', false);
         if (id === 'in') {
            this.fset('by', true);
            id = '';
            if (last[0] === 'ID' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === ',' || ref$ === ']' || ref$ === '}')) {
               id = this.tokens.pop()[1];
               if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {
                  this.tokens.pop();
               }
            }
         }
         break;
      }
      // fallthrough
   case 'instanceof':
      if (last[1] === '!') {
         id = this.tokens.pop()[1] + id;
      }
      tag = (ref$ = this.tokens)[ref$.length - 1][0] === '(' ? 'BIOPR' : 'RELATION';
      break;
   case 'not':
      if (last.alias && last[1] === '===') {
         return last[1] = '!==', 3;
      }
      tag = 'UNARY';
      id = '!';
      break;
   case 'and':
   case 'or':
   case 'xor':
   case 'is':
   case 'isnt':
      this.unline();
      tag = id === 'is' || id === 'isnt' ? 'COMPARE' : 'LOGIC';
      if (last[0] === '(') {
         tag = 'BIOP';
      }
      this.token(tag, (function(){
         switch (id) {
         case 'is':
            return '===';
         case 'isnt':
            return '!==';
         case 'or':
            return '||';
         case 'and':
            return '&&';
         case 'xor':
            return 'xor';
         }
      }()));
      this.last.alias = true;
      return id.length;
   case 'unless':
      tag = 'IF';
      break;
   case 'until':
      tag = 'WHILE';
      break;
   case 'const':
   case 'var':
      tag = 'DECL';
      break;
   case 'with':
      tag = (function(){
         switch (false) {
         case !able(this.tokens):
            return 'CLONEPORT';
         case last[0] !== '(':
            return 'BIOP';
         default:
            return 'WITH';
         }
      }.call(this));
      break;
   case 'when':
      tag = 'CASE';
      // fallthrough
   case 'case':
      if (this.doCase()) {
         return input.length;
      }
      break;
   case 'match':
      tag = 'SWITCH';
      break;
   case 'loop':
      this.token('WHILE', id);
      this.token('LITERAL', 'true');
      return input.length;
   case 'let':
   case 'own':
      if (last[0] === 'FOR' && !last[1].includes(id)) {
         last[1].push(id);
         return 3;
      }
      // fallthrough
   default:
      if (KEYWORDS_SHARED.includes(id)) {
         break;
      }
      if (KEYWORDS_UNUSED.includes(id)) {
         this.carp("reserved word '" + id + "'");
      }
      if (!last[1] && ((ref$ = last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LABEL')) {
         last[1] = id;
         last.spaced = false;
         return input.length;
      }
      tag = 'ID';
      switch (id) {
      case 'otherwise':
         if ((ref$ = last[0]) === 'CASE' || ref$ === '|') {
            last[0] = 'DEFAULT';
            return id.length;
         }
         break;
      case 'all':
         if (that = last[1] === '<<<' && '<' || last[1] === 'import' && 'All') {
            last[1] += that;
            return 3;
         }
         break;
      case 'from':
         if (last[1] === 'yield') {
            last[1] += 'from';
            return 4;
         }
         this.forange() && (tag = 'FROM');
         break;
      case 'to':
      case 'til':
         this.forange() && this.tokens.push(['FROM', '', this.line, this.column], ['STRNUM', '0', this.line, this.column]);
         if (this.fget('from')) {
            this.fset('from', false);
            this.fset('by', true);
            tag = 'TO';
         } else if (!last.callable && last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === '[') {
            last[0] = 'RANGE';
            last.op = id;
            return id.length;
         } else if (this.closes.includes(']')) {
            this.token('TO', id);
            return id.length;
         }
         break;
      case 'by':
         if (last[0] === 'STRNUM' && !(ref$ = this.tokens)[ref$.length - 2][0] && (ref$ = this.tokens)[ref$.length - 3][0] === '[') {
            tag = 'RANGE_BY';
         } else if (this.closes.includes(']')) {
            tag = 'BY';
         } else if (this.fget('by') && last[0] !== 'FOR') {
            tag = 'BY';
            this.fset('by', false);
         }
         break;
      case 'ever':
         if (last[0] === 'FOR') {
            this.fset('for', false);
            last[0] = 'WHILE';
            tag = 'LITERAL';
            id = 'true';
         }
      }
   }
   tag || (tag = regexMatch[1].toUpperCase());
   if ((tag === 'COMPARE' || tag === 'LOGIC' || tag === 'RELATION') && last[0] === '(') {
      tag = tag === 'RELATION' ? 'BIOPR' : 'BIOP';
   }
   if (tag === 'THEN' || tag === 'IF' || tag === 'WHILE') {
      this.fset('for', false);
      this.fset('by', false);
   }
   if (tag === 'RELATION' || tag === 'THEN' || tag === 'ELSE' || tag === 'CASE' || tag === 'DEFAULT' || tag === 'CATCH' || tag === 'FINALLY' || tag === 'IN' || tag === 'OF' || tag === 'FROM' || tag === 'TO' || tag === 'BY' || tag === 'EXTENDS' || tag === 'IMPLEMENTS' || tag === 'WHERE') {
      this.unline();
   }
   this.token(tag, id);
   return input.length;
};
exports.doNumber = function(code, lastIndex){
   var input, regexMatch, last, radix, num, rnum, bound, ref$;
   NUMBER.lastIndex = lastIndex;
   if (!(input = (regexMatch = NUMBER.exec(code))[0])) {
      return 0;
   }
   last = this.last;
   if (regexMatch[5] && (last[0] === 'DOT' || this.adi())) {
      this.token('STRNUM', regexMatch[4].replace(NUMBER_OMIT, ''));
      return regexMatch[4].length;
   }
   if (radix = regexMatch[1]) {
      num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, ''), radix);
      bound = false;
      if (radix > 36 || radix < 2) {
         if (/[0-9]/.exec(rnum)) {
            this.carp("invalid number base " + radix + " (with number " + rnum + "),base must be from 2 to 36");
         } else {
            bound = true;
         }
      }
      if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
         this.strnum(regexMatch[1]);
         this.token('DOT', '.~');
         this.token('ID', regexMatch[2]);
         return input.length;
      }
      num += '';
   } else {
      num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');
      if (regexMatch[3] && num.charAt() === '0' && ((ref$ = num.charAt(1)) !== '' && ref$ !== '.')) {
         this.carp("deprecated octal literal " + regexMatch[4]);
      }
   }
   if (!last.spaced && last[0] === '+-') {
      last[0] = 'STRNUM';
      last[1] += num;
      return input.length;
   }
   this.strnum(num);
   return input.length;
};
exports.doString = function(code, index, q){
   var parts, str;
   if (q === code.charAt(index + 1)) {
      return q === code.charAt(index + 2)
         ? this.doHeredoc(code, index, q)
         : (this.strnum(q + q), 2);
   }
   if (q === '"') {
      parts = this.interpolate(code, index, q);
      this.addInterpolated(parts, unlines);
      return parts.size;
   }
   str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
   this.strnum(unlines(this.string(q, str.slice(1, -1))));
   return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
   var end, raw, doc, parts, tabs, i$, len$, i, t;
   if (q === "'") {
      ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
      raw = code.slice(index + 3, end);
      doc = raw.replace(LASTDENT, '');
      this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));
      return this.countLines(raw).length + 6;
   }
   parts = this.interpolate(code, index, q + q + q);
   tabs = heretabs(code.slice(index + 3, index + parts.size - 3).replace(LASTDENT, ''));
   for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
      i = i$;
      t = parts[i$];
      if (t[0] === 'S') {
         if (i + 1 === parts.length) {
            t[1] = t[1].replace(LASTDENT, '');
         }
         t[1] = detab(t[1], tabs);
         if (i === 0) {
            t[1] = lchomp(t[1]);
         }
      }
   }
   this.addInterpolated(parts, enlines);
   return parts.size;
};
exports.doComment = function(code, index){
   var comment, end, ref$;
   comment = ~(end = code.indexOf('*/', index + 2))
      ? code.slice(index, end + 2)
      : code.slice(index) + '*/';
   if ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN') {
      this.token('COMMENT', detab(comment, this.dent));
      this.token('NEWLINE', '\n');
   }
   return this.countLines(comment).length;
};
exports.doJS = function(code, lastIndex){
   var js, ref$;
   JSTOKEN.lastIndex = lastIndex;
   js = JSTOKEN.exec(code)[0] || this.carp('unterminated JS literal');
   this.token('LITERAL', (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);
   return this.countLines(js).length;
};
exports.doRegex = function(code, index){
   var divisible, ref$, input, body, flag;
   if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {
      if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === ' ' || ref$ === '=')) {
         return 0;
      }
   }
   ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
   if (input) {
      this.regex(body, flag);
   } else if (!divisible && this.last[0] !== '(') {
      this.carp('unterminated regex');
   }
   return input.length;
};
exports.doHeregex = function(code, index){
   var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
   tokens = this.tokens, last = this.last;
   parts = this.interpolate(code, index, '//');
   rest = code.slice(index + parts.size);
   flag = this.validate(/^(?:[dgimsuy]{1,7}|[?$]?)/.exec(rest)[0]);
   if (parts[1]) {
      if (flag === '$') {
         this.adi();
         this.token('(', '"');
      } else {
         tokens.push(['ID', 'RegExp', last[2], last[3]], ['CALL(', '', last[2], last[3]]);
         if (flag === '?') {
            for (i$ = parts.length - 1; i$ >= 0; --i$) {
               i = i$;
               t = parts[i$];
               if (t[0] === 'TOKENS') {
                  dynaflag = parts.splice(i, 1)[0][1];
                  break;
               }
            }
         }
      }
      for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
         i = i$;
         t = parts[i$];
         if (t[0] === 'TOKENS') {
            tokens.push.apply(tokens, t[1]);
         } else {
            val = deheregex(t[1]);
            if (one && !val) {
               continue;
            }
            one = tokens.push((t[0] = 'STRNUM', t[1] = this.string("'", enslash(val)), t));
         }
         tokens.push(['+-', '+', tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]]);
      }
      --tokens.length;
      if (dynaflag || flag >= 'g') {
         this.token(',', ',');
         if (dynaflag) {
            tokens.push.apply(tokens, dynaflag);
         } else {
            this.token('STRNUM', "'" + flag + "'");
         }
      }
      this.token(flag === '$' ? ')' : ')CALL', '');
   } else {
      this.regex(reslash(deheregex(parts[0][1])), flag);
   }
   return parts.size + flag.length;
};
exports.doBackslash = function(code, lastIndex){
   var ref$, input, word;
   BSTOKEN.lastIndex = lastIndex;
   ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];
   if (word) {
      this.strnum(this.string("'", word));
   } else {
      this.countLines(input);
   }
   return input.length;
};
exports.doLine = function(code, index){
   var ref$, input, tabs, length, last, that, delta, tag, val;
   ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];
   length = this.countLines(input).length;
   last = this.last;
   last.eol = true;
   last.spaced = true;
   if (index + length >= code.length) {
      return length;
   }
   if (that = tabs && (this.emender || (this.emender = RegExp('[^' + tabs.charAt() + ']'))).exec(tabs)) {
      this.carp("contaminated indent " + escape(that));
   }
   if (0 > (delta = tabs.length - this.dent)) {
      this.dedent(-delta);
      this.newline();
   } else {
      tag = last[0], val = last[1];
      if (tag === 'ASSIGN' && ((ref$ = val + '') !== '=' && ref$ !== ':=' && ref$ !== '+=') || tag === 'CREMENT' && val === '++' && (ref$ = this.tokens)[ref$.length - 2].spaced || (tag === '+-' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'MATH' || tag === 'COMPARE' || tag === 'RELATION' || tag === 'SHIFT' || tag === 'IN' || tag === 'OF' || tag === 'TO' || tag === 'BY' || tag === 'FROM' || tag === 'EXTENDS' || tag === 'IMPLEMENTS')) {
         return length;
      }
      if (delta) {
         this.indent(delta);
      } else {
         this.newline();
      }
   }
   this.fset('for', false);
   this.fset('by', false);
   return length;
};
exports.doSpace = function(code, lastIndex){
   var input;
   SPACE.lastIndex = lastIndex;
   if (input = SPACE.exec(code)[0]) {
      this.last.spaced = true;
   }
   return input.length;
};
exports.doCase = function(){
   var ref$, ref1$;
   this.fset('for', false);
   if (((ref$ = this.last[0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':') || (this.last[0] === 'INDENT' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':'))) {
      this.token('SWITCH', 'switch');
      return this.token('CASE', 'case');
   }
};
exports.doLiteral = function(code, index){
   var sym, tag, val, ref$, that;
   if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {
      return 0;
   }
   switch (tag = val = sym) {
   case '|':
      tag = 'CASE';
      if (this.doCase()) {
         return sym.length;
      }
      break;
   case '|>':
      tag = 'PIPE';
      break;
   case '`':
      tag = 'BACKTICK';
      break;
   case '<<':
   case '>>':
      tag = 'COMPOSE';
      break;
   case '<|':
      tag = 'BACKPIPE';
      break;
   case '+':
   case '-':
      tag = '+-';
      break;
   case '&&':
   case '||':
      tag = 'LOGIC';
      break;
   case '.&.':
   case '.|.':
   case '.^.':
      tag = 'BITWISE';
      break;
   case '^^':
      tag = 'CLONE';
      break;
   case '**':
   case '^':
      tag = 'POWER';
      break;
   case '?':
      if (this.last[0] === '(') {
         this.token('PARAM(', '(');
         this.token(')PARAM', ')');
         this.token('->', '->');
         this.token('ID', 'it');
      } else {
         if (this.last.spaced) {
            tag = 'LOGIC';
         }
      }
      break;
   case '/':
   case '%':
   case '%%':
      tag = 'MATH';
      break;
   case '++':
   case '--':
      tag = 'CREMENT';
      break;
   case '<<<':
   case '<<<<':
      tag = 'IMPORT';
      break;
   case ';':
      tag = 'NEWLINE';
      this.fset('by', false);
      break;
   case '..':
      this.token('LITERAL', '..', true);
      return 2;
   case '.':
      if (this.last[1] === '?') {
         this.last[0] = '?';
      }
      tag = 'DOT';
      break;
   case ',':
      switch (this.last[0]) {
      case ',':
      case '[':
      case '(':
      case 'CALL(':
         this.token('LITERAL', 'void');
         break;
      case 'FOR':
      case 'OWN':
         this.token('ID', '');
      }
      break;
   case '!=':
   case '~=':
      if (!(able(this.tokens) || ((ref$ = this.last[0]) === '(' || ref$ === 'CREMENT'))) {
         this.tokens.push(val === '!='
            ? ['UNARY', '!', this.line, this.column]
            : ['UNARY', '~', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
         return 2;
      }
      // fallthrough
   case '!~=':
   case '==':
      val = (function(){
         switch (val) {
         case '~=':
            return '==';
         case '!~=':
            return '!=';
         case '==':
            return '===';
         case '!=':
            return '!==';
         }
      }());
      tag = 'COMPARE';
      break;
   case '===':
   case '!==':
      val += '=';
      // fallthrough
   case '<':
   case '>':
   case '<=':
   case '>=':
   case '<==':
   case '>==':
   case '>>=':
   case '<<=':
      tag = 'COMPARE';
      break;
   case '.<<.':
   case '.>>.':
   case '.>>>.':
   case '<?':
   case '>?':
      tag = 'SHIFT';
      break;
   case '(':
      if (!(((ref$ = this.last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LET') || this.able(true) || this.last[1] === '.@')) {
         this.token('(', '(');
         this.closes.push(')');
         this.parens.push(this.last);
         return 1;
      }
      tag = 'CALL(';
      this.closes.push(')CALL');
      break;
   case '[':
   case '{':
      this.adi();
      this.closes.push(']}'.charAt(val === '{'));
      break;
   case '}':
      if (this.inter && val !== (ref$ = this.closes)[ref$.length - 1]) {
         this.rest = code.slice(index + 1);
         return 9e9;
      }
      // fallthrough
   case ']':
   case ')':
      if (tag === ')' && ((ref$ = this.last[0]) === '+-' || ref$ === 'COMPARE' || ref$ === 'LOGIC' || ref$ === 'MATH' || ref$ === 'POWER' || ref$ === 'SHIFT' || ref$ === 'BITWISE' || ref$ === 'CONCAT' || ref$ === 'COMPOSE' || ref$ === 'RELATION' || ref$ === 'PIPE' || ref$ === 'BACKPIPE' || ref$ === 'IMPORT' || ref$ === 'CLONEPORT' || ref$ === 'ASSIGN')) {
         (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
            switch (this.last[0]) {
            case 'RELATION':
               return 'BIOPR';
            case 'PIPE':
               this.parameters(false, -1);
               return 'BIOPP';
            default:
               return 'BIOP';
            }
         }.call(this));
      }
      if (')' === (tag = val = this.pair(val))) {
         this.lpar = this.parens.pop();
      }
      break;
   case '=':
   case ':':
      if (val === ':') {
         switch (this.last[0]) {
         case 'ID':
         case 'STRNUM':
         case ')':
            break;
         case '...':
            this.last[0] = 'STRNUM';
            break;
         default:
            tag = 'LABEL';
            val = '';
         }
         this.token(tag, val);
         return sym.length;
      }
      // fallthrough
   case ':=':
   case '+=':
   case '-=':
   case '*=':
   case '/=':
   case '%=':
   case '%%=':
   case '<?=':
   case '>?=':
   case '**=':
   case '^=':
   case '.&.=':
   case '.|.=':
   case '.^.=':
   case '.<<.=':
   case '.>>.=':
   case '.>>>.=':
   case '++=':
   case '|>=':
      if (this.last[1] === '.' || this.last[0] === '?' && this.adi()) {
         this.last[1] += val;
         return val.length;
      }
      if (this.last[0] === 'LOGIC') {
         (val = Object(val)).logic = this.tokens.pop()[1];
      } else if ((val === '+=' || val === '-=') && !able(this.tokens) && ((ref$ = this.last[0]) !== '+-' && ref$ !== 'UNARY' && ref$ !== 'LABEL')) {
         this.token('UNARY', val.charAt());
         val = '=';
      }
      tag = 'ASSIGN';
      break;
   case '::=':
      this.token('DOT', '.');
      this.token('ID', 'prototype');
      this.token('IMPORT', '<<');
      return sym.length;
   case '*':
      if (this.last[0] === 'FUNCTION') {
         this.last[0] = 'GENERATOR';
         return sym.length;
      }
      if (
         that = ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN' || ref$ === '=>') &&
         (INLINEDENT.lastIndex = index + 1, INLINEDENT).exec(code)[0].length
      ) {
         this.tokens.push(['LITERAL', 'void', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
         this.indent(index + that - 1 - this.dent - code.lastIndexOf('\n', index - 1));
         return that;
      }
      tag = able(this.tokens) || this.last[0] === 'CREMENT' && able(this.tokens, this.tokens.length - 1) || this.last[0] === '(' ? 'MATH' : 'STRNUM';
      break;
   case '@':
      this.adi();
      if (this.last[0] === 'DOT' && this.last[1] === '.' && (ref$ = this.tokens)[ref$.length - 2][0] === 'ID' && (ref$ = this.tokens)[ref$.length - 2][1] === 'constructor') {
         this.tokens.pop();
         this.tokens.pop();
         this.token('LITERAL', 'this', true);
         this.adi();
         this.token('ID', 'constructor', true);
      } else {
         this.token('LITERAL', 'this', true);
      }
      return 1;
   case '@@':
      this.adi();
      this.token('ID', 'constructor', true);
      return 2;
   case '&':
      this.token('LITERAL', 'arguments');
      return 1;
   case '!':
      switch (false) {
      default:
         if (!this.last.spaced) {
            if (this.last[1] === 'require') {
               this.last[0] = 'REQUIRE';
               this.last[1] = 'require!';
            } else if (able(this.tokens, null, true)) {
               this.token('CALL(', '!');
               this.token(')CALL', ')');
            } else if (this.last[1] === 'typeof') {
               this.last[1] = 'classof';
            } else if (this.last[1] === 'delete') {
               this.last[1] = 'jsdelete';
            } else {
               break;
            }
            return 1;
         }
      }
      tag = 'UNARY';
      break;
   case '|':
      tag = 'BITWISE';
      break;
   case '~':
      if (this.dotcat(val)) {
         return 1;
      }
      tag = 'UNARY';
      break;
   case '::':
      this.adi();
      val = 'prototype';
      tag = 'ID';
      break;
   case '=>':
      this.unline();
      this.fset('for', false);
      tag = 'THEN';
      break;
   default:
      if (/^!?(?:--?|~~?)>>?\*?$/.test(val)) {
         this.parameters(tag = '->');
      } else if (/^\*?<(?:--?|~~?)!?$/.test(val)) {
         this.parameters(tag = '<-');
      } else {
         switch (val.charAt(0)) {
         case '(':
            this.token('CALL(', '(');
            tag = ')CALL';
            val = ')';
            break;
         case '<':
            if (val.length < 4) {
               this.carp('unterminated words');
            }
            this.token('WORDS', val.slice(2, -2), this.adi());
            return this.countLines(val).length;
         }
      }
   }
   if ((tag === '+-' || tag === 'COMPARE' || tag === 'LOGIC' || tag === 'MATH' || tag === 'POWER' || tag === 'SHIFT' || tag === 'BITWISE' || tag === 'CONCAT' || tag === 'RELATION' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'IMPORT') && this.last[0] === '(') {
      tag = tag === 'BACKPIPE' ? 'BIOPBP' : 'BIOP';
   }
   if (tag === ',' || tag === 'CASE' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'COMPARE' || tag === 'MATH' || tag === 'POWER' || tag === 'IMPORT' || tag === 'SHIFT' || tag === 'BITWISE') {
      this.unline();
   }
   this.token(tag, val);
   return sym.length;
};
exports.token = function(tag, value, callable){
   this.tokens.push(this.last = [tag, value, this.line, this.column]);
   if (callable) {
      this.last.callable = true;
   }
   return value;
};
exports.indent = function(delta){
   this.dent += delta;
   this.dents.push(this.token('INDENT', delta));
   this.closes.push('DEDENT');
};
exports.dedent = function(debt){
   var dent;
   this.dent -= debt;
   while (debt > 0 && (dent = this.dents.pop())) {
      if (debt < dent && !this.inter) {
         this.carp("unmatched dedent (" + debt + " for " + dent + ")");
      }
      this.pair('DEDENT');
      debt -= typeof dent === 'number' ? this.token('DEDENT', dent) : dent;
   }
};
exports.newline = function(){
   var ref$;
   if (!(this.last[0] === 'NEWLINE' && this.last[1] === '\n')) {
      this.tokens.push(this.last = (ref$ = ['NEWLINE', '\n', this.line, this.column], ref$.spaced = true, ref$));
   }
};
exports.unline = function(){
   var ref$;
   if (!this.tokens[1]) {
      return;
   }
   switch (this.last[0]) {
   case 'INDENT':
      (ref$ = this.dents)[ref$.length - 1] += '';
      // fallthrough
   case 'NEWLINE':
      this.tokens.length--;
   }
};
exports.parameters = function(arrow, offset){
   var i$, ref$, i, t, ref1$;
   if (this.last[0] === ')' && ')' === this.last[1]) {
      this.lpar[0] = 'PARAM(';
      this.last[0] = ')PARAM';
      return;
   }
   if (arrow === '->') {
      this.token('PARAM(', '');
   } else {
      for (i$ = (ref$ = this.tokens).length - 1; i$ >= 0; --i$) {
         i = i$;
         t = ref$[i$];
         if ((ref1$ = t[0]) === 'NEWLINE' || ref1$ === 'INDENT' || ref1$ === 'THEN' || ref1$ === '=>' || ref1$ === '(') {
            break;
         }
      }
      this.tokens.splice(i + 1, 0, ['PARAM(', '', t[2], t[3]]);
   }
   if (offset) {
      this.tokens.splice(this.tokens.length + offset, 0, [')PARAM', '', t[2], t[3]]);
   } else {
      this.token(')PARAM', '');
   }
};
exports.interpolate = function(str, idx, end){
   var parts = [], end0 = end[0], pos = 0, i = -1, ref$, oldLine, oldColumn, ch, n = -1, inComment, id, prop, stringified, length, tag, delta, nested, clone, ref1$;
   str = str.slice(idx + end.length);
   ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
   this.countLines(end);
   while (ch = str[++i]) {
      ++n;
      switch (ch) {
      case end0:
         if (end !== str.slice(i, i + end.length)) {
            continue;
         }
         parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
         this.countLines(end);
         return parts.size = pos + i + end.length * 2, parts;
      case '#':
         if (inComment) continue;
         id = (ID_INTERPOLATE.lastIndex = i + 1, ID_INTERPOLATE).exec(str)[1];
         if (!(id || str[i + 1] === '{')) {
            if (end === '//') {
               if (!n || /\s/.test(str[i - 1])) {
                  inComment = true;
               }
            }
            continue;
         }
         break;
      case '\n':
         if (inComment) {
            inComment = false;
         }
         continue;
      case '\\':
         if (inComment) continue;
         ++i;
         continue;
      default:
         continue;
      }
      if (i || nested && !stringified) {
         stringified = parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
         ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
      }
      if (id) {
         length = id.length;
         if (id === '@') {
            id = 'this'
         } else if (id[0] === '@') {
            prop = id.substring(1);
            if (/^\d+$/.test(prop)) {
               id = 'this[' + prop + ']'
            } else {
               id = 'this.' + camelize(prop);
            }
         } else {
            id = camelize(id);
            // try {
            // 	Function("'use strict'; var " + id);
            // } catch (e) {
            // 	this.carp("invalid variable interpolation '" + id + "'");
            // }
         }
         tag = 'ID';
         str = str.slice(delta = i + 1 + length);
         parts.push(['TOKENS', nested = [[tag, id, this.line, this.column]]]);
      } else {
         clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);
         nested = clone.tokenize(str.slice(i + 2), {
            line: this.line,
            column: this.column + 2,
            raw: true
         });
         delta = str.length - clone.rest.length;
         this.countLines(str.slice(i, delta));
         str = clone.rest;
         while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
            nested.shift();
         }
         if (nested.length) {
            nested.unshift(['(', '(', oldLine, oldColumn]);
            nested.push([')', ')', this.line, this.column - 1]);
            parts.push(['TOKENS', nested]);
         }
         ref1$ = [this.line, this.column], oldLine = ref1$[0], oldColumn = ref1$[1];
      }
      pos += delta;
      i = -1;
   }
   this.carp("missing `" + end + "`");
};
exports.addInterpolated = function(parts, nlines){
   var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;
   if (!parts[1]) {
      return this.strnum(nlines(this.string('"', parts[0][1])));
   }
   tokens = this.tokens, last = this.last;
   ref$ = !last.spaced && last[1] === '%'
      ? (--tokens.length, this.last = last = tokens[tokens.length - 1], ['[', ']', [',', ',']])
      : ['(', ')', ['+-', '+']], left = ref$[0], right = ref$[1], joint = ref$[2];
   callable = this.adi();
   tokens.push([left, '"', last[2], last[3]]);
   for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
      i = i$;
      t = parts[i$];
      if (t[0] === 'TOKENS') {
         tokens.push.apply(tokens, t[1]);
      } else {
         if (i > 1 && !t[1]) {
            continue;
         }
         tokens.push(['STRNUM', nlines(this.string('"', t[1])), t[2], t[3]]);
      }
      tokens.push(joint.concat(tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]));
   }
   --tokens.length;
   this.token(right, '', callable);
};
exports.strnum = function(it){
   this.token('STRNUM', it, this.adi() || this.last[0] === 'DOT');
};
exports.regex = function(body, flag){
   try {
      RegExp(body);
   } catch (e) {
      this.carp(e.message);
   }
   if (flag === '$') {
      return this.strnum(this.string("'", enslash(body)));
   }
   return this.token('LITERAL', "/" + (body || '(?:)') + "/" + this.validate(flag));
};
exports.adi = function(){
   if (this.last.spaced || !able(this.tokens)) {
      return;
   }
   return this.token('DOT', '.');
};
exports.dotcat = function(it){
   if (this.last[1] === '.' || this.adi()) {
      return this.last[1] += it;
   }
};
exports.pair = function(it){
   var wanted, ref$;
   if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || ')CALL' === wanted && it === ')')) {
      if ('DEDENT' !== wanted) {
         this.carp("unmatched `" + it + "`");
      }
      this.dedent((ref$ = this.dents)[ref$.length - 1]);
      return this.pair(it);
   }
   this.unline();
   this.fclear();
   return this.closes.pop();
};
exports.able = function(call){
   return !this.last.spaced && able(this.tokens, null, call);
};
exports.countLines = function(it){
   var pos;
   if (!this.isAtPrefix) {
      this.column += it.length;
   }
   while (pos = 1 + it.indexOf('\n', pos)) {
      if (!this.isAtPrefix) {
         this.column = 0;
      }
      this.column += it.length - pos;
      ++this.line;
      this.isAtPrefix = false;
   }
   this.charsCounted += it.length;
   return it;
};
exports.forange = function(){
   var ref$, ref1$, ref2$;
   if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) === 'NEWLINE' || ref2$ === 'INDENT')]) != null ? ref$[0] : void 8) === 'FOR' || this.last[0] === 'FOR') {
      this.fset('for', false);
      this.fset('from', true);
      return true;
   } else {
      return false;
   }
};
exports.validate = function(flag){
   var that;
   if (that = flag && /(.).*\1/.exec(flag)) {
      this.carp("duplicate regex flag `" + that[1] + "`");
   }
   return flag;
};
exports.fget = function(key){
   var ref$;
   return (ref$ = this.flags[this.closes.length]) != null ? ref$[key] : void 8;
};
exports.fset = function(key, val){
   var ref$, key$;
   ((ref$ = this.flags)[key$ = this.closes.length] || (ref$[key$] = {}))[key] = val;
};
exports.fclear = function(){
   this.flags.splice(this.closes.length);
};
exports.carp = function(it){
   carp(it, this.line);
};
exports.string = function(q, body){
   return string(q, body, this.line);
};
function carp(msg, lno){
   throw SyntaxError(msg + " on line " + (-~lno));
}
function able(tokens, i, call){
   var token, tag;
   i == null && (i = tokens.length);
   tag = (token = tokens[i - 1])[0];
   return (tag === 'ID' || tag === ']' || tag === '?') || (call
      ? token.callable || (tag === ')' || tag === ')CALL' || tag === 'BIOPBP') && token[1]
      : tag === '}' || tag === ')' || tag === ')CALL' || tag === 'STRNUM' || tag === 'LITERAL' || tag === 'WORDS');
}
string = (function(re){
   return function(q, body, lno){
      body = body.replace(re, function(it, oct, xu, rest){
         if (it === q || it === '\\') {
            return '\\' + it;
         }
         if (oct) {
            return '\\x' + (0x100 + parseInt(oct, 8)).toString(16).slice(1);
         }
         if (xu) {
            carp('malformed character escape sequence', lno);
         }
         if (!rest || q === rest) {
            return it;
         } else {
            return rest;
         }
      });
      return q + body + q;
   };
}.call(this, /['"]|\\(?:([0-3]?[0-7]{2}|[1-7]|0(?=[89]))|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|u\{(?:10|[\dA-Fa-f])?[\dA-Fa-f]{1,4}\}|([xu])|[\\0bfnrtv]|[^\n\S]|([\w\W]))?/g));
function heretabs(doc){
   var dent, that, ref$;
   dent = 0 / 0;
   while (that = TABS.exec(doc)) {
      dent <= (ref$ = that[0].length - 1) || (dent = ref$);
   }
   return dent;
}
TABS = /\n(?!$)[^\n\S]*/mg;
function detab(str, len){
   if (len) {
      return str.replace(detab[len] || (detab[len] = RegExp('\\n[^\\n\\S]{1,' + len + '}', 'g')), '\n');
   } else {
      return str;
   }
}
unlines = function(it){
   return it.replace(/\n[^\n\S]*/g, '');
};
enlines = function(it){
   return it.replace(/\n/g, '\\n');
};
enslash = function(it){
   return it.replace(/\\/g, '\\\\');
};
reslash = function(it){
   return it.replace(/(\\.)|\//g, (s, s1) => s1 || '\\/');
};
camelize = function(it){
   return it.replace(/-[a-z]/ig, it => it[1].toUpperCase());
};
deheregex = function(it){
   return it.replace(/(^|\s+)#.*|^\s+|\\(?= )|\\?\n+/gm, "");
   // return it.replace(/(\\)?\n\s*|\s+(?:#.*)|\n$/g, function(arg$, bs){
   // 	bs || (bs = '');
   // 	if ('\\' === bs) {
   // 		return '';
   // 	} else {
   // 		return bs;
   // 	}
   // });
};
function lchomp(it){
   return it.slice(1 + it.lastIndexOf('\n', 0));
}
function decode(val, lno){
   if (!isNaN(val)) {
      return [+val];
   }
   val = val.length > 8
      ? 'ng'
      : Function('return ' + val)();
   val.length === 1 || carp('bad string in range', lno);
   return [val.charCodeAt(), true];
}
function uxxxx(it){
   return '"\\u' + ('000' + it.toString(16)).slice(-4) + '"';
}
character = JSON
   ? function(it){
      switch (it) {
      case 0x2028:
      case 0x2029:
         return uxxxx(it);
      default:
         return JSON.stringify(String.fromCharCode(it))
            .replace(/\\u000([0-7])/, '\\$1')
            .replace('\\u00', '\\x');
      }
   } : uxxxx;
function firstPass(tokens){
   var prev, i, token, tag, val, line, column, next, parens, i$, j, ts, ref$;
   prev = ['NEWLINE', '\n', 0];
   i = 0;
   while (token = tokens[++i]) {
      tag = token[0], val = token[1], line = token[2], column = token[3];
      switch (tag) {
      case 'ASSIGN':
         if (LS_KEYWORDS.includes(prev[1]) && tokens[i - 2][0] !== 'DOT') {
            carp("cannot assign to reserved word '" + prev[1] + "'", line);
         }
         break;
      case 'DOT':
         switch (false) {
         case !(prev[0] === ']' && tokens[i - 2][0] === '[' && tokens[i - 3][0] === 'DOT'):
            tokens.splice(i - 2, 3);
            tokens[i - 3][1] = '[]';
            i -= 3;
            break;
         case !(prev[0] === '}' && tokens[i - 2][0] === '{' && tokens[i - 3][0] === 'DOT'):
            tokens.splice(i - 2, 3);
            tokens[i - 3][1] = '{}';
            i -= 3;
            break;
         case !(val === '.' && token.spaced && prev.spaced):
            tokens[i] = ['COMPOSE', '<<', line, column];
            break;
         default:
            next = tokens[i + 1];
            if (prev[0] === '(' && next[0] === ')') {
               tokens[i][0] = 'BIOP';
            } else if (prev[0] === '(') {
               tokens.splice(i, 0, ['PARAM(', '(', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column], ['ID', 'it', line, column]);
            } else if (next[0] === ')') {
               tokens.splice(i + 1, 0, ['[', '[', line, column], ['ID', 'it', line, column], [']', ']', line, column]);
               parens = 1;
               LOOP: for (i$ = i + 1; i$ >= 0; --i$) {
                  j = i$;
                  switch (tokens[j][0]) {
                  case ')':
                     ++parens;
                     break;
                  case '(':
                     if (--parens === 0) {
                        tokens.splice(j + 1, 0, ['PARAM(', '(', line, column], ['ID', 'it', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column]);
                        break LOOP;
                     }
                  }
               }
            }
         }
         break;
      case 'CREMENT':
         if (!(val === '++' && (next = tokens[i + 1]))) {
            break;
         }
         ts = ['ID', 'LITERAL', 'STRNUM'];
         if (prev.spaced && token.spaced || !(prev.spaced || token.spaced) && ts.includes(prev[0]) && ts.includes(next[0])) {
            tokens[i][0] = 'CONCAT';
         }
         if (prev[0] === '(' && next[0] === ')' || prev[0] === '(' && token.spaced || next[0] === ')' && prev.spaced) {
            tokens[i][0] = 'BIOP';
         }
         break;
      case 'ID':
         if (val !== 'async') {
            break;
         }
         next = tokens[i + 1];
         if ((ref$ = next[0]) === 'FUNCTION' || ref$ === 'GENERATOR') {
            token[0] = 'ASYNC';
         }
      }
      prev = token;
      continue;
   }
}
function rewriteBlockless(tokens){
   var i, token, tag;
   i = -1;
   while (token = tokens[++i]) {
      tag = token[0];
      if (tag === 'IF' || tag === 'CLASS' || tag === 'CATCH') {
         detectEnd(tokens, i + 1, ok, go);
      }
   }
   function ok(it){
      return it[0] === 'NEWLINE' || it[0] === 'INDENT';
   }
   function go(it, i){
      var lno, cno;
      if (tag === 'IF') {
         if (it[0] !== 'INDENT' || !it[1] && !it.then || BLOCK_USERS.includes(tokens[i - 1][0])) {
            token[0] = 'POST_IF';
         }
      } else if (it[0] !== 'INDENT') {
         tokens.splice(i, 0, ['INDENT', 0, lno = tokens[i - 1][2], cno = tokens[i - 1][3]], ['DEDENT', 0, lno, cno]);
      }
   }
}
function addImplicitIndentation(tokens){
   var i, token, tag, next, indent, dedent, ref$, ref1$, idx;
   i = 0;
   while (token = tokens[++i]) {
      tag = token[0];
      if (tag !== '->' && tag !== 'THEN' && tag !== 'ELSE' && tag !== 'DEFAULT' && tag !== 'TRY' && tag !== 'FINALLY' && tag !== 'DECL') {
         continue;
      }
      switch (next = tokens[i + 1][0]) {
      case 'IF':
         if (tag === 'ELSE') {
            continue;
         }
         break;
      case 'INDENT':
      case 'THEN':
         if (tag === 'THEN') {
            tokens.splice(i--, 1);
         }
         continue;
      }
      indent = ['INDENT', 0, token[2], token[3]];
      dedent = ['DEDENT', 0];
      if (tag === 'THEN') {
         (tokens[i] = indent).then = true;
      } else {
         tokens.splice(++i, 0, indent);
      }
      switch (false) {
      case tag !== 'DECL':
         break;
      case next !== 'DOT' && next !== '?' && next !== ',' && next !== 'PIPE' && next !== 'BACKPIPE':
         --i;
         // fallthrough
      case !((next === 'ID' || next === 'STRNUM' || next === 'LITERAL') && ',' === ((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8)):
         go(0, i += 2);
         ++i;
         continue;
      case !((next === '(' || next === '[' || next === '{') && ',' === ((ref1$ = tokens[idx = 1 + indexOfPair(tokens, i + 1)]) != null ? ref1$[0] : void 8)):
         go(0, idx);
         ++i;
         continue;
      }
      detectEnd(tokens, i + 1, ok, go);
   }
   function ok(token, i){
      var t0, t;
      t0 = token[0];
      t = tag;
      if (tag === t0 || tag === 'THEN' && t0 === 'SWITCH') {
         tag = '';
      }
      switch (t0) {
      case 'NEWLINE':
         return token[1] !== ';';
      case 'DOT':
      case '?':
      case ',':
      case 'PIPE':
      case 'BACKPIPE':
         return tokens[i - 1].eol;
      case 'ELSE':
         return t === 'THEN';
      case 'CATCH':
         return t === 'TRY';
      case 'FINALLY':
         return t === 'TRY' || t === 'CATCH' || t === 'THEN';
      case 'CASE':
      case 'DEFAULT':
         return t === 'CASE' || t === 'THEN';
      }
   }
   function go(arg$, i){
      var prev;
      prev = tokens[i - 1];
      tokens.splice(prev[0] === ',' ? i - 1 : i, 0, (dedent[2] = prev[2], dedent[3] = prev[3], dedent));
   }
}
function addImplicitParentheses(tokens){
   var i, brackets, token, endi, ref$, tpair, tag, prev, ref1$, skipBlock, seenSwitch;
   i = 0;
   brackets = [];
   while (token = tokens[++i]) {
      if (token[1] === 'do' && tokens[i + 1][0] === 'INDENT') {
         endi = indexOfPair(tokens, i + 1);
         if (tokens[endi + 1][0] === 'NEWLINE' && ((ref$ = tokens[endi + 2]) != null ? ref$[0] : void 8) === 'WHILE') {
            token[0] = 'DO';
            tokens[endi + 2].done = true;
            tokens.splice(endi + 1, 1);
         } else {
            (token = tokens[1 + i])[0] = '(';
            (tpair = tokens[endi])[0] = ')';
            token.doblock = true;
            tokens.splice(i, 1);
         }
      }
      tag = token[0];
      prev = tokens[i - 1];
      tag === '[' && brackets.push(prev[0] === 'DOT');
      if (prev[0] === ']') {
         if (brackets.pop()) {
            prev.index = true;
         } else {
            continue;
         }
      }
      if (!(((ref1$ = prev[0]) === 'FUNCTION' || ref1$ === 'GENERATOR' || ref1$ === 'LET' || ref1$ === 'WHERE') || prev.spaced && able(tokens, i, true))) {
         continue;
      }
      if (token.doblock) {
         token[0] = 'CALL(';
         tpair[0] = ')CALL';
         continue;
      }
      if (!exp(token)) {
         continue;
      }
      if (tag === 'CREMENT') {
         if (token.spaced || !CHAIN.includes((ref1$ = tokens[i + 1]) != null ? ref1$[0] : void 8)) {
            continue;
         }
      }
      skipBlock = seenSwitch = false;
      tokens.splice(i++, 0, ['CALL(', '', token[2], token[3]]);
      detectEnd(tokens, i, ok, go);
   }
   function exp(token){
      var tag;
      tag = token[0];
      return ARG.includes(tag) || !token.spaced && (tag === '+-' || tag === 'CLONE');
   }
   function ok(token, i){
      var tag, ref$, pre;
      tag = token[0];
      if (tag === 'POST_IF' || tag === 'PIPE' || tag === 'BACKPIPE') {
         return true;
      }
      if (!skipBlock) {
         if (token.alias && ((ref$ = token[1]) === '&&' || ref$ === '||' || ref$ === 'xor') || (tag === 'TO' || tag === 'BY' || tag === 'IMPLEMENTS')) {
            return true;
         }
      }
      pre = tokens[i - 1];
      switch (tag) {
      case 'NEWLINE':
         return pre[0] !== ',';
      case 'DOT':
      case '?':
         return !skipBlock && (pre.spaced || pre[0] === 'DEDENT');
      case 'SWITCH':
         seenSwitch = true;
         // fallthrough
      case 'IF':
      case 'CLASS':
      case 'FUNCTION':
      case 'GENERATOR':
      case 'LET':
      case 'WITH':
      case 'CATCH':
         skipBlock = true;
         break;
      case 'CASE':
         if (seenSwitch) {
            skipBlock = true;
         } else {
            return true;
         }
         break;
      case 'INDENT':
         if (skipBlock) {
            return skipBlock = false;
         }
         return !BLOCK_USERS.includes(pre[0]);
      case 'WHILE':
         if (token.done) {
            return false;
         }
         // fallthrough
      case 'FOR':
         skipBlock = true;
         return able(tokens, i) || pre[0] === 'CREMENT' || pre[0] === '...' && pre.spaced;
      }
      return false;
   }
   function go(token, i){
      tokens.splice(i, 0, [')CALL', '', tokens[i - 1][2], tokens[i - 1][3]]);
   }
}
function addImplicitBraces(tokens){
   var stack, i, token, tag, start, paren, index, pre, ref$, ref1$, inline;
   stack = [];
   i = 0;
   while (token = tokens[++i]) {
      if (':' !== (tag = token[0])) {
         switch (false) {
         case !CLOSERS.includes(tag):
            start = stack.pop();
            break;
         case !OPENERS.includes(tag):
            if (tag === 'INDENT' && tokens[i - 1][0] === '{') {
               tag = '{';
            }
            stack.push([tag, i]);
         }
         continue;
      }
      paren = tokens[i - 1][0] === ')';
      index = paren
         ? start[1]
         : i - 1;
      pre = tokens[index - 1];
      if (!(((ref1$ = pre[0]) === ':' || ref1$ === 'ASSIGN' || ref1$ === 'IMPORT') || ((ref$ = stack[stack.length - 1]) != null ? ref$[0] : void 8) !== '{')) {
         continue;
      }
      stack.push(['{']);
      inline = !pre.doblock && ((ref1$ = pre[0]) !== 'NEWLINE' && ref1$ !== 'INDENT');
      while (((ref1$ = tokens[index - 2]) != null ? ref1$[0] : void 8) === 'COMMENT') {
         index -= 2;
      }
      tokens.splice(index, 0, ['{', '{', tokens[index][2], tokens[index][3]]);
      detectEnd(tokens, ++i + 1, ok, go);
   }
   function ok(token, i){
      var tag, ref$, t1, ref1$;
      switch (tag = token[0]) {
      case ',':
         break;
      case 'NEWLINE':
         if (inline) {
            return true;
         }
         break;
      case 'DEDENT':
         return true;
      case 'POST_IF':
      case 'FOR':
      case 'WHILE':
         return inline;
      default:
         return false;
      }
      t1 = (ref$ = tokens[i + 1]) != null ? ref$[0] : void 8;
      return t1 !== (tag === ',' ? 'NEWLINE' : 'COMMENT') && ':' !== ((ref1$ = tokens[t1 === '('
         ? 1 + indexOfPair(tokens, i + 1)
         : i + 2]) != null ? ref1$[0] : void 8);
   }
   function go(token, i){
      tokens.splice(i, 0, ['}', '', token[2], token[3]]);
   }
}
function expandLiterals(tokens){
   var i, fromNum, token, sig, ref$, ref1$, ref2$, lno, cno, ref3$, ref4$, char, toNum, tochar, byNum, byp, ref5$, ts, enc, add, i$, n, ref6$, ref7$, len$, word, that, isLoop, guessLen;
   i = 0;
   while (token = tokens[++i]) {
      switch (token[0]) {
      case 'STRNUM':
         if (~'-+'.indexOf(sig = token[1][0])) {
            token[1] = token[1].substring(1);
            tokens.splice(i++, 0, ['+-', sig, token[2], token[3]]);
         }
         if (token.callable) {
            continue;
         }
         break;
      case 'TO':
      case 'TIL':
         if (!(tokens[i - 1][0] === '[' && ((tokens[i + 2][0] === ']' && (((ref2$ = tokens[i + 1][1].charAt(0)) === '\'' || ref2$ === '"'))) || (tokens[i + 2][0] === 'BY' && ((ref$ = tokens[i + 3]) != null ? ref$[0] : void 8) === 'STRNUM' && ((ref1$ = tokens[i + 4]) != null ? ref1$[0] : void 8) === ']')))) {
            continue;
         }
         if (tokens[i + 2][0] === 'BY') {
            tokens[i + 2][0] = 'RANGE_BY';
         }
         token.op = token[1];
         fromNum = 0;
         // fallthrough
      case 'RANGE':
         isLoop = true;
         lno = token[2];
         cno = token[3];
         if (fromNum != null || (
            tokens[i - 1][0] === '[' && tokens[i + 1][0] === 'STRNUM' && (
               (tokens[i + 2][0] === ']' && (((ref4$ = tokens[i + 1][1].charAt(0)) === "'" || ref4$ === '"'))) || (
                  tokens[i + 2][0] === 'RANGE_BY' &&
                  ((ref2$ = tokens[i + 3]) != null ? ref2$[0] : void 8) === 'STRNUM' &&
                  ((ref3$ = tokens[i + 4]) != null ? ref3$[0] : void 8) === ']'
               )
            )
         )) {
            isLoop = false;
            if (fromNum == null) {
               ref4$ = decode(token[1], lno), fromNum = ref4$[0], char = ref4$[1];
            }
            ref4$ = decode(tokens[i + 1][1], lno), toNum = ref4$[0], tochar = ref4$[1];
            if (toNum == null || char ^ tochar) {
               carp('bad "to" in range', lno);
            }
            byNum = 1;
            if (byp = ((ref4$ = tokens[i + 2]) != null ? ref4$[0] : void 8) === 'RANGE_BY') {
               if (!(byNum = +((ref5$ = tokens[i + 3]) != null ? ref5$[1] : void 8))) {
                  carp('bad "by" in range', tokens[i + 2][2]);
               }
            } else if (fromNum > toNum) {
               byNum = -1;
            }
            guessLen = Math.abs(toNum - fromNum) + 1;
            if (guessLen > 32) {
               isLoop = true;
            } else {
               ts = [];
               enc = char ? character : String;
               add = fn$;
               if (token.op === 'to') {
                  for (i$ = fromNum; byNum < 0 ? i$ >= toNum : i$ <= toNum; i$ += byNum) {
                     n = i$;
                     add();
                  }
               } else {
                  for (i$ = fromNum; byNum < 0 ? i$ > toNum : i$ < toNum; i$ += byNum) {
                     n = i$;
                     add();
                  }
               }
               ts.pop() || carp('empty range', lno);
               tokens.splice.apply(tokens, [i, 2 + 2 * byp].concat(arrayFrom$(ts)));
               i += ts.length - 1;
            }
         }
         if (isLoop) {
            token[0] = 'STRNUM';
            if (((ref6$ = tokens[i + 2]) && ref6$[0]) === 'RANGE_BY') {
               tokens.splice(i + 2, 1, ['BY', 'by', lno, cno]);
            }
            tokens.splice(i + 1, 0, ['TO', token.op, lno, cno]);
         }
         fromNum = null;
         break;
      case 'WORDS':
         ts = [['[', '[', lno = token[2], cno = token[3]]];
         for (i$ = 0, len$ = (ref7$ = token[1].match(/\S+/g) || '').length; i$ < len$; ++i$) {
            word = ref7$[i$];
            ts.push(['STRNUM', string("'", word, lno), lno, cno], [',', ',', lno, cno]);
         }
         tokens.splice.apply(tokens, [i, 1].concat(arrayFrom$(ts), [[']', ']', lno, cno]]));
         i += ts.length;
         break;
      case 'INDENT':
         if (that = tokens[i - 1]) {
            if (that[1] === 'new') {
               tokens.splice(i++, 0, ['PARAM(', '', token[2], token[3]], [')PARAM', '', token[2], token[3]], ['->', '', token[2], token[3]]);
            } else if ((ref7$ = that[0]) === 'FUNCTION' || ref7$ === 'GENERATOR' || ref7$ === 'LET') {
               tokens.splice(i, 0, ['CALL(', '', token[2], token[3]], [')CALL', '', token[2], token[3]]);
               i += 2;
            }
         }
         continue;
      case 'LITERAL':
      case '}':
         break;
      case ')':
      case ')CALL':
         if (token[1]) {
            continue;
         }
         break;
      case ']':
         if (token.index) {
            continue;
         }
         break;
      case 'CREMENT':
         if (!able(tokens, i)) {
            continue;
         }
         break;
      case 'BIOP':
         if (!token.spaced && ((ref7$ = token[1]) === '+' || ref7$ === '-') && tokens[i + 1][0] !== ')') {
            tokens[i][0] = '+-';
         }
         continue;
      default:
         continue;
      }
      if (token.spaced && ARG.includes(tokens[i + 1][0])) {
         tokens.splice(++i, 0, [',', ',', token[2], token[3]]);
      }
   }
   function fn$(){
      if (65536 < ts.push(['STRNUM', enc(n), lno, cno], [',', ',', lno, cno])) {
         carp('range limit exceeded', lno);
      }
   }
}
function detectEnd(tokens, i, ok, go){
   var levels, token, tag;
   levels = 0;
   for (; token = tokens[i]; ++i) {
      if (!levels && ok(token, i)) {
         return go(token, i);
      }
      tag = token[0];
      if (0 > (levels += OPENERS.includes(tag) || -CLOSERS.includes(tag))) {
         return go(token, i);
      }
   }
}
function indexOfPair(tokens, i){
   var level, end, start, that;
   level = 1;
   end = INVERSES[start = tokens[i][0]];
   while (that = tokens[++i]) {
      switch (that[0]) {
      case start:
         ++level;
         break;
      case end:
         if (!--level) {
            return i;
         }
      }
   }
   return -1;
}
KEYWORDS_SHARED = ['true', 'false', 'null', 'this', 'void', 'super', 'return', 'throw', 'break', 'continue', 'if', 'else', 'for', 'while', 'switch', 'case', 'default', 'try', 'catch', 'finally', 'function', 'class', 'extends', 'implements', 'new', 'do', 'delete', 'typeof', 'in', 'instanceof', 'let', 'with', 'var', 'const', 'debugger', 'yield'];
KEYWORDS_UNUSED = ['enum', 'interface', 'package', 'private', 'protected', 'public', 'static'];
JS_KEYWORDS = KEYWORDS_SHARED.concat(KEYWORDS_UNUSED);
LS_KEYWORDS = ['xor', 'match', 'where'];
ID = /((?!\s)[a-z_$\xAA-\uFFDC](?:[\w$\xAA-\uFFDC]|-[a-z])*)([^\n\S]*:(?![:=]))?|/ig;
ID_INTERPOLATE = /((?!\s)(?:@?[a-z_$\xAA-\uFFDC](?:[\w$\xAA-\uFFDC]|-[a-z])*)|@\d*)([^\n\S]*:(?![:=]))?|/ig;
SYMBOL = /[-\/^]=|[/%+:*]{1,2}=|\|>=|\.(?:[&\|\^]|<<|>>>?)\.=?|\.{1,3}|\^\^|\*?<(?:--?|~~?)!?|!?(?:--?|~~?)>>?\*?|([-+&|:])\1|\/\/|%%|&|\([^\n\S]*\)|[!=]==?|!?\~=|@@?|<\[(?:[\s\S]*?\]>)?|<<<<?|<\||[<>]==|<<=|>>=|<<|>>|[<>]\??=?|\|>|\||=>|\*\*|\^|`|[^\s#]?/g;
SPACE = /[^\n\S]*(?:#.*)?/g;
MULTIDENT = /(?:\s*#.*)*(?:\n([^\n\S]*))*/g;
SIMPLESTR = /'[^\\']*(?:\\[\s\S][^\\']*)*'|/g;
JSTOKEN = /``[^\\`]*(?:\\[\s\S][^\\`]*)*``|/g;
BSTOKEN = RegExp('\\\\(?:(\\S[^\\s,;)}\\]]*)|(?:' + SPACE.source + '\\n?)*)', 'g');
NUMBER = /0x[\dA-Fa-f][\dA-Fa-f_]*n?|(\d*)~([\dA-Za-z]\w*)|\d[\d_]*n|((\d[\d_]*)(\.\d[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)[$\w]*|/g;
NUMBER_OMIT = /_+/g;
REGEX = /\/([^[\/\n\\]*(?:(?:\\.|\[[^\]\n\\]*(?:\\.[^\]\n\\]*)*\])[^[\/\n\\]*)*)\/([dgimsuy]{1,7}|\$?)|/g;
HEREGEX_OMIT = /\s+(?:#.*)?/g;
LASTDENT = /\n[^\n\S]*$/;
INLINEDENT = /[^\n\S]*[^#\s]?/g;
NONASCII = /[\x80-\uFFFF]/;
OPENERS = ['(', '[', '{', 'CALL(', 'PARAM(', 'INDENT'];
CLOSERS = [')', ']', '}', ')CALL', ')PARAM', 'DEDENT'];
INVERSES = import$((function(){
   var i$, ref$, len$, resultObj$ = {};
   for (i$ = 0, len$ = (ref$ = OPENERS).length; i$ < len$; ++i$) {
      i = i$;
      o = ref$[i$];
      resultObj$[o] = CLOSERS[i];
   }
   return resultObj$;
}()), (function(){
   var i$, ref$, len$, resultObj$ = {};
   for (i$ = 0, len$ = (ref$ = CLOSERS).length; i$ < len$; ++i$) {
      i = i$;
      c = ref$[i$];
      resultObj$[c] = OPENERS[i];
   }
   return resultObj$;
}()));
CHAIN = ['(', '{', '[', 'ID', 'STRNUM', 'LITERAL', 'LET', 'WITH', 'WORDS'];
ARG = CHAIN.concat(['...', 'UNARY', 'YIELD', 'CREMENT', 'PARAM(', 'FUNCTION', 'GENERATOR', 'IF', 'SWITCH', 'TRY', 'CLASS', 'RANGE', 'LABEL', 'DECL', 'DO', 'BIOPBP']);
BLOCK_USERS = [',', ':', '->', 'ELSE', 'ASSIGN', 'IMPORT', 'UNARY', 'DEFAULT', 'TRY', 'FINALLY', 'HURL', 'DECL', 'DO', 'LET', 'FUNCTION', 'GENERATOR', '...'];
function clone$(it){
   function fun(){} fun.prototype = it;
   return new fun;
}
function import$(obj, src){
   var own = {}.hasOwnProperty;
   for (var key in src) if (own.call(src, key)) obj[key] = src[key];
   return obj;
}
},{}],4:[function(require,module,exports){
(function (global){
// Generated by LiveScript 1.6.1
module.exports = function(LiveScript){
   var fs, path, events;
   fs = require('fs');
   path = require('path');
   events = require('events');
   LiveScript.run = function(code, options, arg$){
      var filename, ref, js, context, main, dirname;
      if (options != null) {
         filename = options.filename;
      }
      ref$ = arg$ != null
         ? arg$
         : {}, js = ref$.js, context = ref$.context;
      main = require.main;
      dirname = filename
         ? path.dirname(fs.realpathSync(filename = path.resolve(filename)))
         : filename = '.';
      main.paths = main.constructor._nodeModulePaths(dirname);
      main.filename = filename;
      if (!js) {
         code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = false, ref$));
         if (code.code) {
            code = code.code;
         }
      }
      if (context) {
         global.__runContext = context;
         code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
      }
      filename += '(js)';
      try {
         return main._compile(code, filename);
      } catch (e) {
         throw hackTrace(e, code, filename);
      }
   };
   if (isNode) {
      Object.assign(LiveScript, require('events').EventEmitter.prototype);
   }
   require.extensions['.ls'] = function(module, filename){
      var file, js;
      file = fs.readFileSync(filename, 'utf8');
      js = '.json.ls' === filename.substr(-8)
         ? 'module.exports = ' + LiveScript.compile(file, {
            filename: filename,
            json: true
         })
         : LiveScript.compile(file, {
            filename: filename,
            bare: false,
            map: "embedded"
         }).code;
      try {
         return module._compile(js, filename);
      } catch (e) {
         throw hackTrace(e, js, filename);
      }
   };
};
function hackTrace(error, js, filename){
   var stack, traces, i$, len$, i, trace, index, lno, end, length, lines, j$, ref$, n;
   if (error != null) {
      stack = error.stack;
   }
   if (!stack) {
      return error;
   }
   traces = stack.split('\n');
   if (!(traces.length > 1)) {
      return error;
   }
   for (i$ = 0, len$ = traces.length; i$ < len$; ++i$) {
      i = i$;
      trace = traces[i$];
      if (0 > (index = trace.indexOf("(" + filename + ":"))) {
         continue;
      }
      lno = (/:(\d+):/.exec(trace.slice(index + filename.length)) || '')[1];
      if (!(lno = +lno)) {
         continue;
      }
      end = lno + 4;
      length = ('' + end).length;
      lines || (lines = js.split('\n'));
      for (j$ = 1 > (ref$ = lno - 4) ? 1 : ref$; j$ <= end; ++j$) {
         n = j$;
         traces[i] += "\n" + ('    ' + n).slice(-length) + "" + '|+'.charAt(n === lno) + " " + [lines[n - 1]];
      }
   }
   return error.stack = traces.join('\n'), error;
}
function import$(obj, src){
   var own = {}.hasOwnProperty;
   for (var key in src) if (own.call(src, key)) obj[key] = src[key];
   return obj;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (){
/* parser generated by jison 0.4.18 */
/*
   Returns a Parser object of the following structure:

   Parser: {
      yy: {}
   }

   Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),

      lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),

            options: {
                  ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                  flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                  backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },

            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
      }
   }


   token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
   }


   the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
   }
   while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
   }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,60],$V1=[1,31],$V2=[1,34],$V3=[1,35],$V4=[1,36],$V5=[1,37],$V6=[1,38],$V7=[1,8],$V8=[1,15],$V9=[1,14],$Va=[1,39],$Vb=[1,41],$Vc=[1,29],$Vd=[1,6],$Ve=[1,10],$Vf=[1,9],$Vg=[1,11],$Vh=[1,16],$Vi=[1,17],$Vj=[1,18],$Vk=[1,19],$Vl=[1,20],$Vm=[1,21],$Vn=[1,22],$Vo=[1,23],$Vp=[1,44],$Vq=[1,24],$Vr=[1,25],$Vs=[1,26],$Vt=[1,27],$Vu=[1,28],$Vv=[1,30],$Vw=[1,43],$Vx=[1,45],$Vy=[1,20,25,47],$Vz=[20,47],$VA=[2,64],$VB=[1,49],$VC=[1,50],$VD=[1,51],$VE=[1,52],$VF=[1,53],$VG=[1,54],$VH=[1,55],$VI=[1,56],$VJ=[1,57],$VK=[1,58],$VL=[1,59],$VM=[1,60],$VN=[1,61],$VO=[1,62],$VP=[1,63],$VQ=[30,46,47,48],$VR=[2,50],$VS=[1,68],$VT=[1,67],$VU=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102,105],$VV=[2,75],$VW=[1,77],$VX=[1,78],$VY=[1,73],$VZ=[1,79],$V_=[1,71],$V$=[1,72],$V01=[1,74],$V11=[1,75],$V21=[1,83],$V31=[1,87],$V41=[1,86],$V51=[1,84],$V61=[1,95],$V71=[1,109],$V81=[48,105],$V91=[2,201],$Va1=[1,113],$Vb1=[2,1],$Vc1=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103,104,105],$Vd1=[2,2],$Ve1=[19,46,47,48],$Vf1=[1,120],$Vg1=[1,119],$Vh1=[22,46,47],$Vi1=[2,156],$Vj1=[1,130],$Vk1=[1,125],$Vl1=[1,128],$Vm1=[1,129],$Vn1=[25,47],$Vo1=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,99,102,103,104,105],$Vp1=[30,47,48],$Vq1=[2,58],$Vr1=[1,169],$Vs1=[12,19,20,30,46,47,48],$Vt1=[2,55],$Vu1=[2,71],$Vv1=[12,46,47,48],$Vw1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,66,67,68,70,71,72,79,81,82,102,105],$Vx1=[20,46,47,48],$Vy1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,79,81,82,102,105],$Vz1=[1,206],$VA1=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,102,105],$VB1=[1,209],$VC1=[46,48,82],$VD1=[2,203],$VE1=[1,215],$VF1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,82,102,105],$VG1=[19,47,48],$VH1=[1,227],$VI1=[20,22,46,47],$VJ1=[9,13,20,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],$VK1=[2,165],$VL1=[1,251],$VM1=[19,20,22,47,48,81,102],$VN1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,62,63,66,67,68,70,71,72,79,81,82,102,105],$VO1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,63,67,71,72,79,81,82,102,105],$VP1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,62,63,67,70,71,72,79,81,82,102,105],$VQ1=[1,264],$VR1=[1,265],$VS1=[2,59],$VT1=[12,47,48],$VU1=[20,47,48],$VV1=[1,302],$VW1=[1,303],$VX1=[1,311],$VY1=[4,7,14,16,21,23,29,31,32,38,41,44,48,49,59,60,61,75,76,77,78,80,81,83,84,85,90,93,97,102],$VZ1=[1,336],$V_1=[1,337],$V$1=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,88,89,102,105],$V02=[2,46],$V12=[1,369];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"Chain":3,"ID":4,"KeyLike":5,"List":6,"LITERAL":7,"Index":8,"CALL(":9,"ArgList":10,"OptComma":11,")CALL":12,"?":13,"LET":14,"Block":15,"[":16,"Expression":17,"LoopHeads":18,"]":19,"DEDENT":20,"{":21,"}":22,"(":23,"BIOP":24,")":25,"BIOPR":26,"BIOPBP":27,"BIOPP":28,"PARAM(":29,")PARAM":30,"UNARY":31,"CREMENT":32,"BACKTICK":33,"TO":34,"BY":35,"FROM":36,"DOT":37,"WITH":38,"LoopHead":39,"Else":40,"STRNUM":41,"Parenthetical":42,"Properties":43,"LABEL":44,"Arg":45,",":46,"NEWLINE":47,"INDENT":48,"...":49,"Lines":50,"Line":51,"<-":52,"COMMENT":53,"REQUIRE":54,"SplatChain":55,"CLONEPORT":56,"ASSIGN":57,"IMPORT":58,"+-":59,"CLONE":60,"YIELD":61,"COMPARE":62,"LOGIC":63,"MATH":64,"POWER":65,"SHIFT":66,"BITWISE":67,"CONCAT":68,"COMPOSE":69,"RELATION":70,"PIPE":71,"BACKPIPE":72,"!?":73,"->":74,"FUNCTION":75,"GENERATOR":76,"ASYNC":77,"IF":78,"POST_IF":79,"DO":80,"WHILE":81,"CASE":82,"HURL":83,"JUMP":84,"SWITCH":85,"Exprs":86,"Cases":87,"DEFAULT":88,"ELSE":89,"TRY":90,"CATCH":91,"FINALLY":92,"CLASS":93,"OptExtends":94,"OptImplements":95,"EXTENDS":96,"DECL":97,"KeyColon":98,":":99,"Property":100,"Body":101,"FOR":102,"IN":103,"OF":104,"IMPLEMENTS":105,"Root":106,"$accept":0,"$end":1},
terminals_: {2:"error",4:"ID",7:"LITERAL",9:"CALL(",12:")CALL",13:"?",14:"LET",16:"[",19:"]",20:"DEDENT",21:"{",22:"}",23:"(",24:"BIOP",25:")",26:"BIOPR",27:"BIOPBP",28:"BIOPP",29:"PARAM(",30:")PARAM",31:"UNARY",32:"CREMENT",33:"BACKTICK",34:"TO",35:"BY",36:"FROM",37:"DOT",38:"WITH",41:"STRNUM",44:"LABEL",46:",",47:"NEWLINE",48:"INDENT",49:"...",52:"<-",53:"COMMENT",54:"REQUIRE",56:"CLONEPORT",57:"ASSIGN",58:"IMPORT",59:"+-",60:"CLONE",61:"YIELD",62:"COMPARE",63:"LOGIC",64:"MATH",65:"POWER",66:"SHIFT",67:"BITWISE",68:"CONCAT",69:"COMPOSE",70:"RELATION",71:"PIPE",72:"BACKPIPE",73:"!?",74:"->",75:"FUNCTION",76:"GENERATOR",77:"ASYNC",78:"IF",79:"POST_IF",80:"DO",81:"WHILE",82:"CASE",83:"HURL",84:"JUMP",85:"SWITCH",88:"DEFAULT",89:"ELSE",90:"TRY",91:"CATCH",92:"FINALLY",93:"CLASS",96:"EXTENDS",97:"DECL",99:":",102:"FOR",103:"IN",104:"OF",105:"IMPLEMENTS"},
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,2],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[3,3],[3,3],[5,1],[5,1],[8,2],[8,2],[8,2],[6,4],[6,4],[6,5],[6,5],[10,0],[10,1],[10,3],[10,4],[10,6],[45,1],[45,2],[45,1],[11,0],[11,1],[50,0],[50,1],[50,3],[50,2],[51,1],[51,2],[51,6],[51,1],[51,1],[51,2],[15,3],[55,2],[17,3],[17,3],[17,5],[17,1],[17,3],[17,3],[17,6],[17,3],[17,6],[17,2],[17,2],[17,3],[17,2],[17,3],[17,3],[17,3],[17,4],[17,4],[17,4],[17,2],[17,2],[17,2],[17,3],[17,3],[17,3],[17,6],[17,5],[17,1],[17,2],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,2],[17,6],[17,6],[17,6],[17,7],[17,7],[17,4],[17,3],[17,4],[17,6],[17,2],[17,5],[17,1],[17,1],[17,2],[17,3],[17,5],[17,5],[17,2],[17,4],[17,4],[17,2],[17,2],[17,4],[17,6],[17,5],[17,7],[17,4],[17,5],[17,4],[17,3],[17,2],[17,2],[17,5],[86,1],[86,3],[98,2],[98,2],[100,2],[100,5],[100,1],[100,2],[100,1],[43,0],[43,1],[43,3],[43,4],[43,4],[42,3],[101,1],[101,1],[101,3],[40,0],[40,2],[40,5],[39,4],[39,6],[39,6],[39,8],[39,2],[39,4],[39,4],[39,6],[39,4],[39,6],[39,6],[39,8],[39,6],[39,5],[39,8],[39,7],[39,8],[39,7],[39,10],[39,9],[39,10],[39,9],[39,2],[39,4],[39,4],[39,6],[18,1],[18,2],[18,3],[18,3],[87,3],[87,4],[94,2],[94,0],[95,2],[95,0],[106,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 5:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].add($$[$0]));
break;
case 6:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 7:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 8:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
break;
case 9:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 10:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 11:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 12: case 18: case 20:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 13:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 14:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 15:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
            ? yy.Binary($$[$0-1].slice(1)).invertIt()
            : yy.Binary($$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],'!' === $$[$0-2].charAt(0)
            ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
            : yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 17:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
            ? yy.Binary($$[$0-1].slice(1), $$[$0-2]).invertIt()
            : yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 19:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 22: case 23:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Unary($$[$0-1]))));
break;
case 24:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 25:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 26:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 27:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
            from: $$[$0-3],
            op: $$[$0-2],
            to: $$[$0-1],
            inComprehension: true
         }))));
break;
case 28:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], new yy.For({
            from: $$[$0-5],
            op: $$[$0-4],
            to: $$[$0-3],
            step: $$[$0-1],
            inComprehension: true
         }))));
break;
case 29:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({
            from: $$[$0-3],
            op: $$[$0-2],
            to: $$[$0-1],
            inComprehension: true
         }))));
break;
case 30:
this.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0-1], new yy.For({
            from: $$[$0-5],
            op: $$[$0-4],
            to: $$[$0-3],
            step: $$[$0-1],
            inComprehension: true
         }))));
break;
case 31:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
            from: yy.Chain(yy.Literal(0)),
            op: $$[$0-2],
            to: $$[$0-1],
            inComprehension: true
         }))));
break;
case 32:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({
            from: yy.Chain(yy.Literal(0)),
            op: $$[$0-4],
            to: $$[$0-3],
            step: $$[$0-1],
            inComprehension: true
         }))));
break;
case 33:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.StepSlice({
            op: $$[$0-4],
            target: $$[$0-8],
            from: $$[$0-5],
            to: $$[$0-3],
            step: $$[$0-1]
         }))));
break;
case 34:
this.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-7],_$[$0], new yy.StepSlice({
            op: $$[$0-4],
            target: $$[$0-7],
            from: yy.Literal(0),
            to: $$[$0-3],
            step: $$[$0-1]
         }))));
break;
case 35:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.Slice({
            type: $$[$0-2],
            target: $$[$0-6],
            from: $$[$0-3],
            to: $$[$0-1]
         }))));
break;
case 36:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({
            type: $$[$0-1],
            target: $$[$0-5],
            from: $$[$0-2]
         }))));
break;
case 37:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({
            type: $$[$0-2],
            target: $$[$0-5],
            to: $$[$0-1]
         }))));
break;
case 38:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
            type: $$[$0-1],
            target: $$[$0-4]
         }))));
break;
case 39:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.Cascade($$[$0-1], $$[$0], 'with'))));
break;
case 40:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain($$[$0-2].addBody($$[$0-1]).addElse($$[$0])));
break;
case 41:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 42: case 55: case 58: case 59: case 63: case 64: case 162: case 163:

break;
case 43:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Index(yy.L(_$[$0],_$[$0],yy.Key($$[$0])), $$[$0-1], true));
break;
case 44: case 45:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Index($$[$0], $$[$0-1], true));
break;
case 46:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 47:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 48:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 49:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 50: case 156:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
case 51: case 147: case 157: case 194:
this.$ = yy.L(_$[$0], _$[$0],[$$[$0]]);
break;
case 52: case 148: case 158: case 196: case 197:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].concat($$[$0]));
break;
case 53: case 159:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 54:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 56:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 57:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 60:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 62: case 164:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
case 65:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));
break;
case 66:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 67: case 155:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 68:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
case 69:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 70:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 71:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 72:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
            prec: 'yy.UNARY'
         })), $$[$0], false));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
            prec: 'yy.UNARY'
         })), $$[$0].unwrap(), false));
break;
case 74:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 75:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 76:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
case 79:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import($$[$0-2], $$[$0], $$[$0-1] === '<<<<'));
break;
case 80:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === '<<<<'));
break;
case 81:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0].unwrap()));
break;
case 82:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1].unwrap(), true));
break;
case 83:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0].unwrap())));
break;
case 84:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1], true));
break;
case 85: case 86: case 87:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0].unwrap(), [$$[$0-2]], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 88: case 89: case 90:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Assign(yy.Splat($$[$0].unwrap()), [$$[$0-3]], yy.L(_$[$0-2],_$[$0-2],yy.Box($$[$0-2]))));
break;
case 91: case 92: case 93:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0]));
break;
case 94: case 95: case 96:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0])));
break;
case 97:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 98:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 99:
this.$ = yy.L(_$[$0], _$[$0],yy.Yield($$[$0]));
break;
case 100:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
case 110:
this.$ = yy.L(_$[$0-2], _$[$0],'!' === $$[$0-1].charAt(0)
            ? yy.Binary($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert()
            : yy.Binary($$[$0-1], $$[$0-2], $$[$0]));
break;
case 111:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe($$[$0], $$[$0-1]));
break;
case 112:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 113:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 114:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1]), />>/.test($$[$0-1])));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true, false).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true, true).named($$[$0-5]));
break;
case 119:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless')).addElse($$[$0]));
break;
case 120:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Try($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 138:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Try($$[$0-3], $$[$0-1], yy.L(_$[$0-2],_$[$0-1], $$[$0])));
break;
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Class({
            title: $$[$0-3].unwrap(),
            sup: $$[$0-2],
            mixins: $$[$0-1],
            body: $$[$0]
         }));
break;
case 142:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Class({
            sup: $$[$0-2],
            mixins: $$[$0-1],
            body: $$[$0]
         }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 149:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Key($$[$0-1]));
break;
case 150:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1]);
break;
case 151:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop($$[$0-1], $$[$0]));
break;
case 152:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Prop($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 153:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(null, $$[$0]));
break;
case 154:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.Splat(), $$[$0]));
break;
case 160:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 161:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Parens($$[$0-1].chomp().unwrap(), false, $$[$0-2] === '"', yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 165: case 201: case 203:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 166: case 200: case 202:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
case 167:
this.$ = yy.L(_$[$0-4], _$[$0],yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless').addElse($$[$0]));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            kind: $$[$0-3],
            item: $$[$0-2].unwrap(),
            index: $$[$0-1],
            source: $$[$0]
         }));
break;
case 169:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            item: $$[$0-4].unwrap(),
            index: $$[$0-3],
            source: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 170:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            item: $$[$0-4].unwrap(),
            index: $$[$0-3],
            source: $$[$0-2],
            step: $$[$0]
         }));
break;
case 171:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            kind: $$[$0-7],
            item: $$[$0-6].unwrap(),
            index: $$[$0-5],
            source: $$[$0-4],
            step: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 172:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.For({
            kind: $$[$0-1],
            source: $$[$0],
            ref: true
         }));
break;
case 173:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            kind: $$[$0-3],
            source: $$[$0-2],
            ref: true,
            guard: $$[$0]
         }));
break;
case 174:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            kind: $$[$0-3],
            source: $$[$0-2],
            ref: true,
            step: $$[$0]
         }));
break;
case 175:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            source: $$[$0-4],
            ref: true,
            step: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 176:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-3],
            index: $$[$0-2],
            source: $$[$0]
         }));
break;
case 177:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-5],
            index: $$[$0-4],
            source: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 178:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-5],
            index: $$[$0-4],
            item: $$[$0-2].unwrap(),
            source: $$[$0]
         }));
break;
case 179:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-7],
            index: $$[$0-6],
            item: $$[$0-4].unwrap(),
            source: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 180:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            index: $$[$0-4],
            from: $$[$0-2],
            op: $$[$0-1],
            to: $$[$0]
         }));
break;
case 181:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.For({
            kind: $$[$0-4],
            from: $$[$0-2],
            op: $$[$0-1],
            to: $$[$0],
            ref: true
         }));
break;
case 182:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            kind: $$[$0-7],
            index: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 183:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.For({
            kind: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            guard: $$[$0],
            ref: true
         }));
break;
case 184:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            kind: $$[$0-7],
            index: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            step: $$[$0]
         }));
break;
case 185:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.For({
            kind: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            step: $$[$0],
            ref: true
         }));
break;
case 186:
this.$ = yy.L(_$[$0-9], _$[$0],new yy.For({
            kind: $$[$0-9],
            index: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            step: $$[$0-2],
            guard: $$[$0]
         }));
break;
case 187:
this.$ = yy.L(_$[$0-8], _$[$0],new yy.For({
            kind: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            step: $$[$0-2],
            guard: $$[$0],
            ref: true
         }));
break;
case 188:
this.$ = yy.L(_$[$0-9], _$[$0],new yy.For({
            kind: $$[$0-9],
            index: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            guard: $$[$0-2],
            step: $$[$0]
         }));
break;
case 189:
this.$ = yy.L(_$[$0-8], _$[$0],new yy.For({
            kind: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            guard: $$[$0-2],
            step: $$[$0],
            ref: true
         }));
break;
case 190:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until'));
break;
case 191:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until').addGuard($$[$0]));
break;
case 192:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', $$[$0]));
break;
case 193:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]));
break;
case 195:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 198:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))]);
break;
case 199:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 204:
return this.$
break;
}
},
table: [o([1,47],$V0,{106:1,101:2,50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{1:[3]},{1:[2,204]},o($Vr,[2,162],{47:$Vx}),o($Vr,[2,163],{47:[1,46]}),o($Vy,[2,61]),o($Vz,$V0,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:47,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy,$VA,{15:48,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,10:64,45:65,17:66,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy,[2,67]),o($Vy,[2,68],{5:32,6:33,39:40,42:42,3:69,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,41:$Vb,81:$Vp,102:$Vw}),{3:70,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($VU,$VV,{8:76,9:$VW,13:$VX,32:$VY,37:$VZ,56:$V_,57:$V$,73:$V01,96:$V11}),{32:[1,81],57:[1,80]},{3:82,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:$V21,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:85,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$V31,49:$V41,55:13,57:$V51,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:89,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:[1,90],55:13,57:[1,88],59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:92,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:[1,93],55:13,57:[1,91],59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o([1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,99],{3:12,55:13,5:32,6:33,39:40,42:42,17:94,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{9:[1,96]},{9:[1,97]},{75:[1,98],76:[1,99]},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:100,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:101,48:$Vd},o([1,12,19,20,22,24,25,26,30,33,34,35,46,47,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,125],{3:12,55:13,5:32,6:33,39:40,42:42,17:102,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:[1,103],49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,[2,126],{4:[1,104]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:107,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,82:$V71,83:$Vq,84:$Vr,85:$Vs,86:105,87:106,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:110,48:$Vd},o($V81,$V91,{5:32,6:33,39:40,42:42,3:111,94:112,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,41:$Vb,81:$Vp,96:$Va1,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:115,16:$V4,17:114,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{48:[1,116]},o([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,104,105],$Vb1),o($Vc1,$Vd1),o($Vc1,[2,3]),o($Vc1,[2,4]),{9:[1,117]},o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:121,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:$Vf1,36:$Vg1,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vh1,$Vi1,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:$Vj1,7:$V2,14:$V3,16:[1,122],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vn1,$V0,{50:3,15:4,51:5,3:12,55:13,5:32,6:33,39:40,42:42,17:133,101:141,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,24:[1,132],26:[1,134],27:[1,135],28:[1,136],29:[1,137],31:[1,138],32:[1,139],33:[1,140],38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:142,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:143,48:$Vd},o($Vo1,[2,41]),o($Vo1,[2,42]),{3:144,4:[1,146],5:32,6:33,7:$V2,14:$V3,16:$V4,17:145,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,36:[1,147],38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:148,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vy,[2,63],{17:7,3:12,55:13,5:32,6:33,39:40,42:42,51:149,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([1,25,47],$V0,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:150,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{20:[1,151],47:$Vx},o($Vy,[2,65]),{3:152,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:153,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,154],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:155,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:156,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:157,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:158,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:159,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:160,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:161,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:162,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:163,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:164,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:165,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:166,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:167,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vp1,$Vq1,{11:168,46:$Vr1}),o($Vs1,[2,51]),o($Vs1,$Vt1,{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vs1,[2,57],{55:13,5:32,6:33,39:40,42:42,17:170,3:171,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:172,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([32,57],$Vu1,{8:76,9:$VW,13:$VX,37:$VZ}),o($Vy,[2,69],{8:76,9:$VW,13:$VX,37:$VZ}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:174,16:$V4,17:173,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:175,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,176],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,82]),o($VU,[2,113]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:177,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,5]),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:178,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,7]),{4:[1,180],5:181,6:182,16:[1,179],21:[1,183],23:[1,184],41:$Vb,42:42},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:185,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,84]),o($VU,[2,81],{8:76,9:$VW,13:$VX,37:$VZ}),{3:186,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:187,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,188],81:$Vp,102:$Vw},o($Vw1,[2,91],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:189,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,190],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:191,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:192,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,193],81:$Vp,102:$Vw},o($Vw1,[2,92],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:194,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:195,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,196],81:$Vp,102:$Vw},o($Vw1,[2,93],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:197,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vy1,[2,100],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),{3:69,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:198,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:199,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{9:[1,200]},{9:[1,201]},{15:202,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{81:[1,203]},o($Vy1,[2,123],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:204,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,[2,127]),{46:$Vz1,82:$V71,87:205},o($VA1,[2,131],{82:$VB1,88:[1,207],89:[1,208]}),o($VU,[2,134]),o($VC1,[2,147],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:210,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,135],{91:[1,211],92:[1,212]}),o($V81,$V91,{8:76,94:213,9:$VW,13:$VX,37:$VZ,96:$Va1}),{48:$VD1,95:214,105:$VE1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:216,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VF1,[2,144],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VU,[2,145]),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:217,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:218,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Ve1,$Vt1,{18:219,39:221,33:$VB,34:[1,220],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,81:$Vp,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:222,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:223,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VG1,$Vq1,{11:224,46:$Vr1}),o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:225,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:$Vf1,36:$Vg1,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([22,47],$Vq1,{11:226,46:$VH1}),o($VI1,[2,157]),o([20,46,47],$Vi1,{3:12,55:13,6:33,39:40,42:42,100:124,98:126,17:127,5:131,43:228,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:229,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,230],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VI1,[2,153],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:231,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VI1,[2,155]),o($VJ1,$Vb1,{99:[1,232]}),o($VJ1,$Vd1,{99:[1,233]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:235,21:$V5,23:$V6,25:[1,234],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vn1,$VA,{15:48,24:[1,236],26:[1,237],33:[1,238],48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:240,21:$V5,23:$V6,25:[1,239],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{9:[1,242],25:[1,241]},{25:[1,243]},o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:244,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:85,21:$V5,23:$V6,25:[1,245],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$V31,49:$V41,55:13,57:$V51,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:82,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,25:[1,246],38:$Va,39:40,41:$Vb,42:42,49:$V21,81:$Vp,102:$Vw},{3:247,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{25:[1,248]},{15:249,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,$VK1,{40:250,89:$VL1}),o([19,20,22,33,35,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102],$VV,{8:76,9:$VW,13:$VX,32:$VY,37:$VZ,56:$V_,57:$V$,73:$V01,96:$V11,103:[1,252]}),o($VM1,[2,172],{33:$VB,35:[1,254],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,253]}),o([9,13,19,20,22,32,33,35,37,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103],$Vb1,{36:[1,257],46:[1,256],104:[1,255]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:258,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,190],{33:$VB,46:[1,260],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,259]}),o($Vy,[2,62]),o($Vr,[2,164],{47:$Vx}),o([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,88,89,91,92,96,102,103,104,105],[2,70]),{8:76,9:$VW,13:$VX,33:[1,261],37:$VZ},o($VN1,[2,79],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:262,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,66,67,68,70,71,72,79,81,82,102,105],[2,101],{33:$VB,64:$VG,65:$VH,69:$VL}),o($VO1,[2,102],{33:$VB,58:$VC,59:$VD,62:$VE,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL,70:$VM}),o($VF1,[2,103],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($Vw1,[2,104],{33:$VB,65:$VH,69:$VL}),o($Vw1,[2,105],{33:$VB,65:$VH,69:$VL}),o($VN1,[2,106],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($VO1,[2,107],{33:$VB,58:$VC,59:$VD,62:$VE,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL,70:$VM}),o($VP1,[2,108],{33:$VB,58:$VC,59:$VD,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL}),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,65,66,67,68,70,71,72,79,81,82,102,105],[2,109],{33:$VB,69:$VL}),o($VP1,[2,110],{33:$VB,58:$VC,59:$VD,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL}),o($VF1,[2,111],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($Vy1,[2,112],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vy1,[2,120],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),{30:[1,263],47:$VQ1,48:$VR1},o([12,19,20,30,47,48],$VS1,{3:12,55:13,5:32,6:33,39:40,42:42,17:66,45:266,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vs1,[2,56],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,$VV,{8:76,9:$VW,13:$VX,32:$Vu1,57:$Vu1,37:$VZ,56:$V_,73:$V01,96:$V11}),o($Vp1,$Vq1,{11:267,46:$Vr1}),o($VN1,[2,72],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($VU,[2,73]),o($Vy1,[2,76],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:268,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VF1,[2,143],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VT1,$Vq1,{11:269,46:$Vr1}),o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,10:121,17:270,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:[1,271],38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,43]),o($Vc1,[2,44]),o($Vc1,[2,45]),o($Vh1,$Vi1,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vn1,$V0,{50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,101:141,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy1,[2,77],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($VU,[2,83],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU,[2,85],{8:76,9:$VW,13:$VX,37:$VZ}),{3:272,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,94],{33:$VB,65:$VH,69:$VL}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:273,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU1,$Vq1,{11:274,46:$Vr1}),o($VU,[2,86],{8:76,9:$VW,13:$VX,37:$VZ}),{3:275,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,95],{33:$VB,65:$VH,69:$VL}),o($VU,[2,87],{8:76,9:$VW,13:$VX,37:$VZ}),{3:276,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,96],{33:$VB,65:$VH,69:$VL}),o($VT1,$Vq1,{11:277,46:$Vr1}),o($VT1,$Vq1,{11:278,46:$Vr1}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:279,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:280,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,$VK1,{40:281,89:$VL1}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:282,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU1,$Vq1,{11:283,46:$Vr1}),o($VA1,[2,128],{82:$VB1,88:[1,284],89:[1,285]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:286,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:287,48:$Vd},{15:288,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:289,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:290,46:$Vz1,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:291,16:$V4,17:66,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,45:292,48:$Vd,49:$VT,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:293,48:$Vd},{48:$VD1,95:294,105:$VE1},{15:295,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:296,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($V81,[2,200],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU1,$Vq1,{11:297,46:$Vr1}),o($VT1,$Vq1,{11:298,46:$Vr1}),{19:[1,299],20:[1,300],39:301,47:$VV1,48:$VW1,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:304,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,194]),{33:$VB,34:[1,305],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,306],33:$VB,35:[1,307],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,308],47:$VQ1,48:$VR1},o($VG1,$Vq1,{11:309,46:$Vr1}),{22:[1,310],47:$VX1},o([20,22,47],$VS1,{3:12,55:13,6:33,39:40,42:42,98:126,17:127,5:131,100:312,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vz,$Vq1,{11:313,46:$VH1}),o($VI1,[2,151],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:314,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VI1,[2,154],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VY1,[2,149]),o($VY1,[2,150]),o($Vc1,[2,12]),{25:[1,315],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{25:[1,316]},{25:[1,317]},{3:318,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vc1,[2,15]),{25:[1,319],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,18]),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:320,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,20]),o($Vp1,$Vq1,{11:321,46:$Vr1}),o($Vc1,[2,22]),o($Vc1,[2,23]),{8:76,9:$VW,13:$VX,33:[1,322],37:$VZ},o($Vo1,[2,161]),o($Vc1,[2,39]),o($Vc1,[2,40]),{15:323,48:$Vd,78:[1,324]},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:325,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:326,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:327,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:328,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:329,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:330,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{33:$VB,34:[1,331],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:332,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:333,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:334,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU1,$Vq1,{11:335,46:$Vr1}),{52:$VZ1,74:$V_1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:66,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,45:338,49:$VT,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:339,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vs1,[2,52]),{30:[1,340],47:$VQ1,48:$VR1},o($VU1,$Vq1,{11:341,46:$Vr1}),{12:[1,342],47:$VQ1,48:$VR1},o($Ve1,$Vt1,{33:$VB,34:[1,343],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:344,19:[1,345],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,88],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU1,$Vq1,{11:346,46:$Vr1}),{20:[1,347],47:$VQ1,48:$VR1},o($VU,[2,89],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU,[2,90],{8:76,9:$VW,13:$VX,37:$VZ}),{12:[1,348],47:$VQ1,48:$VR1},{12:[1,349],47:$VQ1,48:$VR1},o($VT1,$Vq1,{11:350,46:$Vr1}),o($VT1,$Vq1,{11:351,46:$Vr1}),o($VU,[2,119]),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,102,105],[2,121],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,82:[1,352]}),{20:[1,353],47:$VQ1,48:$VR1},{15:354,48:$Vd},{15:355,48:$Vd},o($VC1,[2,148],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,[2,132]),o($VU,[2,133]),{15:356,46:$Vz1,48:$Vd},o($V$1,[2,198]),o($VU,[2,136],{92:[1,357]}),{15:358,48:$Vd},o($VU,[2,140]),{15:359,48:$Vd},o($VU,[2,142]),{46:$Vz1,48:[2,202]},{20:[1,360],47:$VQ1,48:$VR1},{12:[1,361],47:$VQ1,48:$VR1},o($Vc1,[2,9]),{19:[1,362]},o($VM1,[2,195]),{39:363,81:$Vp,102:$Vw},{39:364,81:$Vp,102:$Vw},{19:[1,365],33:$VB,35:[1,366],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:367,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,31]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:368,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,$V02,{44:$V12}),{19:[1,370],47:$VQ1,48:$VR1},o($Vc1,[2,47],{44:[1,371]}),{3:12,4:$Vj1,5:131,6:33,7:$V2,14:$V3,16:$V4,17:127,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$Vl1,53:$Vm1,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,98:126,100:372,102:$Vw},o($VI1,[2,158]),{20:[1,373],47:$VX1},o($VU1,$Vq1,{11:374,46:$Vr1}),o($Vc1,[2,13]),o($Vc1,[2,14]),o($Vc1,[2,17]),{8:76,9:$VW,13:$VX,33:[1,375],37:$VZ},o($Vc1,[2,16]),o($VT1,$Vq1,{11:376,46:$Vr1}),{30:[1,377],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:379,21:$V5,23:$V6,25:[1,378],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,166]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:380,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,168],{33:$VB,35:[1,382],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,381]}),o($VM1,[2,173],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,174],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,383]}),o($VM1,[2,176],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,384]}),{8:76,9:$VW,13:$VX,37:$VZ,104:[1,385]},{33:$VB,34:[1,386],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:387,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,191],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,192],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,388]}),o($VU,[2,74]),{20:[1,389],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:390,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:391,48:$Vd},o($Vs1,[2,53]),o($VU1,$Vq1,{11:392,46:$Vr1}),{74:$V_1},{20:[1,393],47:$VQ1,48:$VR1},o($Vc1,[2,6]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:394,19:[1,395],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{19:[1,397],33:$VB,35:[1,396],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,38]),{20:[1,398],47:$VQ1,48:$VR1},o($VU,[2,98]),{15:399,48:$Vd},{15:400,48:$Vd},{12:[1,401],47:$VQ1,48:$VR1},{12:[1,402],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:403,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,124]),o($VU,[2,129]),o($VU,[2,130]),o($V$1,[2,199]),{15:404,48:$Vd},o($VU,[2,138],{92:[1,405]}),o($VU,[2,141]),o($VU,[2,146]),{15:406,48:$Vd},o($Vc1,[2,10]),o($VM1,[2,196]),o($VM1,[2,197]),o($Vc1,[2,27]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:407,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{19:[1,408],33:$VB,35:[1,409],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,410],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,48]),o([9,13,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],$V02,{39:221,18:411,44:$V12,81:$Vp,102:$Vw}),o($Vc1,[2,49]),o($VI1,[2,159]),o($VI1,[2,160]),{20:[1,412],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:334,21:$V5,23:$V6,25:[1,413],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{12:[1,414],47:$VQ1,48:$VR1},{28:[1,415],52:$VZ1,74:$V_1},o($Vc1,[2,24]),{25:[1,416],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{15:417,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:418,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:419,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:420,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:421,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:422,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:423,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,181],{33:$VB,35:[1,425],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,424]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:426,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,80]),o($Vy,[2,66],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,[2,114]),{20:[1,427],47:$VQ1,48:$VR1},o($VU,[2,78]),{19:[1,429],33:$VB,35:[1,428],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,36]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:430,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,37]),o($VU,[2,97]),o($VU,[2,115]),o($VU,[2,116]),{15:431,48:$Vd},{15:432,48:$Vd},o($VF1,[2,122],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VU,[2,137]),{15:433,48:$Vd},o($Vc1,[2,8]),{19:[1,434],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,29]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:435,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,32]),{22:[1,436],39:301,47:$VV1,48:$VW1,81:$Vp,102:$Vw},o($VI1,[2,152]),o($Vc1,[2,25]),{25:[1,437]},{25:[1,438]},o($Vc1,[2,26]),o($Vc1,$VK1,{40:439,89:$VL1}),o($VM1,[2,169],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,170],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,440]}),o($VM1,[2,175],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,177],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,178],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,441]}),o($VM1,[2,180],{33:$VB,35:[1,443],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,442]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:444,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:445,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,193],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vs1,[2,54]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:446,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,35]),{19:[1,447],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($VU,[2,117]),o($VU,[2,118]),o($VU,[2,139]),o($Vc1,[2,28]),{19:[1,448],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,11]),o($Vc1,[2,19]),o($Vc1,[2,21]),o($Vc1,[2,167]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:449,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:450,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:451,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:452,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,183],{33:$VB,35:[1,453],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,185],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,454]}),{19:[1,455],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,34]),o($Vc1,[2,30]),o($VM1,[2,171],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,179],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,182],{33:$VB,35:[1,456],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,184],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,457]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:458,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:459,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,33]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:460,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:461,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,189],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,187],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,188],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,186],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP})],
defaultActions: {2:[2,204]},
parseError: function parseError (str, hash) {
   if (hash.recoverable) {
      this.trace(str);
   } else {
      var error = new Error(str);
      error.hash = hash;
      throw error;
   }
},
parse: function parse(input) {
   var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
   var args = lstack.slice.call(arguments, 1);
   var lexer = Object.create(this.lexer);
   var sharedState = { yy: {} };
   for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
         sharedState.yy[k] = this.yy[k];
      }
   }
   lexer.setInput(input, sharedState.yy);
   sharedState.yy.lexer = lexer;
   sharedState.yy.parser = this;
   if (typeof lexer.yylloc == 'undefined') {
      lexer.yylloc = {};
   }
   var yyloc = lexer.yylloc;
   lstack.push(yyloc);
   var ranges = lexer.options && lexer.options.ranges;
   if (typeof sharedState.yy.parseError === 'function') {
      this.parseError = sharedState.yy.parseError;
   } else {
      this.parseError = Object.getPrototypeOf(this).parseError;
   }
   function popStack(n) {
      stack.length = stack.length - 2 * n;
      vstack.length = vstack.length - n;
      lstack.length = lstack.length - n;
   }
   _token_stack:
   var lex = function () {
      var token;
      token = lexer.lex() || EOF;
      if (typeof token !== 'number') {
         token = self.symbols_[token] || token;
      }
      return token;
   };
   var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
   while (true) {
      state = stack[stack.length - 1];
      if (this.defaultActions[state]) {
         action = this.defaultActions[state];
      } else {
         if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
         }
         action = table[state] && table[state][symbol];
      }
      if (typeof action === 'undefined' || !action.length || !action[0]) {
         var errStr = '';
         expected = [];
         for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
               expected.push("'" + this.terminals_[p] + "'");
            }
         }
         if (lexer.showPosition) {
            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
         } else {
            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");
         }
         this.parseError(errStr, {
            text: lexer.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer.yylineno,
            loc: yyloc,
            expected: expected
         });
      }
      if (action[0] instanceof Array && action.length > 1) {
         throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
      }
      switch (action[0]) {
      case 1:
         stack.push(symbol);
         vstack.push(lexer.yytext);
         lstack.push(lexer.yylloc);
         stack.push(action[1]);
         symbol = null;
         if (!preErrorSymbol) {
            yyleng = lexer.yyleng;
            yytext = lexer.yytext;
            yylineno = lexer.yylineno;
            yyloc = lexer.yylloc;
            if (recovering > 0) {
               recovering--;
            }
         } else {
            symbol = preErrorSymbol;
            preErrorSymbol = null;
         }
         break;
      case 2:
         len = this.productions_[action[1]][1];
         yyval.$ = vstack[vstack.length - len];
         yyval._$ = {
            first_line: lstack[lstack.length - (len || 1)].first_line,
            last_line: lstack[lstack.length - 1].last_line,
            first_column: lstack[lstack.length - (len || 1)].first_column,
            last_column: lstack[lstack.length - 1].last_column
         };
         if (ranges) {
            yyval._$.range = [
               lstack[lstack.length - (len || 1)].range[0],
               lstack[lstack.length - 1].range[1]
            ];
         }
         r = this.performAction.apply(yyval, [
            yytext,
            yyleng,
            yylineno,
            sharedState.yy,
            action[1],
            vstack,
            lstack
         ].concat(args));
         if (typeof r !== 'undefined') {
            return r;
         }
         if (len) {
            stack = stack.slice(0, -1 * len * 2);
            vstack = vstack.slice(0, -1 * len);
            lstack = lstack.slice(0, -1 * len);
         }
         stack.push(this.productions_[action[1]][0]);
         vstack.push(yyval.$);
         lstack.push(yyval._$);
         newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
         stack.push(newState);
         break;
      case 3:
         return true;
      }
   }
   return true;
}};

function Parser () {
   this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
   if (!args[1]) {
      console.log('Usage: '+args[0]+' FILE');
      process.exit(1);
   }
   var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
   return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
   exports.main(process.argv.slice(1));
}
}

}).call(this)
},{}],6:[function(require,module,exports){
   // ./util
},{}],7:[function(require,module,exports){
   // ...
},{}],8:[function(require,module,exports){
   // fs
},{}],9:[function(require,module,exports){
   // buffer
},{}],10:[function(require,module,exports){
   // events
},{}],11:[function(require,module,exports){
   // ...
},{}],12:[function(require,module,exports){
// var toString = {}.toString;

// module.exports = Array.isArray || function (arr) {
// 	return toString.call(arr) == '[object Array]';
// };

},{}],13:[function(require,module,exports){
   // path
},{}],14:[function(require,module,exports){
   // ./Func.js
},{}],15:[function(require,module,exports){
   // ./List.js
},{}],16:[function(require,module,exports){
   // ./Num.js
},{}],17:[function(require,module,exports){
   // ./Obj.js
},{}],18:[function(require,module,exports){
   // ./Str.js
},{}],19:[function(require,module,exports){
   // prelude-ls
},{}],20:[function(require,module,exports){
   // _process
},{}],21:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
   this._array = [];
   this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
   var set = new ArraySet();
   for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
   }
   return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
   return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
   var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
   var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
   var idx = this._array.length;
   if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
   }
   if (!isDuplicate) {
      if (hasNativeMap) {
         this._set.set(aStr, idx);
      } else {
         this._set[sStr] = idx;
      }
   }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
   if (hasNativeMap) {
      return this._set.has(aStr);
   } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
   }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
   if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
            return idx;
      }
   } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
         return this._set[sStr];
      }
   }

   throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
   if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
   }
   throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
   return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":30}],22:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
   return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
   var isNegative = (aValue & 1) === 1;
   var shifted = aValue >> 1;
   return isNegative
      ? -shifted
      : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
   var encoded = "";
   var digit;

   var vlq = toVLQSigned(aValue);

   do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
         // There are still more digits in this value, so we must make sure the
         // continuation bit is marked.
         digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
   } while (vlq > 0);

   return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
   var strLen = aStr.length;
   var result = 0;
   var shift = 0;
   var continuation, digit;

   do {
      if (aIndex >= strLen) {
         throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
         throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
   } while (continuation);

   aOutParam.value = fromVLQSigned(result);
   aOutParam.rest = aIndex;
};

},{"./base64":23}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
   if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
   }
   throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
   var bigA = 65;     // 'A'
   var bigZ = 90;     // 'Z'

   var littleA = 97;  // 'a'
   var littleZ = 122; // 'z'

   var zero = 48;     // '0'
   var nine = 57;     // '9'

   var plus = 43;     // '+'
   var slash = 47;    // '/'

   var littleOffset = 26;
   var numberOffset = 52;

   // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
   if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
   }

   // 26 - 51: abcdefghijklmnopqrstuvwxyz
   if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
   }

   // 52 - 61: 0123456789
   if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
   }

   // 62: +
   if (charCode == plus) {
      return 62;
   }

   // 63: /
   if (charCode == slash) {
      return 63;
   }

   // Invalid base64 digit.
   return -1;
};

},{}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
   // This function terminates when one of the following is true:
   //
   //   1. We find the exact element we are looking for.
   //
   //   2. We did not find the exact element, but we can return the index of
   //      the next-closest element.
   //
   //   3. We did not find the exact element, and there is no next-closest
   //      element than the one we are searching for, so we return -1.
   var mid = Math.floor((aHigh - aLow) / 2) + aLow;
   var cmp = aCompare(aNeedle, aHaystack[mid], true);
   if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
   }
   else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
         // The element is in the upper half.
         return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
         return aHigh < aHaystack.length ? aHigh : -1;
      } else {
         return mid;
      }
   }
   else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
         // The element is in the lower half.
         return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
         return mid;
      } else {
         return aLow < 0 ? -1 : aLow;
      }
   }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
   if (aHaystack.length === 0) {
      return -1;
   }

   var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                             aCompare, aBias || exports.GREATEST_LOWER_BOUND);
   if (index < 0) {
      return -1;
   }

   // We have found either the exact element, or the next-closest element than
   // the one we are searching for. However, there may be more than one such
   // element. Make sure we always return the smallest of these.
   while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
         break;
      }
      --index;
   }

   return index;
};

},{}],25:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
   // Optimized for most common case
   var lineA = mappingA.generatedLine;
   var lineB = mappingB.generatedLine;
   var columnA = mappingA.generatedColumn;
   var columnB = mappingB.generatedColumn;
   return lineB > lineA || lineB == lineA && columnB >= columnA ||
             util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
   this._array = [];
   this._sorted = true;
   // Serves as infimum
   this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
   function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
   };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
   if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
   } else {
      this._sorted = false;
      this._array.push(aMapping);
   }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
   if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
   }
   return this._array;
};

exports.MappingList = MappingList;

},{"./util":30}],26:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
   var temp = ary[x];
   ary[x] = ary[y];
   ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
   return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
   // If our lower bound is less than our upper bound, we (1) partition the
   // array into two pieces and (2) recurse on each half. If it is not, this is
   // the empty array and our base case.

   if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
         if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
         }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
   }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
   doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],27:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
   var sourceMap = aSourceMap;
   if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
   }

   return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
   return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
   configurable: true,
   enumerable: true,
   get: function () {
      if (!this.__generatedMappings) {
         this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
   }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
   configurable: true,
   enumerable: true,
   get: function () {
      if (!this.__originalMappings) {
         this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
   }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
   function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
   };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
   function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
   };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
   function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
         mappings = this._generatedMappings;
         break;
      case SourceMapConsumer.ORIGINAL_ORDER:
         mappings = this._originalMappings;
         break;
      default:
         throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
         var source = mapping.source === null ? null : this._sources.at(mapping.source);
         source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
         return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
         };
      }, this).forEach(aCallback, context);
   };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
   function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
         source: util.getArg(aArgs, 'source'),
         originalLine: line,
         originalColumn: util.getArg(aArgs, 'column', 0)
      };

      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
         return [];
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                                   this._originalMappings,
                                                   "originalLine",
                                                   "originalColumn",
                                                   util.compareByOriginalPositions,
                                                   binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
         var mapping = this._originalMappings[index];

         if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while (mapping && mapping.originalLine === originalLine) {
               mappings.push({
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
               });

               mapping = this._originalMappings[++index];
            }
         } else {
            var originalColumn = mapping.originalColumn;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while (mapping &&
                      mapping.originalLine === line &&
                      mapping.originalColumn == originalColumn) {
               mappings.push({
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
               });

               mapping = this._originalMappings[++index];
            }
         }
      }

      return mappings;
   };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
   var sourceMap = aSourceMap;
   if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
   }

   var version = util.getArg(sourceMap, 'version');
   var sources = util.getArg(sourceMap, 'sources');
   // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
   // requires the array) to play nice here.
   var names = util.getArg(sourceMap, 'names', []);
   var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
   var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
   var mappings = util.getArg(sourceMap, 'mappings');
   var file = util.getArg(sourceMap, 'file', null);

   // Once again, Sass deviates from the spec and supplies the version as a
   // string rather than a number, so we use loose equality checking here.
   if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
   }

   if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
   }

   sources = sources
      .map(String)
      // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util.normalize)
      // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
         return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
            ? util.relative(sourceRoot, source)
            : source;
      });

   // Pass `true` below to allow duplicate names and sources. While source maps
   // are intended to be compressed and deduplicated, the TypeScript compiler
   // sometimes generates source maps with duplicates in them. See Github issue
   // #72 and bugzil.la/889492.
   this._names = ArraySet.fromArray(names.map(String), true);
   this._sources = ArraySet.fromArray(sources, true);

   this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
   });

   this.sourceRoot = sourceRoot;
   this.sourcesContent = sourcesContent;
   this._mappings = mappings;
   this._sourceMapURL = aSourceMapURL;
   this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
   var relativeSource = aSource;
   if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
   }

   if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
   }

   // Maybe aSource is an absolute URL as returned by |sources|.  In
   // this case we can't simply undo the transform.
   var i;
   for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
         return i;
      }
   }

   return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
   function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                                          smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function (s) {
         return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
         var srcMapping = generatedMappings[i];
         var destMapping = new Mapping;
         destMapping.generatedLine = srcMapping.generatedLine;
         destMapping.generatedColumn = srcMapping.generatedColumn;

         if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;

            if (srcMapping.name) {
               destMapping.name = names.indexOf(srcMapping.name);
            }

            destOriginalMappings.push(destMapping);
         }

         destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
   };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
   get: function () {
      return this._absoluteSources.slice();
   }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
   this.generatedLine = 0;
   this.generatedColumn = 0;
   this.source = null;
   this.originalLine = null;
   this.originalColumn = null;
   this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
   function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
         if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
         }
         else if (aStr.charAt(index) === ',') {
            index++;
         }
         else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;

            // Because each offset is encoded relative to the previous one,
            // many segments often have the same encoding. We can exploit this
            // fact by caching the parsed variable length fields of each segment,
            // allowing us to avoid a second parse if we encounter the same
            // segment again.
            for (end = index; end < length; end++) {
               if (this._charIsMappingSeparator(aStr, end)) {
                  break;
               }
            }
            str = aStr.slice(index, end);

            segment = cachedSegments[str];
            if (segment) {
               index += str.length;
            } else {
               segment = [];
               while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  segment.push(value);
               }

               if (segment.length === 2) {
                  throw new Error('Found a source, but no line and column');
               }

               if (segment.length === 3) {
                  throw new Error('Found a source and line, but no column');
               }

               cachedSegments[str] = segment;
            }

            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;

            if (segment.length > 1) {
               // Original source.
               mapping.source = previousSource + segment[1];
               previousSource += segment[1];

               // Original line.
               mapping.originalLine = previousOriginalLine + segment[2];
               previousOriginalLine = mapping.originalLine;
               // Lines are stored 0-based
               mapping.originalLine += 1;

               // Original column.
               mapping.originalColumn = previousOriginalColumn + segment[3];
               previousOriginalColumn = mapping.originalColumn;

               if (segment.length > 4) {
                  // Original name.
                  mapping.name = previousName + segment[4];
                  previousName += segment[4];
               }
            }

            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
               originalMappings.push(mapping);
            }
         }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
   };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
   function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                                             aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
         throw new TypeError('Line must be greater than or equal to 1, got '
                                       + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
         throw new TypeError('Column must be greater than or equal to 0, got '
                                       + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
   };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
   function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
         var mapping = this._generatedMappings[index];

         // Mappings do not contain a field for the last generated columnt. We
         // can come up with an optimistic estimate, however, by assuming that
         // mappings are contiguous (i.e. given two consecutive mappings, the
         // first mapping ends where the second one starts).
         if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];

            if (mapping.generatedLine === nextMapping.generatedLine) {
               mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
               continue;
            }
         }

         // The last mapping for each line spans the entire line.
         mapping.lastGeneratedColumn = Infinity;
      }
   };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
   function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
         generatedLine: util.getArg(aArgs, 'line'),
         generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
         needle,
         this._generatedMappings,
         "generatedLine",
         "generatedColumn",
         util.compareByGeneratedPositionsDeflated,
         util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
         var mapping = this._generatedMappings[index];

         if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
               source = this._sources.at(source);
               source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
               name = this._names.at(name);
            }
            return {
               source: source,
               line: util.getArg(mapping, 'originalLine', null),
               column: util.getArg(mapping, 'originalColumn', null),
               name: name
            };
         }
      }

      return {
         source: null,
         line: null,
         column: null,
         name: null
      };
   };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
   function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
         return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
         !this.sourcesContent.some(function (sc) { return sc == null; });
   };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
   function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
         return null;
      }

      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
         return this.sourcesContent[index];
      }

      var relativeSource = aSource;
      if (this.sourceRoot != null) {
         relativeSource = util.relative(this.sourceRoot, relativeSource);
      }

      var url;
      if (this.sourceRoot != null
            && (url = util.urlParse(this.sourceRoot))) {
         // XXX: file:// URIs and absolute paths lead to unexpected behavior for
         // many users. We can help them out when they expect file:// URIs to
         // behave like it would if they were running a local HTTP server. See
         // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
         var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
         if (url.scheme == "file"
               && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
         }

         if ((!url.path || url.path == "/")
               && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
         }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
         return null;
      }
      else {
         throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
   };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
   function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      source = this._findSourceIndex(source);
      if (source < 0) {
         return {
            line: null,
            column: null,
            lastColumn: null
         };
      }

      var needle = {
         source: source,
         originalLine: util.getArg(aArgs, 'line'),
         originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
         needle,
         this._originalMappings,
         "originalLine",
         "originalColumn",
         util.compareByOriginalPositions,
         util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
         var mapping = this._originalMappings[index];

         if (mapping.source === needle.source) {
            return {
               line: util.getArg(mapping, 'generatedLine', null),
               column: util.getArg(mapping, 'generatedColumn', null),
               lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
         }
      }

      return {
         line: null,
         column: null,
         lastColumn: null
      };
   };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
   var sourceMap = aSourceMap;
   if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
   }

   var version = util.getArg(sourceMap, 'version');
   var sections = util.getArg(sourceMap, 'sections');

   if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
   }

   this._sources = new ArraySet();
   this._names = new ArraySet();

   var lastOffset = {
      line: -1,
      column: 0
   };
   this._sections = sections.map(function (s) {
      if (s.url) {
         // The url field will require support for asynchronicity.
         // See https://github.com/mozilla/source-map/issues/16
         throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
         throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
         generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
         },
         consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
      }
   });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
   get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
         for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
         }
      }
      return sources;
   }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
   function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
         generatedLine: util.getArg(aArgs, 'line'),
         generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
         function(needle, section) {
            var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
            if (cmp) {
               return cmp;
            }

            return (needle.generatedColumn -
                        section.generatedOffset.generatedColumn);
         });
      var section = this._sections[sectionIndex];

      if (!section) {
         return {
            source: null,
            line: null,
            column: null,
            name: null
         };
      }

      return section.consumer.originalPositionFor({
         line: needle.generatedLine -
            (section.generatedOffset.generatedLine - 1),
         column: needle.generatedColumn -
            (section.generatedOffset.generatedLine === needle.generatedLine
             ? section.generatedOffset.generatedColumn - 1
             : 0),
         bias: aArgs.bias
      });
   };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
   function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
         return s.consumer.hasContentsOfAllSources();
      });
   };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
   function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
         var section = this._sections[i];

         var content = section.consumer.sourceContentFor(aSource, true);
         if (content) {
            return content;
         }
      }
      if (nullOnMissing) {
         return null;
      }
      else {
         throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
   };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
   function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
         var section = this._sections[i];

         // Only consider this section if the requested source is in the list of
         // sources of the consumer.
         if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
         }
         var generatedPosition = section.consumer.generatedPositionFor(aArgs);
         if (generatedPosition) {
            var ret = {
               line: generatedPosition.line +
                  (section.generatedOffset.generatedLine - 1),
               column: generatedPosition.column +
                  (section.generatedOffset.generatedLine === generatedPosition.line
                   ? section.generatedOffset.generatedColumn - 1
                   : 0)
            };
            return ret;
         }
      }

      return {
         line: null,
         column: null
      };
   };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
   function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
         var section = this._sections[i];
         var sectionMappings = section.consumer._generatedMappings;
         for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];

            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);

            var name = null;
            if (mapping.name) {
               name = section.consumer._names.at(mapping.name);
               this._names.add(name);
               name = this._names.indexOf(name);
            }

            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
               source: source,
               generatedLine: mapping.generatedLine +
                  (section.generatedOffset.generatedLine - 1),
               generatedColumn: mapping.generatedColumn +
                  (section.generatedOffset.generatedLine === mapping.generatedLine
                  ? section.generatedOffset.generatedColumn - 1
                  : 0),
               originalLine: mapping.originalLine,
               originalColumn: mapping.originalColumn,
               name: name
            };

            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
               this.__originalMappings.push(adjustedMapping);
            }
         }
      }

      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
   };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":21,"./base64-vlq":22,"./binary-search":24,"./quick-sort":26,"./util":30}],28:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
   if (!aArgs) {
      aArgs = {};
   }
   this._file = util.getArg(aArgs, 'file', null);
   this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
   this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
   this._sources = new ArraySet();
   this._names = new ArraySet();
   this._mappings = new MappingList();
   this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
   function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
         file: aSourceMapConsumer.file,
         sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
         var newMapping = {
            generated: {
               line: mapping.generatedLine,
               column: mapping.generatedColumn
            }
         };

         if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
               newMapping.source = util.relative(sourceRoot, newMapping.source);
            }

            newMapping.original = {
               line: mapping.originalLine,
               column: mapping.originalColumn
            };

            if (mapping.name != null) {
               newMapping.name = mapping.name;
            }
         }

         generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
         var sourceRelative = sourceFile;
         if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
         }

         if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
         }

         var content = aSourceMapConsumer.sourceContentFor(sourceFile);
         if (content != null) {
            generator.setSourceContent(sourceFile, content);
         }
      });
      return generator;
   };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
   function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
         this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
         source = String(source);
         if (!this._sources.has(source)) {
            this._sources.add(source);
         }
      }

      if (name != null) {
         name = String(name);
         if (!this._names.has(name)) {
            this._names.add(name);
         }
      }

      this._mappings.add({
         generatedLine: generated.line,
         generatedColumn: generated.column,
         originalLine: original != null && original.line,
         originalColumn: original != null && original.column,
         source: source,
         name: name
      });
   };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
   function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
         source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
         // Add the source content to the _sourcesContents map.
         // Create a new _sourcesContents map if the property is null.
         if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
         }
         this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
         // Remove the source file from the _sourcesContents map.
         // If the _sourcesContents map is empty, set the property to null.
         delete this._sourcesContents[util.toSetString(source)];
         if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
         }
      }
   };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
   function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
         if (aSourceMapConsumer.file == null) {
            throw new Error(
               'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
               'or the source map\'s "file" property. Both were omitted.'
            );
         }
         sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
         sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
         if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
               line: mapping.originalLine,
               column: mapping.originalColumn
            });
            if (original.source != null) {
               // Copy mapping
               mapping.source = original.source;
               if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source)
               }
               if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
               }
               mapping.originalLine = original.line;
               mapping.originalColumn = original.column;
               if (original.name != null) {
                  mapping.name = original.name;
               }
            }
         }

         var source = mapping.source;
         if (source != null && !newSources.has(source)) {
            newSources.add(source);
         }

         var name = mapping.name;
         if (name != null && !newNames.has(name)) {
            newNames.add(name);
         }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
         var content = aSourceMapConsumer.sourceContentFor(sourceFile);
         if (content != null) {
            if (aSourceMapPath != null) {
               sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
               sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
         }
      }, this);
   };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
   function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                                     aName) {
      // When aOriginal is truthy but has empty values for .line and .column,
      // it is most likely a programmer error. In this case we throw a very
      // specific error message to try to guide them the right way.
      // For example: https://github.com/Polymer/polymer-bundler/pull/519
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
            throw new Error(
                  'original.line and original.column are not numbers -- you probably meant to omit ' +
                  'the original mapping entirely and only map the generated position. If so, pass ' +
                  'null for the original mapping instead of an object with empty or null values.'
            );
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
            && aGenerated.line > 0 && aGenerated.column >= 0
            && !aOriginal && !aSource && !aName) {
         // Case 1.
         return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
         // Cases 2 and 3.
         return;
      }
      else {
         throw new Error('Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
         }));
      }
   };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
   function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
         mapping = mappings[i];
         next = ''

         if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
               next += ';';
               previousGeneratedLine++;
            }
         }
         else {
            if (i > 0) {
               if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                  continue;
               }
               next += ',';
            }
         }

         next += base64VLQ.encode(mapping.generatedColumn
                                                 - previousGeneratedColumn);
         previousGeneratedColumn = mapping.generatedColumn;

         if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;

            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1
                                                    - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;

            next += base64VLQ.encode(mapping.originalColumn
                                                    - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;

            if (mapping.name != null) {
               nameIdx = this._names.indexOf(mapping.name);
               next += base64VLQ.encode(nameIdx - previousName);
               previousName = nameIdx;
            }
         }

         result += next;
      }

      return result;
   };

SourceMapGenerator.prototype._generateSourcesContent =
   function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
         if (!this._sourcesContents) {
            return null;
         }
         if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
         }
         var key = util.toSetString(source);
         return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
            ? this._sourcesContents[key]
            : null;
      }, this);
   };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
   function SourceMapGenerator_toJSON() {
      var map = {
         version: this._version,
         sources: this._sources.toArray(),
         names: this._names.toArray(),
         mappings: this._serializeMappings()
      };
      if (this._file != null) {
         map.file = this._file;
      }
      if (this._sourceRoot != null) {
         map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
         map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
   };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
   function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
   };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":21,"./base64-vlq":22,"./mapping-list":25,"./util":30}],29:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
   this.children = [];
   this.sourceContents = {};
   this.line = aLine == null ? null : aLine;
   this.column = aColumn == null ? null : aColumn;
   this.source = aSource == null ? null : aSource;
   this.name = aName == null ? null : aName;
   this[isSourceNode] = true;
   if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
   function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are accessed by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
         var lineContents = getNextLine();
         // The last line of a file might not have a newline.
         var newLine = getNextLine() || "";
         return lineContents + newLine;

         function getNextLine() {
            return remainingLinesIndex < remainingLines.length ?
                  remainingLines[remainingLinesIndex++] : undefined;
         }
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
         if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
               // Associate first line with "lastMapping"
               addMappingWithCode(lastMapping, shiftNextLine());
               lastGeneratedLine++;
               lastGeneratedColumn = 0;
               // The remaining code is added without mapping
            } else {
               // There is no new line in between.
               // Associate the code between "lastGeneratedColumn" and
               // "mapping.generatedColumn" with "lastMapping"
               var nextLine = remainingLines[remainingLinesIndex] || '';
               var code = nextLine.substr(0, mapping.generatedColumn -
                                                            lastGeneratedColumn);
               remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                                                     lastGeneratedColumn);
               lastGeneratedColumn = mapping.generatedColumn;
               addMappingWithCode(lastMapping, code);
               // No more remaining code, continue
               lastMapping = mapping;
               return;
            }
         }
         // We add the generated code until the first mapping
         // to the SourceNode without any mapping.
         // Each line is added as separate string.
         while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
         }
         if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
         }
         lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLinesIndex < remainingLines.length) {
         if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
         }
         // and add the remaining lines without any mapping
         node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
         var content = aSourceMapConsumer.sourceContentFor(sourceFile);
         if (content != null) {
            if (aRelativePath != null) {
               sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
         }
      });

      return node;

      function addMappingWithCode(mapping, code) {
         if (mapping === null || mapping.source === undefined) {
            node.add(code);
         } else {
            var source = aRelativePath
               ? util.join(aRelativePath, mapping.source)
               : mapping.source;
            node.add(new SourceNode(mapping.originalLine,
                                                mapping.originalColumn,
                                                source,
                                                code,
                                                mapping.name));
         }
      }
   };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
   if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
         this.add(chunk);
      }, this);
   }
   else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
         this.children.push(aChunk);
      }
   }
   else {
      throw new TypeError(
         "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
   }
   return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
   if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
         this.prepend(aChunk[i]);
      }
   }
   else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
   }
   else {
      throw new TypeError(
         "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
   }
   return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
   var chunk;
   for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
         chunk.walk(aFn);
      }
      else {
         if (chunk !== '') {
            aFn(chunk, { source: this.source,
                               line: this.line,
                               column: this.column,
                               name: this.name });
         }
      }
   }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
   var newChildren;
   var i;
   var len = this.children.length;
   if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
         newChildren.push(this.children[i]);
         newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
   }
   return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
   var lastChild = this.children[this.children.length - 1];
   if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
   }
   else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
   }
   else {
      this.children.push(''.replace(aPattern, aReplacement));
   }
   return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
   function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
   };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
   function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
         if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
         }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
         aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
   };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
   var str = "";
   this.walk(function (chunk) {
      str += chunk;
   });
   return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
   var generated = {
      code: "",
      line: 1,
      column: 0
   };
   var map = new SourceMapGenerator(aArgs);
   var sourceMappingActive = false;
   var lastOriginalSource = null;
   var lastOriginalLine = null;
   var lastOriginalColumn = null;
   var lastOriginalName = null;
   this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
            && original.line !== null
            && original.column !== null) {
         if(lastOriginalSource !== original.source
             || lastOriginalLine !== original.line
             || lastOriginalColumn !== original.column
             || lastOriginalName !== original.name) {
            map.addMapping({
               source: original.source,
               original: {
                  line: original.line,
                  column: original.column
               },
               generated: {
                  line: generated.line,
                  column: generated.column
               },
               name: original.name
            });
         }
         lastOriginalSource = original.source;
         lastOriginalLine = original.line;
         lastOriginalColumn = original.column;
         lastOriginalName = original.name;
         sourceMappingActive = true;
      } else if (sourceMappingActive) {
         map.addMapping({
            generated: {
               line: generated.line,
               column: generated.column
            }
         });
         lastOriginalSource = null;
         sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
         if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            // Mappings end at eol
            if (idx + 1 === length) {
               lastOriginalSource = null;
               sourceMappingActive = false;
            } else if (sourceMappingActive) {
               map.addMapping({
                  source: original.source,
                  original: {
                     line: original.line,
                     column: original.column
                  },
                  generated: {
                     line: generated.line,
                     column: generated.column
                  },
                  name: original.name
               });
            }
         } else {
            generated.column++;
         }
      }
   });
   this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
   });

   return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":28,"./util":30}],30:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
   if (aName in aArgs) {
      return aArgs[aName];
   } else if (arguments.length === 3) {
      return aDefaultValue;
   } else {
      throw new Error('"' + aName + '" is a required argument.');
   }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
   var match = aUrl.match(urlRegexp);
   if (!match) {
      return null;
   }
   return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
   };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
   var url = '';
   if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
   }
   url += '//';
   if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
   }
   if (aParsedUrl.host) {
      url += aParsedUrl.host;
   }
   if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
   }
   if (aParsedUrl.path) {
      url += aParsedUrl.path;
   }
   return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
   var path = aPath;
   var url = urlParse(aPath);
   if (url) {
      if (!url.path) {
         return aPath;
      }
      path = url.path;
   }
   var isAbsolute = exports.isAbsolute(path);

   var parts = path.split(/\/+/);
   for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
         parts.splice(i, 1);
      } else if (part === '..') {
         up++;
      } else if (up > 0) {
         if (part === '') {
            // The first part is blank if the path is absolute. Trying to go
            // above the root is a no-op. Therefore we can remove all '..' parts
            // directly after the root.
            parts.splice(i + 1, up);
            up = 0;
         } else {
            parts.splice(i, 2);
            up--;
         }
      }
   }
   path = parts.join('/');

   if (path === '') {
      path = isAbsolute ? '/' : '.';
   }

   if (url) {
      url.path = path;
      return urlGenerate(url);
   }
   return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
   if (aRoot === "") {
      aRoot = ".";
   }
   if (aPath === "") {
      aPath = ".";
   }
   var aPathUrl = urlParse(aPath);
   var aRootUrl = urlParse(aRoot);
   if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
   }

   // `join(foo, '//www.example.org')`
   if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
         aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
   }

   if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
   }

   // `join('http://', 'www.example.com')`
   if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
   }

   var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

   if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
   }
   return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
   return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
   if (aRoot === "") {
      aRoot = ".";
   }

   aRoot = aRoot.replace(/\/$/, '');

   // It is possible for the path to be above the root. In this case, simply
   // checking whether the root is a prefix of the path won't work. Instead, we
   // need to remove components from the root one by one, until either we find
   // a prefix that fits, or we run out of components to remove.
   var level = 0;
   while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
         return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
         return aPath;
      }

      ++level;
   }

   // Make sure we add a "../" for each component we removed from the root.
   return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
   var obj = Object.create(null);
   return !('__proto__' in obj);
}());

function identity (s) {
   return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
   if (isProtoString(aStr)) {
      return '$' + aStr;
   }

   return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
   if (isProtoString(aStr)) {
      return aStr.slice(1);
   }

   return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
   if (!s) {
      return false;
   }

   var length = s.length;

   if (length < 9 /* "__proto__".length */) {
      return false;
   }

   if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
         s.charCodeAt(length - 2) !== 95  /* '_' */ ||
         s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
         s.charCodeAt(length - 4) !== 116 /* 't' */ ||
         s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
         s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
         s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
         s.charCodeAt(length - 8) !== 95  /* '_' */ ||
         s.charCodeAt(length - 9) !== 95  /* '_' */) {
      return false;
   }

   for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
         return false;
      }
   }

   return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
   var cmp = strcmp(mappingA.source, mappingB.source);
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.originalLine - mappingB.originalLine;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.originalColumn - mappingB.originalColumn;
   if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
   }

   cmp = mappingA.generatedColumn - mappingB.generatedColumn;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.generatedLine - mappingB.generatedLine;
   if (cmp !== 0) {
      return cmp;
   }

   return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
   var cmp = mappingA.generatedLine - mappingB.generatedLine;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.generatedColumn - mappingB.generatedColumn;
   if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
   }

   cmp = strcmp(mappingA.source, mappingB.source);
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.originalLine - mappingB.originalLine;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.originalColumn - mappingB.originalColumn;
   if (cmp !== 0) {
      return cmp;
   }

   return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
   if (aStr1 === aStr2) {
      return 0;
   }

   if (aStr1 === null) {
      return 1; // aStr2 !== null
   }

   if (aStr2 === null) {
      return -1; // aStr1 !== null
   }

   if (aStr1 > aStr2) {
      return 1;
   }

   return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
   var cmp = mappingA.generatedLine - mappingB.generatedLine;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.generatedColumn - mappingB.generatedColumn;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = strcmp(mappingA.source, mappingB.source);
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.originalLine - mappingB.originalLine;
   if (cmp !== 0) {
      return cmp;
   }

   cmp = mappingA.originalColumn - mappingB.originalColumn;
   if (cmp !== 0) {
      return cmp;
   }

   return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
   return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
   sourceURL = sourceURL || '';

   if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
         sourceRoot += '/';
      }
      // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   “sources” entry.  This value is prepended to the individual
      //   entries in the “source” field.
      sourceURL = sourceRoot + sourceURL;
   }

   // Historically, SourceMapConsumer did not take the sourceMapURL as
   // a parameter.  This mode is still somewhat supported, which is why
   // this code block is conditional.  However, it's preferable to pass
   // the source map URL to SourceMapConsumer, so that this function
   // can implement the source URL resolution algorithm as outlined in
   // the spec.  This block is basically the equivalent of:
   //    new URL(sourceURL, sourceMapURL).toString()
   // ... except it avoids using URL, which wasn't available in the
   // older releases of node still supported by this library.
   //
   // The spec says:
   //   If the sources are not absolute URLs after prepending of the
   //   “sourceRoot”, the sources are resolved relative to the
   //   SourceMap (like resolving script src in a html document).
   if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
         throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
         // Strip the last path component, but keep the "/".
         var index = parsed.path.lastIndexOf('/');
         if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
         }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
   }

   return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],31:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":27,"./lib/source-map-generator":28,"./lib/source-node":29}],"livescript":[function(require,module,exports){
// Generated by LiveScript 1.6.1
var LiveScript;
LiveScript = require('./index');
LiveScript.stab = function(code, callback, filename){
   var e;
   try {
      LiveScript.run(code, {
         filename: filename,
         map: 'embedded'
      });
   } catch (e$) {
      e = e$;
   }
   if (typeof callback == 'function') {
      callback(e);
   }
};
LiveScript.load = async function(url, callback){
   fetch(url)
   .then(res => {
      if (res.status === 200 || res.status === 0) {
         return res.text();
      } else {
         if (typeof callback == "function") {
            callback(Error(url + ": " + res.status + " " + res.statusText));
         }
      }
   })
   .then(text => {
      LiveScript.stab(text, callback, url);
   });
};
LiveScript.go = async function(){
   var type, sink, i$, ref$, len$, script;
   type = /^(?:text\/|application\/)?ls$/i;
   sink = function(error){
      error && setTimeout(function(){
         throw error;
      });
   };
   for (i$ = 0, len$ = (ref$ = document.getElementsByTagName('script')).length; i$ < len$; ++i$) {
      script = ref$[i$];
      if (type.test(script.type)) {
         if (script.src) {
            await LiveScript.load(script.src, sink);
         } else {
            LiveScript.stab(script.text, sink, script.id);
         }
      }
   }
};
module.exports = LiveScript;
},{"./index":2}]},{},[]);

if (isNode) {
   module.exports = require('livescript');
} else {
   window.livescript = require('livescript');
   window.addEventListener('DOMContentLoaded', livescript.go, {once: true});
}

})();
