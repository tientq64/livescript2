// Generated by LiveScript 1.6.1

// LiveScript 1.6.1
// Copyright (c) Jeremy Ashkenas, Satoshi Murakami, George Zahariev
// Released under the MIT License
// https://raw.githubusercontent.com/gkz/LiveScript/master/LICENSE
(function() {

var isNode = typeof module !== 'undefined' && module.exports;
var require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by LiveScript 1.6.1
var fold, ref$, nameFromPath, stripString, SourceNode, SourceMapGenerator, sn, snEmpty, snSafe, snRemoveLeft, Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Yield, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, StepSlice, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, CopyL, DECLS, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, ID_INTERPOLATE, SIMPLENUM, slice$ = [].slice, arrayFrom$ = Array.from || (x => slice$.call(x)), toString$ = {}.toString;
function curry$(f, bound){
	var context,
	_curry = function(args) {
		return f.length > 1 ? function(){
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) <
					f.length && arguments.length ?
				_curry.call(context, params) : f.apply(context, params);
		} : f;
	};
	return _curry();
}
fold = curry$(function(f, memo, xs){
	var i$, len$, x;
	for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
		x = xs[i$];
		memo = f(memo, x);
	}
	return memo;
});
stripString = function(val){
	var that;
	if (that = /^['"](.*)['"]$/.exec(val.trim())) {
		return that[1];
	} else {
		return val;
	}
};
nameFromPath = function(modulePath){
	return stripString(modulePath).split('/').pop().split('.')[0].replace(/-[a-z]/ig, function(it){
		return it.charAt(1).toUpperCase();
	});
};
ref$ = require('source-map'), SourceNode = ref$.SourceNode, SourceMapGenerator = ref$.SourceMapGenerator;
sn = function(node){
	var parts = [], i$, to$, result;
	node == null && (node = {});
	for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
		parts.push(arguments[i$]);
	}
	try {
		result = new SourceNode(node.line, node.column, null, parts);
		result.displayName = node.constructor.displayName;
		return result;
	} catch (e) {
		console.dir(parts);
		throw e;
	}
};
snEmpty = function(node){
	var i$, ref$, len$;
	if (node instanceof SourceNode) {
		for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
			if (!snEmpty(ref$[i$])) {
				return false;
			}
		}
		return true;
	} else {
		return !node;
	}
};
snSafe = function(code){
	if (code instanceof SourceNode) {
		return code;
	} else {
		return code.toString();
	}
};
snRemoveLeft = function(node, count){
	var to$, i, child;
	for (i = 0, to$ = node.children.length; i < to$; ++i) {
		child = node.children[i];
		if (child instanceof SourceNode) {
			count = snRemoveLeft(child, count);
		} else {
			child = child.toString();
			node.children[i] = child.slice(count);
			count -= child.length;
		}
		if (count <= 0) {
			return 0;
		}
	}
	return count;
};
SourceNode.prototype.replace = function(...args){
	return new SourceNode(
		this.line, this.column, this.source,
		this.children.map(x => x.replace(...args)),
		this.name
	);
};
SourceNode.prototype.setFile = function(filename){
	var i$, ref$, len$, child, results$ = [];
	this.source = filename;
	for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
		child = ref$[i$];
		if (child instanceof SourceNode) {
			results$.push(child.setFile(filename));
		}
	}
	return results$;
};
SourceNode.prototype.toStringWithSourceMap = function(...args){
	var gen, genLine = 1, genColumn = 0, stack = [], code = '',
		debugOutput = '', debugIndent = '', debugIndentStr = '  ', genForNode;
	gen = (function(func, args, ctor) {
		ctor.prototype = func.prototype;
		var child = new ctor, result = func.apply(child, args), t;
		return (t = typeof result)  == "object" || t == "function" ? result || child : child;
	})(SourceMapGenerator, args, function(){});
	genForNode = function(node){
		var valid, i$, ref$, len$, child, cur, to$, i, c, results$ = [];
		if (node instanceof SourceNode) {
			debugOutput += debugIndent + node.displayName;
			valid = node.line && 'column' in node;
			if (valid) {
				stack.push(node);
				debugOutput += '!';
			}
			debugOutput += " " + node.line + ":" + node.column + " " + genLine + ":" + genColumn + "\n";
			debugIndent += debugIndentStr;
			for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
				child = ref$[i$];
				genForNode(child);
			}
			debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
			if (valid) {
				return stack.pop();
			}
		} else {
			debugOutput += debugIndent + "" + JSON.stringify(node) + "\n";
			code += node;
			cur = stack[stack.length - 1];
			if (cur) {
				gen.addMapping({
					source: cur.source,
					original: {
						line: cur.line,
						column: cur.column
					},
					generated: {
						line: genLine,
						column: genColumn
					},
					name: cur.name
				});
			}
			for (i$ = 0, to$ = node.length; i$ < to$; ++i$) {
				i = i$;
				c = node.charAt(i);
				if (c === "\n") {
					genColumn = 0;
					++genLine;
					if (cur) {
						results$.push(gen.addMapping({
							source: cur.source,
							original: {
								line: cur.line,
								column: cur.column
							},
							generated: {
								line: genLine,
								column: genColumn
							},
							name: cur.name
						}));
					}
				} else {
					results$.push(++genColumn);
				}
			}
			return results$;
		}
	};
	genForNode(this);
	return {
		code: code,
		map: gen,
		debug: debugOutput
	};
};
/* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost
tmp-to-string = SourceNode::to-string
SourceNode::to-string = (...args) ->
		console.log("toString(): ", new Error().stack)
		tmp-to-string.apply this, args
*/
(Node = function(){
	throw Error('unimplemented');
}).prototype = {
	compile: function(options, level){
		var o, code, that, i$, len$;
		o = import$({}, options);
		if (level != null) {
			o.level = level;
		}
		if (o.level && this.isStatement()) {
			return this.compileClosure(o);
		}
		code = (this.tab = o.indent, this).compileNode(o);
		if (that = this.temps) {
			for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
				o.scope.free(that[i$]);
			}
		}
		return code;
	},
	compileClosure: function(o){
		var that, fun, call, hasArgs, hasThis, out;
		if (that = this.getJump()) {
			that.carp('inconvertible statement');
		}
		fun = Fun([], Block(this));
		call = Call();
		if (o.inAsync) {
			fun.async = true;
		}
		if (o.inGenerator) {
			fun.generator = true;
		}
		this.traverseChildren(function(it){
			switch (it.value) {
			case 'this':
				hasThis = true;
				break;
			case 'arguments':
				hasArgs = it.value = 'args$';
			}
		});
		if (hasThis) {
			call.args.push(Literal('this'));
			call.method = '.call';
		}
		if (hasArgs) {
			call.args.push(Literal('arguments'));
			fun.params.push(Var('args$'));
		}
		out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
		if (o.inGenerator) {
			out = new Yield('yieldfrom', out);
		} else if (o.inAsync) {
			out = new Yield('await', out);
		}
		return out.compile(o);
	},
	compileBlock: function(o, node){
		var code;
		if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
			return sn(null, "{\n", code, "\n" + this.tab + "}");
		} else {
			return sn(node, '{}');
		}
	},
	compileSpreadOver: function(o, list, transform){
		var ob, them, i$, len$, node, sp, lat, ref$;
		ob = list instanceof Obj;
		them = list.items;
		for (i$ = 0, len$ = them.length; i$ < len$; ++i$) {
			node = them[i$];
			if (sp = node instanceof Splat) {
				node = node.it;
			}
			if (ob && !sp) {
				node = node.val;
			}
			node = transform(node);
			if (sp) {
				node = lat = Splat(node);
			}
			if (ob && !sp) {
				them[i$].val = node;
			} else {
				them[i$] = node;
			}
		}
		if (!lat && (this['void'] || !o.level)) {
			list = (ref$ = Block(ob ? (function(){
				var i$, x$, ref$, len$, results$ = [];
				for (i$ = 0, len$ = (ref$ = them).length; i$ < len$; ++i$) {
					x$ = ref$[i$];
					results$.push(x$.val);
				}
				return results$;
			}()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
		}
		return list.compile(o, LEVEL_PAREN);
	},
	cache: function(o, once, level, tempName){
		var ref$, ref, sub, tempvars;
		if (!this.isComplex()) {
			return [ref$ = level != null ? this.compile(o, level) : this, ref$];
		}
		if (ref = this.getRef()) {
			sub = this;
		} else {
			sub = Assign(ref = Var(o.scope.temporary(tempName)), this);
			if (once) {
				ref.temp = true;
			} else {
				tempvars = [ref.value];
			}
		}
		if (level != null) {
			sub = sub.compile(o, level);
			if (once && tempvars) {
				o.scope.free(ref.value);
			}
			return [sub, ref.value];
		}
		return [sub, ref, tempvars];
	},
	compileLoopReference: function(o, name, ret, safeAccess){
		var ref$, code, asn, tmp;
		if (this instanceof Var && o.scope.check(this.value) || this instanceof Unary && ((ref$ = this.op) === '+' || ref$ === '-') && (-1 / 0 < (ref$ = +this.it.value) && ref$ < 1 / 0) || this instanceof Literal && !this.isComplex()) {
			code = this.compile(o, LEVEL_PAREN);
			if (safeAccess && !(this instanceof Var)) {
				code = "(" + code + ")";
			}
			return [code, code];
		}
		asn = Assign(Var(tmp = o.scope.temporary(name)), this);
		ret || (asn['void'] = true);
		return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
	},
	eachChild: function(fn){
		var i$, ref$, len$, name, child, j$, len1$, that;
		for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
			name = ref$[i$];
			if (child = this[name]) {
				if ('length' in child) {
					for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
						if (that = fn(child[j$], name, j$)) {
							return that;
						}
					}
				} else {
					if ((that = fn(child, name)) != null) {
						return that;
					}
				}
			}
		}
	},
	traverseChildren: function(fn, xscope){
		return this.eachChild((node, name, index) => {
			var ref$;
			return (ref$ = fn(node, this, name, index)) != null
				? ref$
				: node.traverseChildren(fn, xscope);
		});
	},
	rewriteShorthand: function(o, assign){
		var i$, ref$, len$, name, child, j$, len1$, that;
		for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
			name = ref$[i$];
			if (child = this[name]) {
				if ('length' in child) {
					for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
						if (that = child[j$].rewriteShorthand(o, assign)) {
							child[j$] = that;
						}
					}
				} else if (that = child.rewriteShorthand(o, assign)) {
					this[name] = that;
				}
			}
		}
	},
	anaphorize: function(){
		var name, ref$;
		this.children = this.aTargets;
		if (this.eachChild(hasThat)) {
			if (this[name = this.aSource] instanceof Existence) {
				this[name].doAnaphorize = true;
			} else if (this[name].value !== 'that') {
				this[name] = Assign(Var('that'), this[name]);
			}
		}
		function hasThat(it){
			var that;
			return it.value === 'that' || ((that = it.aSource)
				? (that = it[that]) ? hasThat(that) : void 8
				: it.eachChild(hasThat));
		}
		delete this.children;
		return ref$ = this[this.aSource], ref$.cond = true, ref$;
	},
	carp: function(msg, type){
		type == null && (type = SyntaxError);
		throw type(msg + " " + this.lineMsg());
	},
	warn: function(msg){
		if (typeof console != 'undefined' && console !== null) {
			console.warn("WARNING: " + msg + " " + this.lineMsg());
		}
	},
	lineMsg: function(){
		return "on line " + (this.line || this.traverseChildren(it => it.line));
	},
	delegate: function(names, fn){
		var i$, len$;
		for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {
			fn$.call(this, names[i$]);
		}
		function fn$(name){
			this[name] = function(it){
				return fn.call(this, name, it);
			};
		}
	},
	children: [],
	terminator: ';',
	isComplex: YES,
	isStatement: NO,
	isAssignable: NO,
	isCallable: NO,
	isEmpty: NO,
	isArray: NO,
	isString: NO,
	isRegex: NO,
	isMatcher: function(){
		return this.isString() || this.isRegex();
	},
	assigns: NO,
	ripName: VOID,
	getRef: VOID,
	unfoldSoak: VOID,
	unfoldAssign: VOID,
	unparen: THIS,
	unwrap: THIS,
	maybeKey: VOID,
	varName: String,
	getAccessors: VOID,
	getCall: VOID,
	getDefault: VOID,
	getJump: VOID,
	isNextUnreachable: NO,
	extractKeyRef: function(o, assign){
		return this.maybeKey() || this.carp(assign ? "invalid assign" : "invalid property shorthand");
	},
	invert: function(){
		return Unary('!', this, true);
	},
	invertCheck: function(it){
		return it.inverted ? this.invert() : this;
	},
	addElse: function($else){
		this['else'] = $else;
		return this;
	},
	makeReturn: function(ref, obj){
		var items, kv;
		if (obj) {
			items = this instanceof Arr
				? (this.items[0] == null || this.items[1] == null && this.carp('must specify both key and value for object comprehension'), this.items)
				: (kv = 'keyValue$', [Assign(Var(kv), this), Var(kv)].map((v, i) => Chain(v).add(Index(Literal(i)))));
			return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
		} else if (ref) {
			return Call.make(JS(ref + '.push'), [this]);
		} else {
			return Return(this);
		}
	},
	show: String,
	toString: function(idt){
		var tree, that;
		idt || (idt = '');
		tree = '\n' + idt + this.constructor.displayName;
		if (that = this.show()) {
			tree += ' ' + that;
		}
		this.eachChild(function(it){
			tree += it.toString(idt + TAB);
		});
		return tree;
	},
	stringify: function(space){
		return JSON.stringify(this, null, space);
	},
	toJSON: function(){
		return import$({
			type: this.constructor.displayName
		}, this);
	}
};
exports.parse = function(json){
	return exports.fromJSON(JSON.parse(json));
};
exports.fromJSON = (function(){
	return function fromJSON(it){
		var node, key, i$, len$;
		if (!(it && typeof it === 'object')) {
			return it;
		}
		if (it.type) {
			node = clone$(exports[it.type].prototype);
			for (key in it) {
				node[key] = fromJSON(it[key]);
			}
			return node;
		}
		return it.length != null ? it.map(v => fromJSON(v)) : it;
	}
}());
Negatable = {
	show: function(){
		return this.negated && '!';
	},
	invert: function(){
		this.negated = !this.negated;
		return this;
	}
};
exports.Block = Block = (function(superclass){
	var prototype = extend$((import$(Block, superclass).displayName = 'Block', Block), superclass).prototype, constructor = Block;
	function Block(body){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		body || (body = []);
		if ('length' in body) {
			this$.lines = body;
		} else {
			this$.lines = [];
			this$.add(body);
		}
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Block.prototype.children = ['lines'];
	Block.prototype.toJSON = function(){
		delete this.back;
		return superclass.prototype.toJSON.call(this);
	};
	Block.prototype.add = function(it){
		var that, ref$;
		it = it.unparen();
		switch (false) {
		case !(that = this.back):
			that.add(it);
			break;
		case !(that = it.lines):
			(ref$ = this.lines).push.apply(ref$, that);
			break;
		default:
			this.lines.push(it);
			if (that = (ref$ = it.back, delete it.back, ref$)) {
				this.back = that;
			}
		}
		return this;
	};
	Block.prototype.prepend = function(...args){
		this.lines.splice(this.neck(), 0, ...args);
		return this;
	};
	Block.prototype.pipe = function(target, type){
		var args;
		args = type === '|>' ? this.lines.pop() : target;
		if (toString$.call(args).slice(8, -1) !== 'Array') {
			args = [args];
		}
		switch (type) {
		case '|>':
			this.lines.push(Call.make(target, args, {
				pipe: true
			}));
			break;
		case '<|':
			this.lines.push(Call.make(this.lines.pop(), args));
		}
		return this;
	};
	Block.prototype.unwrap = function(){
		return this.lines.length === 1 ? this.lines[0] : this;
	};
	Block.prototype.chomp = function(){
		var lines, i, that;
		lines = this.lines;
		i = lines.length;
		while (that = lines[--i]) {
			if (!that.comment) {
				break;
			}
		}
		lines.length = i + 1;
		return this;
	};
	Block.prototype.neck = function(){
		var pos, i$, ref$, len$, x;
		pos = 0;
		for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
			x = ref$[i$];
			if (!(x.comment || x instanceof Literal)) {
				break;
			}
			++pos;
		}
		return pos;
	};
	Block.prototype.isComplex = function(){
		var ref$;
		return this.lines.length > 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
	};
	prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], it => {
		var ref$, ref1$;
		return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
	});
	Block.prototype.getJump = function(it){
		var i$, ref$, len$, that;
		for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
			if (that = ref$[i$].getJump(it)) {
				return that;
			}
		}
	};
	Block.prototype.isNextUnreachable = function(){
		var i$, ref$, len$;
		for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
			if (ref$[i$].isNextUnreachable()) {
				return true;
			}
		}
		return false;
	};
	Block.prototype.makeReturn = function(){
		var ref$, key$, that;
		this.chomp();
		if (that = (ref$ = this.lines)[key$ = ref$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref$, arguments) : void 8) {
			if (that instanceof Return && !that.it) {
				--this.lines.length;
			}
		}
		return this;
	};
	Block.prototype.compile = function(o, level){
		var tab, codes, i$, ref$, len$, node, that, code;
		level == null && (level = o.level);
		if (level) {
			return this.compileExpressions(o, level);
		}
		o.block = this;
		tab = o.indent;
		codes = [];
		for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
			node = ref$[i$];
			if (!node.evalResult) {
				node['void'] = true;
			}
			if (that = node.rewriteShorthand(o)) {
				node = that;
			}
			if (snEmpty(code = (node.front = true, node).compile(o, level))) {
				continue;
			}
			codes.push(tab, code);
			node.isStatement() || codes.push(node.terminator);
			codes.push('\n');
		}
		codes.pop();
		return sn(null, ...codes)
	};
	Block.prototype.compileRoot = function(options){
		var o, that, ref$, bare, prefix, ref1$, ref2$, comment, ref3$, code;
		o = (import$({
			level: LEVEL_TOP,
			scope: this.scope = Scope.root = new Scope
		}, options));
		if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
			this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
		}
		delete o.filename;
		o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
		if (/^\s*(?:#!|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
			prefix = this.lines.shift().code + '\n';
		}
		if (((ref1$ = this.lines[0]) != null ? (ref2$ = ref1$.code) != null ? ref2$[0] : void 8 : void 8) === '/') {
			comment = this.lines.shift().code + '\n';
		}
		if ((ref3$ = o.eval, delete o.eval, ref3$) && this.chomp().lines.length) {
			if (bare) {
				this.lines.push((ref3$ = Parens(this.lines.pop()), ref3$.evalResult = true, ref3$));
			} else {
				this.makeReturn();
			}
		}
		code = [this.compileWithDeclarations(o)];
		bare || (code = [";(async function(){\n", code[0], "\n}).call(this);\n"]);
		return sn(null, prefix || [], options.header || [], comment || [], code);
	};
	Block.prototype.compileWithDeclarations = function(o){
		var pre, i, rest, post;
		o.level = LEVEL_TOP;
		pre = [];
		if (i = this.neck()) {
			rest = this.lines.splice(i, 9e9);
			pre = [this.compile(o), "\n"];
			this.lines = rest;
		}
		if (snEmpty(post = this.compile(o))) {
			return sn(this, pre[0] || []);
		}
		return sn.apply(null, [null].concat(arrayFrom$(pre), [this.scope ? this.scope.emit(post, o.indent) : post]));
	};
	Block.prototype.compileExpressions = function(o, level){
		var lines, i, that, line, code, last, i$, len$, node;
		lines = this.chomp().lines;
		i = -1;
		while (that = lines[++i]) {
			if (that.comment) {
				lines.splice(i--, 1);
			}
		}
		if (!lines.length) {
			lines.push(Literal('void'));
		}
		lines[0].front = this.front;
		lines[lines.length - 1]['void'] = this['void'];
		if (!lines[1]) {
			line = lines[0];
			if (that = line.rewriteShorthand(o)) {
				line = that;
			}
			return line.compile(o, level);
		}
		code = [];
		last = lines.pop();
		for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
			node = lines[i$];
			if (that = node.rewriteShorthand(o)) {
				node = that;
			}
			code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
		}
		if (that = last.rewriteShorthand(o)) {
			last = that;
		}
		code.push(last.compile(o, LEVEL_PAREN));
		return level < LEVEL_LIST
			? sn.apply(null, [null].concat(arrayFrom$(code)))
			: sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
	};
	Block.prototype.rewriteShorthand = VOID;
	return Block;
}(Node));
Atom = (function(superclass){
	var prototype = extend$((import$(Atom, superclass).displayName = 'Atom', Atom), superclass).prototype, constructor = Atom;
	Atom.prototype.show = function(){
		return this.value;
	};
	Atom.prototype.isComplex = NO;
	function Atom(...args){
		Atom.superclass(...args);
	}
	return Atom;
}(Node));
exports.Literal = Literal = (function(superclass){
	var prototype = extend$((import$(Literal, superclass).displayName = 'Literal', Literal), superclass).prototype, constructor = Literal;
	function Literal(value){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.value = value;
		if (value.js) {
			return JS(value + "", true);
		}
		if (value === 'super') {
			return new Super;
		}
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Literal.prototype.isEmpty = function(){
		return this.value === 'void' || this.value === 'null';
	};
	Literal.prototype.isCallable = function(){
		var ref$;
		return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
	};
	Literal.prototype.isString = function(){
		return '\'"'.indexOf((this.value + "")[0]) >= 0;
	};
	Literal.prototype.isRegex = function(){
		return (this.value + "")[0] === '/';
	};
	Literal.prototype.isComplex = function(){
		return this.isRegex() || this.value === 'debugger';
	};
	Literal.prototype.isWhat = function(){
		switch (false) {
		case !this.isEmpty():
			return 'empty';
		case !this.isCallable():
			return 'callable';
		case !this.isString():
			return 'string';
		case !this.isRegex():
			return 'regex';
		case !this.isComplex():
			return 'complex';
		}
	};
	Literal.prototype.varName = function(){
		return /^\w+$/.test(this.value) ? '$' + this.value : '';
	};
	Literal.prototype.makeReturn = function(it){
		return !it && this.value === 'debugger' ? this : superclass.prototype.makeReturn.apply(this, arguments);
	};
	Literal.prototype.maybeKey = function(){
		return ID.test(this.value)
			? Key(this.value, this.value !== 'arguments' && this.value !== 'eval')
			: this;
	};
	Literal.prototype.compile = function(o, level){
		var val, ref$;
		level == null && (level = o.level);
		switch (val = this.value + "") {
		case 'this':
			return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
		case 'void':
			if (!level) {
				return sn(this, '');
			}
			val += ' 8';
			// fallthrough
		case 'null':
			if (level === LEVEL_CALL) {
				this.carp('invalid use of ' + this.value);
			}
			break;
		case 'on':
		case 'yes':
			val = 'true';
			break;
		case 'off':
		case 'no':
			val = 'false';
			break;
		case '*':
			this.carp('stray star');
			break;
		case '..':
			if (!(val = o.ref)) {
				this.carp('stray reference');
			}
			this.cascadee || (val.erred = true);
			break;
		case 'debugger':
			if (level) {
				return sn(this, "(function(){ debugger; }())");
			}
		}
		return sn(this, snSafe(val));
	};
	return Literal;
}(Atom));
exports.Var = Var = (function(superclass){
	var prototype = extend$((import$(Var, superclass).displayName = 'Var', Var), superclass).prototype, constructor = Var;
	function Var(value){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.value = value;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	prototype.isAssignable = prototype.isCallable = YES;
	Var.prototype.assigns = function(){
		return [this.value];
	};
	Var.prototype.maybeKey = function(){
		var ref$;
		return ref$ = Key(this.value), ref$.line = this.line, ref$;
	};
	Var.prototype.varName = prototype.show;
	Var.prototype.compile = function(o){
		return sn(this, this.temp
			? o.scope.free(this.value)
			: this.value);
	};
	return Var;
}(Atom));
exports.Key = Key = (function(superclass){
	var prototype = extend$((import$(Key, superclass).displayName = 'Key', Key), superclass).prototype, constructor = Key;
	function Key(name, reserved){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.reserved = reserved || name.reserved;
		this$.name = '' + name;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Key.prototype.isComplex = NO;
	Key.prototype.assigns = function(){
		return [this.name];
	};
	Key.prototype.maybeKey = THIS;
	Key.prototype.varName = function(){
		var name;
		name = this.name;
		if (this.reserved || (name === 'arguments' || name === 'eval')) {
			return "$" + name;
		} else {
			return name;
		}
	};
	Key.prototype.show = function(){
		return this.reserved ? "'" + this.name + "'" : this.name;
	};
	Key.prototype.compile = function(){
		return sn(this, this.show());
	};
	return Key;
}(Node));
exports.Index = Index = (function(superclass){
	var prototype = extend$((import$(Index, superclass).displayName = 'Index', Index), superclass).prototype, constructor = Index;
	function Index(key, symbol, init){
		var k, this$ = this instanceof ctor$ ? this : new ctor$;
		symbol || (symbol = '.');
		if (init && key instanceof Arr) {
			switch (key.items.length) {
			case 1:
				if (!((k = key.items[0]) instanceof Splat)) {
					key = Parens(k);
				}
			}
		}
		switch (symbol) {
		case '[]':
			this$.vivify = Arr;
			break;
		case '{}':
			this$.vivify = Obj;
			break;
		default:
			if ('=' === symbol.slice(-1)) {
				this$.assign = symbol.slice(1);
			}
		}
		this$.key = key;
		this$.symbol = symbol;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Index.prototype.children = ['key'];
	Index.prototype.show = function(){
		return [this.soak ? '?' : void 8] + this.symbol;
	};
	Index.prototype.isComplex = function(){
		return this.key.isComplex() || this.vivify != null;
	};
	Index.prototype.varName = function(){
		var ref$;
		return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) && this.key.varName();
	};
	Index.prototype.compile = function(o){
		var code;
		code = this.key.compile(o, LEVEL_PAREN);
		if (this.key instanceof Key && "'" !== code.toString().charAt(0)) {
			return sn(this, ".", code);
		} else {
			return sn(this, "[", code, "]");
		}
	};
	return Index;
}(Node));
exports.Slice = Slice = (function(superclass){
	var prototype = extend$((import$(Slice, superclass).displayName = 'Slice', Slice), superclass).prototype, constructor = Slice;
	function Slice(arg$){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
		this$.from == null && (this$.from = Literal(0));
		if (this$.to && this$.type === 'to') {
			this$.to = Binary('+', this$.to, Literal('1'));
		}
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Slice.prototype.children = ['target', 'from', 'to'];
	Slice.prototype.show = function(){
		return this.type;
	};
	Slice.prototype.compileNode = function(o){
		var args;
		if (this.to && this.type === 'to') {
			this.to = Binary('||', this.to, Literal('9e9'));
		}
		args = [this.target, this.from];
		if (this.to) {
			args.push(this.to);
		}
		return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
	};
	return Slice;
}(Node));
exports.Chain = Chain = (function(superclass){
	var prototype = extend$((import$(Chain, superclass).displayName = 'Chain', Chain), superclass).prototype, constructor = Chain;
	function Chain(head, tails){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		if (!tails && head instanceof Chain) {
			return head;
		}
		this$.head = head;
		this$.tails = tails || [];
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Chain.prototype.children = ['head', 'tails'];
	Chain.prototype.add = function(it){
		var last, ref$, index, ref1$, bi, logics, call, f;
		if (this.tails.length) {
			last = (ref$ = this.tails)[ref$.length - 1];
			if (last instanceof Call && ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 && it.args.length === 1) {
				index = last.partialized[0].head.value;
				delete last.partialized;
				last.args[index] = it.args[0];
				return this;
			}
		}
		if (this.head instanceof Existence) {
			ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
			it.soak = true;
		}
		this.tails.push(it);
		bi = this.head instanceof Parens && this.head.it instanceof Binary && !this.head.it.partial
			? this.head.it
			: this.head instanceof Binary && !this.head.partial ? this.head : void 8;
		if (this.head instanceof Super) {
			if (!this.head.called && it instanceof Call && !it.method) {
				it.method = '.call';
				it.args.unshift(Literal('this'));
				this.head.called = true;
			} else if (!this.tails[1] && ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
				this.head.sproto = true;
			}
		} else if (it instanceof Call && this.tails.length === 1 && bi && (logics = ['&&', '||', 'xor']).includes(bi.op)) {
			call = it;
			f = function(x, key){
				var y;
				y = x[key];
				if (y instanceof Binary && logics.includes(y.op)) {
					f(y, 'first');
					return f(y, 'second');
				} else {
					return x[key] = Chain(y).autoCompare(call.args);
				}
			};
			f(bi, 'first');
			f(bi, 'second');
			return bi;
		}
		return this;
	};
	Chain.prototype.autoCompare = function(target){
		var test;
		if (!this.tails.length) {
			test = this.head;
		}
		switch (false) {
		case !(test instanceof Literal):
			return Binary('===', test, target[0]);
		case !(test instanceof Unary && test.it instanceof Literal):
			return Binary('===', test, target[0]);
		case !(test instanceof Arr || test instanceof Obj):
			return Binary('====', test, target[0]);
		case !(test instanceof Var && test.value === '_'):
			return Literal('true');
		default:
			return this.add(Call(target)) || [];
		}
	};
	Chain.prototype.flipIt = function(){
		this.flip = true;
		return this;
	};
	Chain.prototype.unwrap = function(){
		return this.tails.length ? this : this.head;
	};
	prototype.delegate(['getJump', 'assigns', 'isStatement', 'isString'], function(it, arg){
		return !this.tails.length && this.head[it](arg);
	});
	Chain.prototype.isComplex = function(){
		return this.tails.length || this.head.isComplex();
	};
	Chain.prototype.isCallable = function(){
		var that, ref$;
		if (that = (ref$ = this.tails)[ref$.length - 1]) {
			return !((ref$ = that.key) != null && ref$.items);
		} else {
			return this.head.isCallable();
		}
	};
	Chain.prototype.isArray = function(){
		var that, ref$;
		if (that = (ref$ = this.tails)[ref$.length - 1]) {
			return that.key instanceof Arr;
		} else {
			return this.head.isArray();
		}
	};
	Chain.prototype.isRegex = function(){
		return this.head.value === 'RegExp' && !this.tails[1] && this.tails[0] instanceof Call;
	};
	Chain.prototype.isAssignable = function(){
		var tail, ref$, i$, len$;
		if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
			return this.head.isAssignable();
		}
		if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
			return false;
		}
		for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
			if (ref$[i$].assign) {
				return false;
			}
		}
		return true;
	};
	Chain.prototype.isSimpleAccess = function(){
		return this.tails.length === 1 && !this.head.isComplex() && !this.tails[0].isComplex();
	};
	Chain.prototype.makeReturn = function(){
		var ref$;
		if (this.tails.length) {
			return superclass.prototype.makeReturn.apply(this, arguments);
		} else {
			return (ref$ = this.head).makeReturn.apply(ref$, arguments);
		}
	};
	Chain.prototype.getCall = function(){
		var tail, ref$;
		return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call && tail;
	};
	Chain.prototype.varName = function(){
		var ref$, ref1$;
		return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
	};
	Chain.prototype.cacheReference = function(o){
		var name, ref$, base, bref, nref, key;
		name = (ref$ = this.tails)[ref$.length - 1];
		if (!this.isAssignable()) {
			return this.unwrap().cache(o, true);
		}
		if (this.tails.length < 2 && !this.head.isComplex() && !(name != null && name.isComplex())) {
			return [this, this];
		}
		base = Chain(this.head, this.tails.slice(0, -1));
		if (base.isComplex()) {
			ref$ = base.unwrap().cache(o, true), base = ref$[0], bref = ref$[1];
			base = Chain(base);
		}
		if (!name) {
			return [base, bref];
		}
		nref = name;
		if (name.symbol !== '.') {
			nref = name;
			name = Index(name.key, '.');
		}
		if (name.isComplex()) {
			ref$ = name.key.unwrap().cache(o, true, void 8, 'key'), key = ref$[0], nref.key = ref$[1];
			name = Index(key);
		}
		return [base.add(name), Chain(bref || base.head, [nref])];
	};
	Chain.prototype.compileNode = function(o){
		var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
		if (this.flip) {
			util('flip');
			util('curry');
		}
		head = this.head, tails = this.tails;
		head.front = this.front;
		head.newed = this.newed;
		if (!tails.length) {
			return head.compile(o);
		}
		if (that = this.unfoldAssign(o)) {
			return that.compile(o);
		}
		for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
			t = tails[i$];
			if (t.partialized) {
				hasPartial = true;
				break;
			}
		}
		if (hasPartial) {
			util('slice');
			pre = [];
			rest = [];
			for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
				t = tails[i$];
				broken = broken || t.partialized != null;
				if (broken) {
					rest.push(t);
				} else {
					pre.push(t);
				}
			}
			if (rest != null) {
				partial = rest[0], post = slice$.call(rest, 1);
			}
			this.tails = pre;
			context = pre.length
				? Chain(head, slice$.call(pre, 0, -1))
				: Literal('this');
			return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial.partialized)])])), post).compile(o);
		}
		if (tails[0] instanceof Call && !head.isCallable()) {
			this.carp('invalid callee');
		}
		this.expandVivify();
		this.expandBind(o);
		this.expandSplat(o);
		this.expandStar(o);
		if (this.splattedNewArgs) {
			idt = o.indent + TAB;
			func = Chain(this.head, tails.slice(0, -1));
			return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
		}
		if (!this.tails.length) {
			return this.head.compile(o);
		}
		base = [this.head.compile(o, LEVEL_CALL)];
		news = [];
		rest = [];
		for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
			t = ref$[i$];
			if (t['new']) {
				news.push('new ');
			}
			rest.push(t.compile(o));
		}
		if ('.' === rest.join("").charAt(0) && SIMPLENUM.test(base[0].toString())) {
			base.push(' ');
		}
		return sn.apply(null, [null].concat(arrayFrom$(news), arrayFrom$(base), arrayFrom$(rest)));
	};
	Chain.prototype.unfoldSoak = function(o){
		var that, ref$, i$, len$, node, ref1$, bust, test;
		if (that = this.head.unfoldSoak(o)) {
			(ref$ = that.then.tails).push.apply(ref$, this.tails);
			return that;
		}
		for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
			node = ref$[i$];
			if (ref1$ = node.soak, delete node.soak, ref1$) {
				bust = Chain(this.head, this.tails.splice(0, i$));
				if (node.assign && !bust.isAssignable()) {
					node.carp('invalid accessign');
				}
				if (i$ && (node.assign || node instanceof Call)) {
					ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
					if (bust instanceof Chain) {
						(ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
						bust = bust.head;
					}
					this.head = bust;
				} else {
					ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
				}
				test = node instanceof Call
					? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
					: Existence(test);
				return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
			}
		}
	};
	Chain.prototype.unfoldAssign = function(o){
		var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
		if (that = this.head.unfoldAssign(o)) {
			(ref$ = that.right.tails).push.apply(ref$, this.tails);
			return that;
		}
		for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
			i = i$;
			index = ref$[i$];
			if (op = index.assign) {
				index.assign = '';
				left = Chain(this.head, this.tails.splice(0, i)).unwrap();
				if (left instanceof Arr) {
					lefts = left.items;
					rites = (this.head = Arr()).items;
					for (j$ = 0, len1$ = lefts.length; j$ < len1$; ++j$) {
						i = j$;
						node = lefts[j$];
						ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
					}
				} else {
					ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
				}
				if (op === '=') {
					op = ':=';
				}
				return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
			}
		}
	};
	Chain.prototype.expandSplat = function(o){
		var tails, i, call, args, ctx, ref$;
		tails = this.tails;
		i = -1;
		while (call = tails[++i]) {
			if (!(args = call.args)) {
				continue;
			}
			ctx = call.method === '.call' && (args = args.concat()).shift();
			if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
				continue;
			}
			if (call['new']) {
				this.splattedNewArgs = args;
			} else {
				if (!ctx && tails[i - 1] instanceof Index) {
					ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
					i = 0;
				}
				call.method = '.apply';
				call.args = [ctx || Literal('null'), JS(args)];
			}
		}
	};
	Chain.prototype.expandVivify = function(){
		var tails, i, that, ref$, ref1$;
		tails = this.tails;
		i = 0;
		while (i < tails.length) {
			if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
				this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
				i = 0;
			}
		}
	};
	Chain.prototype.expandBind = function(o){
		var tails, i, that, obj, key, call;
		tails = this.tails;
		i = -1;
		while (that = tails[++i]) {
			if (that.symbol !== '.~') {
				continue;
			}
			that.symbol = '';
			obj = Chain(this.head, tails.splice(0, i)).unwrap();
			key = tails.shift().key;
			call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
			this.head = this.newed ? Parens(call, true) : call;
			i = -1;
		}
	};
	Chain.prototype.expandStar = function(o){
		var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
		tails = this.tails;
		i = -1;
		while (that = tails[++i]) {
			if (that.args || that.stars || that.key instanceof Key) {
				continue;
			}
			stars = that.stars = [];
			that.eachChild(seek);
			if (!stars.length) {
				continue;
			}
			ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
			value = Chain(ref, [Index(Key('length'))]).compile(o);
			for (i$ = 0, len$ = stars.length; i$ < len$; ++i$) {
				star = stars[i$];
				star.value = value;
				star.isAssignable = YES;
			}
			this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
			if (temps) {
				o.scope.free(temps[0]);
			}
			i = -1;
		}
		function seek(it){
			if (it.value === '*') {
				stars.push(it);
			} else if (!(it instanceof Index)) {
				it.eachChild(seek);
			}
		}
	};
	Chain.prototype.rewriteShorthand = function(o, assign){
		var that, lastI, i$, ref$, len$, i, item;
		if (that = this.unfoldSoak(o)) {
			return that.rewriteShorthand(o, assign) || that;
		}
		if (that = this.head.rewriteShorthand(o)) {
			this.head = that;
		}
		lastI = this.tails.length - 1;
		for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
			i = i$;
			item = ref$[i$];
			if (that = item.rewriteShorthand(o, assign && i === lastI)) {
				this.tails[i] = that;
			}
		}
		this.expandSlice(o, assign);
		return this.unwrap();
	};
	Chain.prototype.expandSlice = function(o, assign){
		var tails, i, tail, ref$, x;
		tails = this.tails;
		i = -1;
		while (tail = tails[++i]) {
			if ((ref$ = tail.key) != null && ref$.items) {
				if (tails[i + 1] instanceof Call) {
					tail.carp('calling a slice');
				}
				x = tails.splice(0, i + 1);
				x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
				this.head = (x.front = this.front, x);
				i = -1;
			}
		}
		return this;
	};
	Chain.prototype.extractKeyRef = function(o, assign){
		var ref$, ref1$, ref2$;
		return ((ref$ = (ref2$ = this.tails)[ref2$.length - 1]) != null ? (ref1$ = ref$.key) != null ? ref1$.extractKeyRef(o, assign) : void 8 : void 8) || superclass.prototype.extractKeyRef.apply(this, arguments);
	};
	return Chain;
}(Node));
exports.Call = Call = (function(superclass){
	var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;
	function Call(args){
		var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
		args || (args = []);
		if (args.length === 1 && (splat = args[0]) instanceof Splat) {
			if (splat.filler) {
				this$.method = '.call';
				args[0] = Literal('this');
				args[1] = Splat(Literal('arguments'));
			} else if (splat.it instanceof Arr) {
				args = splat.it.items;
			}
		} else {
			for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
				i = i$;
				a = args[i$];
				if (a.value === '_') {
					args[i] = Chain(Literal('void'));
					args[i].placeholder = true;
					((ref$ = this$.partialized) != null
						? ref$
						: this$.partialized = []).push(Chain(Literal(i)));
				}
			}
		}
		this$.args = args;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Call.prototype.children = ['args'];
	Call.prototype.show = function(){
		return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
	};
	Call.prototype.compile = function(o){
		var code, i$, ref$, len$, i, a;
		code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
		for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {
			i = i$;
			a = ref$[i$];
			code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
		}
		code.push(sn(this, ')'));
		return sn.apply(null, [null].concat(arrayFrom$(code)));
	};
	Call.make = function(callee, args, opts){
		var call;
		call = Call(args);
		if (opts) {
			import$(call, opts);
		}
		return Chain(callee).add(call);
	};
	Call.block = function(fun, args, method){
		var ref$, ref1$;
		return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
	};
	Call.back = function(params, node, bound, curried, hushed, generator){
		var fun, ref$, args, index, i$, len$;
		fun = Fun(params, void 8, bound, curried, hushed, generator);
		if (node instanceof Label) {
			fun.name = node.label;
			fun.labeled = true;
			node = node.it;
		}
		if (!fun.hushed && (fun.hushed = node.op === '!')) {
			node = node.it;
		}
		if ((ref$ = node.getCall()) != null) {
			ref$.partialized = null;
		}
		args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
		index = 0;
		for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
			if (args[i$].placeholder) {
				break;
			}
			++index;
		}
		return node.back = (args[index] = fun).body, node;
	};
	Call['let'] = function(args, body){
		var hasYield, hasAwait, params, i$, len$, a, that, gotThis;
		hasYield = false;
		hasAwait = false;
		body.traverseChildren(child => {
			if (child instanceof Yield) {
				switch (child.op) {
				case 'yield':
				case 'yieldfrom':
					hasYield = true;
					break;
				case 'await':
					hasAwait = true;
				}
			}
			if (hasYield && hasAwait) {
				return true;
			}
		});
		params = [];
		for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
			a = args[i$];
			if (that = a.op === '=' && !a.logic && a.right) {
				args[i$] = that;
				if (i$ === 0 && (gotThis = a.left.value === 'this')) {
					continue;
				}
				params.push(a.left);
			} else {
				params.push(Var(a.varName() || a.carp('invalid "let" argument')));
			}
		}
		gotThis || args.unshift(Literal('this'));
		body = this.block(Fun(params, body, null, null, null, hasYield, hasAwait), args, '.call');
		return hasYield || hasAwait
			? Block(Yield(hasYield ? 'yieldfrom' : 'await', body))
			: body;
	};
	return Call;
}(Node));
List = (function(superclass){
	var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List;
	List.prototype.children = ['items'];
	List.prototype.show = function(){
		return this.name;
	};
	List.prototype.named = function(name){
		this.name = name;
		return this;
	};
	List.prototype.isEmpty = function(){
		return !this.items.length;
	};
	List.prototype.assigns = function(){
		var x$, i$, ref$, len$, that, j$, len1$;
		x$ = [];
		for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
			if (that = ref$[i$].assigns()) {
				for (j$ = 0, len1$ = that.length; j$ < len1$; ++j$) {
					x$.push(that[j$]);
				}
			}
		}
		if (that = this.name) {
			x$.push(that);
		}
		return x$;
	};
	List.compile = function(o, items, deepEq){
		var indent, level, code, i, that, target;
		switch (items.length) {
		case 0:
			return '';
		case 1:
			return items[0].compile(o, LEVEL_LIST);
		}
		indent = o.indent, level = o.level;
		o.indent = indent + TAB;
		o.level = LEVEL_LIST;
		code = [items[i = 0].compile(o)];
		while (that = items[++i]) {
			code.push(', ');
			target = that;
			if (deepEq) {
				if (target instanceof Var && target.value === '_') {
					target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
				} else if (target instanceof Obj || target instanceof Arr) {
					target.deepEq = true;
				}
			}
			code.push(target.compile(o));
		}
		if (~code.join("").indexOf('\n')) {
			code = ["\n" + o.indent].concat(arrayFrom$(code), ["\n" + indent]);
		}
		o.indent = indent;
		o.level = level;
		return sn.apply(null, [this].concat(arrayFrom$(code)));
	};
	List.prototype.toSlice = function(o, base, symbol, assign){
		var items, isObj, ref$, ref, temps, i$, len$, i, item, val, splat, chain;
		items = this.items;
		isObj = this instanceof Obj;
		if (items.length > 1) {
			ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
		} else {
			ref = base;
		}
		for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
			i = i$;
			item = items[i$];
			if (!item.comment) {
				if (isObj) {
					val = item.val;
					if (!(val instanceof List)) {
						(val = val.maybeKey()) || this.carp("value in object slice is not a key");
					}
				} else {
					val = item;
					if (splat = val instanceof Splat) {
						val = val.it;
					}
					if (val.isEmpty()) {
						continue;
					}
				}
				chain = val instanceof List
					? val.toSlice(o, base, symbol, assign)
					: Chain(base, [Index(val, symbol)]);
				if (isObj) {
					item.val = chain;
				} else {
					items[i] = splat ? Splat(chain) : chain;
				}
				base = ref;
			}
		}
		chain || this.carp('empty slice');
		if (temps) {
			(this.temps || (this.temps = [])).push(temps[0]);
		}
		return this;
	};
	List.prototype.extractKeyRef = function(){
		return this.name != null ? key(this.name) : superclass.prototype.extractKeyRef.apply(this, arguments);
	};
	function List(){
		List.superclass.apply(this, arguments);
	}
	return List;
}(Node));
exports.Obj = Obj = (function(superclass){
	var prototype = extend$((import$(Obj, superclass).displayName = 'Obj', Obj), superclass).prototype, constructor = Obj;
	function Obj(items){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.items = items || [];
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Obj.prototype.asObj = THIS;
	Obj.prototype.compileNode = function(o){
		var items, code, idt, dic, i$, len$, node, ref$, rest, multi, key, val;
		if (this.name != null) {
			this.carp("unexpected label");
		}
		items = this.items;
		if (!items.length) {
			return sn(this, this.front ? '({})' : '{}');
		}
		code = [];
		idt = '\n' + (o.indent += TAB);
		dic = {};
		for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
			node = items[i$];
			if (node.comment) {
				code.push(idt, node.compile(o));
				continue;
			}
			if ((ref$ = node.key) instanceof Splat || ref$ instanceof Parens) {
				rest = items.slice(i$);
				break;
			}
			if (node.logic) {
				node.val = (ref$ = node.logic, ref$.first = node.val, ref$);
			}
			if (this.deepEq) {
				if (node.val instanceof Var && node.val.value === '_') {
					node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
				} else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
					node.val.deepEq = true;
				}
			}
			if (multi) {
				code.push(',');
			} else {
				multi = true;
			}
			code.push(idt);
			key = node.key, val = node.val;
			if (node.accessor) {
				code.push(node.compileAccessor(o, key = key.compile(o)));
			} else {
				val.ripName(key);
				code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
			}
			ID.test(key) || (key = Function("return " + key)());
			if (!(dic[key + "."] ^= 1)) {
				node.carp("duplicate property \"" + key + "\"");
			}
		}
		if (code.join("")) {
			code.push('\n' + this.tab);
		}
		code = sn.apply(null, [null, sn(this, "{")].concat(arrayFrom$(code), [sn(this, "}")]));
		rest && (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
		if (this.front && '{' === code.toString().charAt()) {
			return sn(null, "(", code, ")");
		} else {
			return code;
		}
	};
	return Obj;
}(List));
exports.Prop = Prop = (function(superclass){
	var prototype = extend$((import$(Prop, superclass).displayName = 'Prop', Prop), superclass).prototype, constructor = Prop;
	function Prop(key, val){
		var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
		this$.key = key;
		this$.val = val;
		if ((key != null ? key.value : void 8) === '...') {
			this$.key = Splat();
		}
		if (that = val.getAccessors()) {
			this$.val = that;
			for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
				fun = that[i$];
				fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
			}
			this$['accessor'] = 'accessor';
		}
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Prop.prototype.children = ['key', 'val', 'logic'];
	Prop.prototype.show = function(){
		return this.accessor;
	};
	Prop.prototype.assigns = function(){
		var ref$;
		return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns() : void 8;
	};
	Prop.prototype.compileAccessor = function(o, key){
		var funs, code, i$, len$, fun;
		funs = this.val;
		if (funs[1] && funs[0].params.length + funs[1].params.length !== 1) {
			funs[0].carp('invalid accessor parameter');
		}
		code = [];
		for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
			fun = funs[i$];
			fun.accessor = true;
			code.push(fun.x, "et ", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\n' + o.indent);
		}
		code.pop();
		return sn.apply(null, [null].concat(arrayFrom$(code)));
	};
	Prop.prototype.compileDescriptor = function(o){
		var obj, i$, ref$, len$, fun;
		obj = Obj();
		for (i$ = 0, len$ = (ref$ = this.val).length; i$ < len$; ++i$) {
			fun = ref$[i$];
			obj.items.push(Prop(Key(fun.x + 'et'), fun));
		}
		obj.items.push(Prop(Key('configurable'), Literal(true)), Prop(Key('enumerable'), Literal(true)));
		return obj.compile(o);
	};
	Prop.prototype.rewriteShorthand = function(o, assign){
		var ref$, that;
		superclass.prototype.rewriteShorthand.apply(this, arguments);
		if (this.key == null && this.val instanceof Assign) {
			this.val = this.val.maybeLogic();
		}
		if (this.key == null && this.val instanceof Unary && ((ref$ = this.val.op) === '+' || ref$ === '-')) {
			this.key = this.val.it.maybeKey() || this.carp("invalid property flag shorthand");
			this.val = Literal(this.val.op === '+');
		}
		if (that = this.val instanceof Binary && this.val.getDefault()) {
			this.val = this.val.first;
			this.logic = (that.first = null, that);
		}
		this.key == null && (this.key = this.val.extractKeyRef(o, assign));
	};
	return Prop;
}(Node));
exports.Arr = Arr = (function(superclass){
	var prototype = extend$((import$(Arr, superclass).displayName = 'Arr', Arr), superclass).prototype, constructor = Arr;
	function Arr(items){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.items = items || [];
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Arr.prototype.isArray = YES;
	Arr.prototype.asObj = function(){
		return Obj(this.items.map((item, i) => Prop(Literal(i), item)))
	};
	Arr.prototype.compile = function(o){
		var items, code;
		if (this.name != null) {
			this.carp("unexpected label");
		}
		items = this.items;
		if (!items.length) {
			return sn(this, '[]');
		}
		if (!snEmpty(code = Splat.compileArray(o, items))) {
			return this.newed ? sn(this, "(", code, ")") : sn(this, code);
		}
		return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
	};
	Arr.maybe = function(nodes){
		if (nodes.length === 1 && !(nodes[0] instanceof Splat)) {
			return nodes[0];
		}
		return constructor(nodes);
	};
	Arr.wrap = function(it){
		return constructor([Splat((it.isArray = YES, it))]);
	};
	return Arr;
}(List));
exports.Yield = Yield = (function(superclass){
	var prototype = extend$((import$(Yield, superclass).displayName = 'Yield', Yield), superclass).prototype, constructor = Yield;
	function Yield(op, it){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.op = op;
		this$.it = it;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Yield.prototype.children = ['it'];
	Yield.prototype.show = function(){
		switch (this.op) {
		case 'yield':
			return '';
		case 'yieldfrom':
			return 'from';
		case 'await':
			return 'await';
		}
	};
	prototype.delegate(['isCallable'], function(){
		return true;
	});
	Yield.prototype.compileNode = function(o){
		var code;
		code = [(() => {
			switch (this.op) {
			case 'yield':
				return 'yield';
			case 'yieldfrom':
				return 'yield*';
			case 'await':
				return 'await';
			}
		})()];
		if (this.it) {
			code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
		}
		return sn(this, "(", ...code, ")");
	};
	return Yield;
}(Node));
exports.Unary = Unary = (function(superclass){
	var prototype = extend$((import$(Unary, superclass).displayName = 'Unary', Unary), superclass).prototype, constructor = Unary;
	function Unary(op, it, flag){
		var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
		if (it != null) {
			if (that = !flag && it.unaries) {
				that.push(op);
				return it;
			}
			switch (op) {
			case '!':
				if (flag) {
					break;
				}
				if (it instanceof Fun && !it.hushed) {
					return it.hushed = true, it;
				}
				return it.invert();
			case '++':
			case '--':
				if (flag) {
					this$.post = true;
				}
				break;
			case 'new':
				if (it instanceof Existence && !it.negated) {
					it = Chain(it).add(Call());
				}
				it.newed = true;
				for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ < len$; ++i$) {
					node = ref$[i$];
					if (node instanceof Call && !node['new']) {
						if (node.method === '.call') {
							node.args.shift();
						}
						node['new'] = 'new';
						node.method = '';
						return it;
					}
				}
				break;
			case '~':
				if (it instanceof Fun && it.statement && !it.bound) {
					return it.bound = 'this$', it;
				}
				break;
			case 'do':
				if (it instanceof Existence && !it.negated) {
					return Chain(it).add(Call());
				}
			}
		}
		this$.op = op;
		this$.it = it;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Unary.prototype.children = ['it'];
	Unary.prototype.show = function(){
		return [this.post ? '@' : void 8] + this.op;
	};
	Unary.prototype.isCallable = function(){
		var ref$;
		return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
	};
	Unary.prototype.isArray = function(){
		return this.it instanceof Arr && this.it.items.length || this.it instanceof Chain && this.it.isArray();
	};
	Unary.prototype.isString = function(){
		return this.op === 'typeof' || this.op === 'classof';
	};
	Unary.prototype.invert = function(){
		var ref$;
		if (this.op === '!' && ((ref$ = this.it.op) === '!' || ref$ === '<' || ref$ === '>' || ref$ === '<=' || ref$ === '>=' || ref$ === 'of' || ref$ === 'instanceof')) {
			return this.it;
		}
		return constructor('!', this, true);
	};
	Unary.prototype.unfoldSoak = function(o){
		var ref$;
		return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete' || ref$ === 'jsdelete') && this.it != null && If.unfoldSoak(o, this, 'it');
	};
	Unary.prototype.getAccessors = function(){
		var items;
		if (this.op !== '~') {
			return;
		}
		if (this.it instanceof Fun) {
			return [this.it];
		}
		if (this.it instanceof Arr) {
			items = this.it.items;
			if (!items[2] && items[0] instanceof Fun && items[1] instanceof Fun) {
				return items;
			}
		}
	};
	function crement(it){
		return {
			'++': 'in',
			'--': 'de'
		}[it] + 'crement';
	}
	Unary.prototype.compileNode = function(o){
		var that, op, it, x, code;
		if (this.it == null) {
			return this.compileAsFunc(o);
		}
		if (that = this.compileSpread(o)) {
			return that;
		}
		op = this.op, it = this.it;
		switch (op) {
		case '!':
			it.cond = true;
			break;
		case 'new':
			it.isCallable() || it.carp('invalid constructor');
			break;
		case 'do':
			if (o.level === LEVEL_TOP && it instanceof Fun && it.isStatement()) {
				return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
			}
			x = Parens(Call.make(it));
			return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
		case 'delete':
			if (it instanceof Var || !it.isAssignable()) {
				this.carp('invalid delete');
			}
			if (o.level && !this['void']) {
				return this.compilePluck(o);
			}
			break;
		case '++':
		case '--':
			it.isAssignable() || this.carp('invalid ' + crement(op));
			if (that = it instanceof Var && o.scope.checkReadOnly(it.value)) {
				this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
			}
			if (this.post) {
				it.front = this.front;
			}
			break;
		case '^^':
			return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
		case 'jsdelete':
			return sn(this, "delete ", it.compile(o, LEVEL_LIST));
		case 'classof':
			return sn(this, util('toString'), ".call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
		}
		code = [it.compile(o, LEVEL_OP + PREC.unary)];
		if (this.post) {
			code.push(op);
		} else {
			if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') && op === code.join("").charAt()) {
				op += ' ';
			}
			code.unshift(op);
		}
		if (o.level < LEVEL_CALL) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Unary.prototype.compileSpread = function(o){
		var it, ops;
		it = this.it;
		ops = [this];
		for (; it instanceof constructor; it = it.it) {
			ops.push(it);
		}
		if (!(it instanceof Splat && (it = it.it) instanceof List)) {
			return '';
		}
		return this.compileSpreadOver(o, it, function(node){
			var i$, ref$, op;
			for (i$ = (ref$ = ops).length - 1; i$ >= 0; --i$) {
				op = ref$[i$];
				node = constructor(op.op, node, op.post);
			}
			return node.unfoldSoak(o) || node;
		});
	};
	Unary.prototype.compilePluck = function(o){
		var ref$, get, del, code, ref;
		ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
		code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free(ref)];
		if (o.level < LEVEL_LIST) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Unary.prototype.compileAsFunc = function(o){
		if (this.op === '!') {
			return sn(this, util('not'));
		} else {
			return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
		}
	};
	Unary.prototype.rewriteShorthand = function(o, assign){
		var that, ref$;
		if (that = this.unfoldSoak(o)) {
			return that.rewriteShorthand(o, assign) || that;
		}
		return superclass.prototype.rewriteShorthand.call(this, o, assign || ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete' || ref$ === 'jsdelete'));
	};
	return Unary;
}(Node));
exports.Binary = Binary = (function(superclass){
	var COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = 'Binary', Binary), superclass).prototype, constructor = Binary;
	function Binary(op, first, second){
		var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
		this$.partial = first == null || second == null;
		if (!this$.partial) {
			if ('=' === op.charAt(op.length - 1) && ((ref$ = op.charAt(op.length - 2)) !== '=' && ref$ !== '<' && ref$ !== '>' && ref$ !== '!')) {
				return Assign(first.unwrap(), second, op);
			}
			switch (op) {
			case 'in':
				return new In(first, second);
			case 'with':
				return new Import(Unary('^^', first), second, false);
			case '<<<':
			case '<<<<':
				return Import(first, second, op === '<<<<');
			case '<|':
				return Block(first).pipe(second, op);
			case '|>':
				return Block(second).pipe(first, '<|');
			case '.':
			case '.~':
				return Chain(first).add(Index(second, op));
			}
		}
		this$.op = op;
		this$.first = first;
		this$.second = second;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Binary.prototype.children = ['first', 'second'];
	Binary.prototype.show = function(){
		return this.op;
	};
	Binary.prototype.isCallable = function(){
		var ref$;
		return this.partial || ((ref$ = this.op) === '&&' || ref$ === '||' || ref$ === '?' || ref$ === '<<' || ref$ === '>>') && this.first.isCallable() && this.second.isCallable();
	};
	Binary.prototype.isArray = function(){
		switch (this.op) {
		case '*':
			return this.first.isArray();
		case '/':
			return this.second.isMatcher();
		}
	};
	Binary.prototype.isString = function(){
		switch (this.op) {
		case '+':
		case '*':
			return this.first.isString() || this.second.isString();
		case '-':
			return this.second.isMatcher();
		}
	};
	COMPARER = /^(?:[!=]=|[<>])=?$/;
	INVERSIONS = {
		'===': '!==',
		'!==': '===',
		'==': '!=',
		'!=': '=='
	};
	Binary.prototype.invert = function(){
		var that;
		if (that = !COMPARER.test(this.second.op) && INVERSIONS[this.op]) {
			this.op = that;
			this.wasInverted = true;
			return this;
		}
		return Unary('!', Parens(this), true);
	};
	Binary.prototype.invertIt = function(){
		this.inverted = true;
		return this;
	};
	Binary.prototype.getDefault = function(){
		switch (this.op) {
		case '?':
		case '||':
		case '&&':
			return this;
		}
	};
	Binary.prototype.assigns = function(){
		var ref$;
		return (ref$ = this.getDefault()) != null ? ref$.first.assigns() : void 8;
	};
	Binary.prototype.xorChildren = function(test){
		var ref$, first;
		if (!(!(first = test(this.first)) !== !(ref$ = test(this.second)) && (first || ref$))) {
			return false;
		}
		return first
			? [this.first, this.second]
			: [this.second, this.first];
	};
	Binary.prototype.compileNode = function(o){
		var top, rite, items, that, ref$, code, level;
		if (this.partial) {
			return this.compilePartial(o);
		}
		switch (this.op) {
		case '?':
			return this.compileExistence(o);
		case '*':
			if (this.second.isString()) {
				return this.compileJoin(o);
			}
			if (this.first.isString() || this.first.isArray()) {
				return this.compileRepeat(o);
			}
			break;
		case '-':
			if (this.second.isMatcher()) {
				return this.compileRemove(o);
			}
			break;
		case '/':
			if (this.second.isMatcher()) {
				return this.compileSplit(o);
			}
			break;
		case '**':
		case '^':
			return this.compilePow(o);
		case '<?':
		case '>?':
			return this.compileMinMax(o);
		case '<<':
		case '>>':
			return this.compileCompose(o);
		case '++':
			return this.compileConcat(o);
		case '%%':
			return this.compileMod(o);
		case 'xor':
			return this.compileXor(o);
		case '&&':
		case '||':
			if (top = this['void'] || !o.level) {
				this.second['void'] = true;
			}
			if (top || this.cond) {
				this.first.cond = true;
				this.second.cond = true;
			}
			break;
		case 'instanceof':
			rite = this.second, items = rite.items;
			if (rite instanceof Arr) {
				if (items[1]) {
					return this.compileAnyInstanceOf(o, items);
				}
				this.second = items[0] || rite;
			}
			this.second.isCallable() || this.second.carp('invalid instanceof operand');
			break;
		case '====':
		case '!===':
			this.op = this.op.slice(0, 3);
			// fallthrough
		case '<==':
		case '>==':
		case '<<=':
		case '>>=':
			return this.compileDeepEq(o);
		default:
			if (COMPARER.test(this.op)) {
				if (that = ((ref$ = this.op) === '===' || ref$ === '!==') && this.xorChildren(function(it){
					return it.isRegex();
				})) {
					return this.compileRegexEquals(o, that);
				}
				if (this.op === '===' && (this.first instanceof Literal && this.second instanceof Literal) && this.first.isWhat() !== this.second.isWhat()) {
					if (o.warn) {
						this.warn("strict comparison of two different types will always be false: " + this.first.value + " == " + this.second.value);
					}
				}
			}
			if (COMPARER.test(this.op) && COMPARER.test(this.second.op)) {
				return this.compileChain(o);
			}
		}
		this.first.front = this.front;
		code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
		if (o.level <= level) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Binary.prototype.mapOp = function(op){
		var that;
		switch (false) {
		case !(that = op.match(/\.([&\|\^]|<<|>>>?)\./)):
			return that[1];
		case op !== 'of':
			return 'in';
		default:
			return op;
		}
	};
	Binary.prototype.compileChain = function(o){
		var code, level, ref$, sub;
		code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
		ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
		code.push(" ", this.op, " ", sub.compile(o, level), " && ", this.second.compile(o, LEVEL_OP));
		if (o.level <= LEVEL_OP) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Binary.prototype.compileExistence = function(o){
		var x;
		if (this['void'] || !o.level) {
			x = Binary('&&', Existence(this.first, true), Parens(this.second.unwrap()));
			return (x['void'] = true, x).compileNode(o);
		}
		x = this.first.cache(o, true);
		return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
	};
	Binary.prototype.compileAnyInstanceOf = function(o, items){
		var ref$, sub, ref, test, i$, len$, item;
		ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
		test = Binary('instanceof', sub, items.shift());
		for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
			item = items[i$];
			test = Binary('||', test, Binary('instanceof', ref, item));
		}
		return sn(this, Parens(test).compile(o));
	};
	Binary.prototype.compileMinMax = function(o){
		var lefts, rites, x;
		lefts = this.first.cache(o, true);
		rites = this.second.cache(o, true);
		x = Binary(this.op.charAt(), lefts[0], rites[0]);
		return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
	};
	Binary.prototype.compileMethod = function(o, klass, method, arg){
		var args;
		args = [this.second].concat(arg || []);
		if (this.first["is" + klass]()) {
			return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
		} else {
			args.unshift(this.first);
			return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
		}
	};
	Binary.prototype.compileJoin = function(it){
		return this.compileMethod(it, 'Array', 'join');
	};
	Binary.prototype.compileRemove = function(it){
		return this.compileMethod(it, 'String', 'replace', JS("''"));
	};
	Binary.prototype.compileSplit = function(it){
		return this.compileMethod(it, 'String', 'split');
	};
	Binary.prototype.compileRepeat = function(o){
		var x, items, n, arr, arrCode, refs, i$, len$, i, item, ref$, q;
		x = this.first, items = x.items, n = this.second;
		arr = x.isArray() && 'Array';
		if (items && !snEmpty(arrCode = Splat.compileArray(o, items))) {
			x = JS(arrCode);
			items = null;
		}
		if (arr && !items || !(n instanceof Literal && n.value < 2)) {
			return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
		}
		n = +n.value;
		if (1 <= n && n < 2) {
			return sn(this, x.compile(o));
		}
		if (items) {
			if (n < 1) {
				return sn(this, Block(items).add(JS('[]')).compile(o));
			}
			refs = [];
			for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
				i = i$;
				item = items[i$];
				ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
			}
			items.push((ref$ = JS(), ref$.compile = function(){
				return sn.apply(null, [this].concat(arrayFrom$((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
			}, ref$));
			return sn(this, x.compile(o));
		} else if (x instanceof Literal) {
			return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
		} else {
			if (n < 1) {
				return sn(this, Block(x.it).add(JS("''")).compile(o));
			}
			x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
			if (o.level < LEVEL_OP + PREC['+']) {
				return sn(this, x);
			} else {
				return sn(this, "(", x, ")");
			}
		}
	};
	Binary.prototype.compilePow = function(o){
		return sn(null, this.first.compile(o), ' ** ', this.second.compile(o));
	};
	Binary.prototype.compileConcat = function(o){
		var f;
		f = function(x){
			switch (false) {
			case !(x instanceof Binary && x.op === '++'):
				return f(x.first).concat(f(x.second));
			default:
				return [x];
			}
		};
		return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
	};
	Binary.prototype.compileCompose = function(o){
		var op, functions, x;
		op = this.op;
		functions = [this.first];
		x = this.second;
		while (x instanceof Binary && x.op === op && !x.partial) {
			functions.push(x.first);
			x = x.second;
		}
		functions.push(x);
		if (op === '<<') {
			functions.reverse();
		}
		return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
	};
	Binary.prototype.compileMod = function(o){
		var ref, code;
		ref = o.scope.temporary();
		code = [sn(this, "(("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ", ref, ") % ", ref)];
		o.scope.free(ref);
		if (o.level < LEVEL_OP + PREC['%']) {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Binary.prototype.compilePartial = function(o){
		var vit, x, y;
		vit = Var('it');
		switch (false) {
		case !(this.first == null && this.second == null):
			x = Var('x$');
			y = Var('y$');
			return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
		case this.first == null:
			return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
		default:
			return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
		}
	};
	Binary.prototype.compileRegexEquals = function(o, arg$){
		var regex, target, method;
		regex = arg$[0], target = arg$[1];
		if (this.op === '===') {
			method = this.wasInverted ? 'test' : 'exec';
			return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
		} else {
			return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
		}
	};
	Binary.prototype.compileDeepEq = function(o){
		var ref$, negate, i$, len$, x, r;
		if ((ref$ = this.op) === '>==' || ref$ === '>>=') {
			ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
			this.op = this.op === '>==' ? '<==' : '<<=';
		}
		if (this.op === '!==') {
			this.op = '===';
			negate = true;
		}
		for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ < len$; ++i$) {
			x = ref$[i$];
			if (x instanceof Obj || x instanceof Arr) {
				x.deepEq = true;
			}
		}
		r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
		return sn(this, (negate ? Unary('!', r) : r).compile(o));
	};
	Binary.prototype.compileXor = function(o){
		var left, right;
		left = Chain(this.first).cacheReference(o);
		right = Chain(this.second).cacheReference(o);
		return sn(this, Binary('&&', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).compile(o));
	};
	Binary.prototype.rewriteShorthand = function(o, assign){
		var that;
		if (this.partial) {
			return superclass.prototype.rewriteShorthand.apply(this, arguments);
		}
		if (that = this.first.rewriteShorthand(o, assign)) {
			this.first = that;
		}
		if (that = this.second.rewriteShorthand(o)) {
			this.second = that;
		}
	};
	return Binary;
}(Node));
exports.Assign = Assign = (function(superclass){
	var prototype = extend$((import$(Assign, superclass).displayName = 'Assign', Assign), superclass).prototype, constructor = Assign;
	function Assign(left, rite, op, logic, defParam){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.left = left;
		this$.op = op || '=';
		this$.logic = logic || this$.op.logic;
		this$.defParam = defParam;
		this$.opLoc = this$.op;
		this$.op += '';
		this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Assign.prototype.children = ['left', 'right'];
	Assign.prototype.show = function(){
		return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
	};
	Assign.prototype.assigns = function(){
		return this.left.assigns();
	};
	Assign.prototype.getRef = function(){
		if (!this.left.isComplex()) {
			return this.left;
		}
	};
	prototype.delegate(['isCallable', 'isRegex'], function(it){
		var ref$;
		return ((ref$ = this.op) === '=' || ref$ === ':=') && this.right && this.right[it]();
	});
	Assign.prototype.isArray = function(){
		switch (this.op) {
		case '=':
		case ':=':
			return this.right && this.right.isArray();
		case '/=':
			return this.right && this.right.isMatcher();
		}
	};
	Assign.prototype.isString = function(){
		switch (this.op) {
		case '=':
		case ':=':
		case '+=':
		case '*=':
			return this.right && this.right.isString();
		case '-=':
			return this.right && this.right.isMatcher();
		}
	};
	Assign.prototype.unfoldSoak = function(o){
		var that, ref$, ref1$, rite, temps;
		if (this.left instanceof Existence) {
			if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
				rite = this.right;
				rite = Assign(this.right = Var(that), rite);
			} else {
				ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
			}
			return ref$ = If(Existence(rite), this), ref$.soak = true, ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
		}
		return If.unfoldSoak(o, this, 'left');
	};
	Assign.prototype.unfoldAssign = function(){
		return this.access && this;
	};
	Assign.prototype.compileNode = function(o){
		var that, left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, protoSplit, dotSplit, code, empty, res;
		if (that = this.unfoldSoak(o)) {
			return that.compile(o);
		}
		if (this.left instanceof Slice && this.op === '=') {
			return this.compileSplice(o);
		}
		left = this.left;
		if (sp = this.left instanceof Splat) {
			left = left.it;
		}
		if (sp) {
			left instanceof List || this.left.carp('invalid splat');
			return this.compileSpread(o, left);
		}
		if (!this.right) {
			left.isAssignable() || left.carp('invalid unary assign');
			ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
			for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ < len$; ++i$) {
				op = ref$[i$];
				this.right = Unary(op, this.right);
			}
		}
		if (left.isEmpty()) {
			return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
		}
		if (left.getDefault()) {
			this.right = Binary(left.op, this.right, left.second);
			left = left.first;
		}
		if (left.soak) {
			this.left = left.then;
			left.then = this;
			return left.compile(o);
		}
		if (left.items) {
			return this.compileDestructuring(o, left);
		}
		left.isAssignable() || left.carp('invalid assign');
		if (this.logic) {
			return this.compileConditional(o, left);
		}
		op = this.op, right = this.right;
		if (op === '<?=' || op === '>?=') {
			return this.compileMinMax(o, left, right);
		}
		if ((op === '**=' || op === '^=' || op === '//=' || op === '%%=' || op === '++=' || op === '|>=') || op === '*=' && right.isString() || (op === '-=' || op === '/=') && right.isMatcher()) {
			ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
			right = Binary(op.slice(0, -1), reft, right);
			op = ':=';
		}
		if (op === '.&.=' || op === '.|.=' || op === '.^.=' || op === '.<<.=' || op === '.>>.=' || op === '.>>>.=') {
			op = op.slice(1, -2) + '=';
		}
		(right = right.unparen()).ripName(left = left.unwrap());
		if (left instanceof Chain) {
			left.expandVivify();
			if ((left = left.unwrap()) instanceof Assign) {
				ref$ = Chain(left.left).cacheReference(o), left.left = ref$[0], this.left = ref$[1];
				return Block([left, (ref$ = clone$(this), ref$.terminator = '', ref$)]).compile(o);
			}
		}
		sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
		name = (left.front = true, left).compile(o, LEVEL_LIST);
		if (lvar = left instanceof Var) {
			if (op === '=') {
				o.scope.declare(name.toString(), left, this['const'] || !this.defParam && o['const'] && '$' !== name.toString().slice(-1));
			} else if (that = o.scope.checkReadOnly(name.toString())) {
				left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
			}
		}
		if (left instanceof Chain && right instanceof Fun) {
			protoSplit = name.toString().split('.prototype.');
			dotSplit = name.toString().split('.');
			if (protoSplit.length > 1) {
				right.inClass = protoSplit[0];
			} else if (dotSplit.length > 1) {
				right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
			}
		}
		code = !o.level && right instanceof While && !right['else'] && (lvar || left instanceof Chain && left.isSimpleAccess())
			? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
			: [name, sign, right.compile(o, LEVEL_LIST)];
		if (o.level > LEVEL_LIST) {
			code = ["("].concat(arrayFrom$(code), [")"]);
		}
		return sn.apply(null, [null].concat(arrayFrom$(code)));
	};
	Assign.prototype.compileConditional = function(o, left){
		var ref$, lcache, morph;
		if (left instanceof Var && this.logic === '?' && this.op === '=') {
			o.scope.declare(left.value, left);
		}
		ref$ = Chain(left).cacheReference(o), lcache = ref$[0], left = ref$[1];
		o.level += LEVEL_OP < o.level;
		if (this.logic === '?' && ((ref$ = this.op) !== '=' && ref$ !== ':=')) {
			this.logic = '&&';
			lcache = Existence(lcache);
		}
		morph = Binary(this.logic, lcache, (this.logic = false, this.left = left, this));
		return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
	};
	Assign.prototype.compileMinMax = function(o, left, right){
		var lefts, rites, test, put, ref$;
		lefts = Chain(left).cacheReference(o);
		rites = right.cache(o, true);
		test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
		put = Assign(lefts[1], rites[1], ':=');
		if (this['void'] || !o.level) {
			return Parens(Binary('||', test, put)).compile(o);
		}
		ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
		return sn(this, If(test, left).addElse(put).compileExpression(o));
	};
	Assign.prototype.compileDestructuring = function(o, left){
		var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
		items = left.items, len = items.length;
		ret = o.level && !this['void'];
		rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
		if (that = left.name) {
			cache = sn(this, that, " = ", rite);
			o.scope.declare(rite = that, left);
		} else if ((ret || len > 1) && (!ID.test(rite.toString()) || ((that = left.assigns()) && that.includes(rite.toString())))) {
			cache = sn(this, rref = o.scope.temporary(), " = ", rite);
			rite = rref;
		}
		if (rite.toString() === 'arguments' && !ret) {
			destructureArgs = true;
			if (!(left instanceof Arr)) {
				this.carp('arguments can only destructure to array');
			}
		}
		list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
		if (rref) {
			o.scope.free(rref);
		}
		if (cache) {
			list.unshift(cache);
		}
		if (ret || !list.length) {
			list.push(rite);
		}
		code = [];
		sep = destructureArgs ? '; ' : ', ';
		for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
			item = list[i$];
			code.push(item, sep);
		}
		code.pop();
		if ((o.level < LEVEL_OP && list.length < 2) || o.level < LEVEL_LIST) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Assign.prototype.compileSplice = function(o){
		var ref$, fromExpNode, fromExp, rightNode, right, toExp;
		ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
		ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
		toExp = Binary('-', this.left.to, fromExp);
		return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
	};
	Assign.prototype.compileSpread = function(o, left){
		var that, ref$, rite, rref, this$ = this;
		ref$ = (that = this.unaries)
			? [that, that]
			: left.items.length <= 1
				? [ref$ = this.right, ref$]
				: this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
		return this.compileSpreadOver(o, left, function(it){
			var result;
			result = constructor(it, rite, this$.op, this$.logic);
			rite = rref;
			return result;
		});
	};
	Assign.prototype.rendArr = function(o, nodes, rite, destructureArgs){
		var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$;
		function argsSlice(begin, end){
			return new For({
				ref: true,
				from: begin,
				op: 'til',
				to: end
			}).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
		}
		ret = [];
		for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
			i = i$;
			node = nodes[i$];
			if (node.isEmpty()) {
				continue;
			}
			if (node instanceof Splat) {
				len && node.carp('multiple splat in an assignment');
				skip = (node = node.it).isEmpty();
				if (i + 1 === (len = nodes.length)) {
					if (skip) {
						break;
					}
					if (destructureArgs) {
						val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
					} else {
						val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
					}
				} else {
					val = ivar = rite + ".length - " + (len - i - 1);
					if (skip && i + 2 === len) {
						continue;
					}
					start = i + 1;
					(this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
					val = (fn$());
				}
			} else {
				(inc = ivar) && start < i && (inc += " + " + (i - start));
				val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
			}
			if (destructureArgs) {
				if (!(node instanceof Var) && val instanceof For) {
					(this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
					vtmp = Var(tmp);
					ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
					ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
				} else {
					ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
				}
			} else {
				ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
			}
		}
		return ret;
		function fn$(){
			switch (false) {
			case !skip:
				return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
			case !destructureArgs:
				return argsSlice(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
			default:
				return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
			}
		}
	};
	Assign.prototype.rendObj = function(o, nodes, rite){
		var keys, pairs, rvar, i$, len$, ref$, key, lval, logic, excludes, val, left, right, results$ = [];
		keys = [];
		pairs = [];
		rvar = Var(rite);
		for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
			ref$ = nodes[i$], key = ref$.key, lval = ref$.val, logic = ref$.logic;
			lval = lval.unparen();
			if (key instanceof Splat) {
				logic != null && this.carp("invalid assign");
				excludes = Obj((fn$.call(this)));
				val = Chain(Var(util('copyWithout'))).add(Call([rvar, excludes]));
			} else {
				keys.push(key);
				if (logic) {
					lval = (logic.first = lval, logic);
				}
				val = Chain(rvar, [Index(key)]);
			}
			pairs.push([lval, val]);
		}
		for (i$ = 0, len$ = pairs.length; i$ < len$; ++i$) {
			ref$ = pairs[i$], left = ref$[0], right = ref$[1];
			results$.push((ref$ = clone$(this), ref$.left = left, ref$.right = right, ref$['void'] = true, ref$.temps = [], ref$).compile(o, LEVEL_PAREN));
		}
		return results$;
		function fn$(){
			var i$, x$, ref$, len$, results$ = [];
			for (i$ = 0, len$ = (ref$ = keys).length; i$ < len$; ++i$) {
				x$ = ref$[i$];
				results$.push(Prop(x$.extractKeyRef(o, true, this), Literal(0)));
			}
			return results$;
		}
	};
	Assign.prototype.rewriteShorthand = function(o, assign){
		var bin, ref$, that, ref1$;
		if (assign) {
			if (this === (bin = this.maybeLogic())) {
				this.carp("invalid assign");
			}
			return (ref$ = bin.rewriteShorthand(o, true)) != null ? ref$ : bin;
		}
		if (that = this.unfoldSoak(o)) {
			return that.rewriteShorthand(o, assign) || that;
		}
		if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, true) : void 8) {
			this.left = that;
		}
		if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
			this.right = that;
		}
	};
	Assign.prototype.maybeLogic = function(){
		if (this.op === '=') {
			return Binary(this.logic || '?', this.left, this.right);
		} else {
			return this;
		}
	};
	return Assign;
}(Node));
exports.Import = Import = (function(superclass){
	var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor = Import;
	function Import(left, right, all){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.left = left;
		this$.right = right;
		this$.all = all && 'All';
		if (!all && left instanceof Obj && right.items) {
			return Obj(left.items.concat(right.asObj().items));
		}
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Import.prototype.children = ['left', 'right'];
	Import.prototype.show = function(){
		return this.all;
	};
	prototype.delegate(['isCallable', 'isArray'], function(it){
		return this.left[it]();
	});
	Import.prototype.unfoldSoak = function(o){
		var left, value, ref$, temps;
		left = this.left;
		if (left instanceof Existence && !left.negated) {
			if ((left = left.it) instanceof Var) {
				value = (this.left = left).value;
				if (!o.scope.check(value, true)) {
					left = JS("typeof " + value + " != 'undefined' && " + value);
				}
			} else {
				ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
			}
			return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
		}
		return If.unfoldSoak(o, this, 'left') || this['void'] && If.unfoldSoak(o, this, 'right');
	};
	Import.prototype.compileNode = function(o){
		var right;
		right = this.right;
		if (!this.all) {
			if (right instanceof Chain) {
				right = right.unfoldSoak(o) || right.unfoldAssign(o) || right;
			}
			if (right instanceof List) {
				return this.compileAssign(o, right.asObj().items);
			}
		}
		return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
	};
	Import.prototype.compileAssign = function(o, items){
		var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, key, val, logic;
		if (!items.length) {
			return this.left.compile(o);
		}
		top = !o.level;
		if (this.proto || (items.length < 2 && (top || this['void'] || items[0].key instanceof Splat))) {
			reft = this.left;
			if (reft.isComplex()) {
				reft = Parens(reft);
			}
		} else {
			ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
		}
		ref$ = top
			? [';', '\n' + this.tab]
			: [',', ' '], delim = ref$[0], space = ref$[1];
		delim += space;
		code = this.temps
			? [left.compile(o, LEVEL_PAREN), delim]
			: [];
		for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
			i = i$;
			node = items[i$];
			i && code.push(com ? space : delim);
			if (com = node.comment) {
				code.push(node.compile(o));
				continue;
			}
			key = node.key, val = node.val, logic = node.logic;
			if (key instanceof Splat) {
				code.push(CopyL(this, Import(reft, val)).compile(o));
				continue;
			}
			if (node.accessor) {
				if (key instanceof Key) {
					key = JS("'" + key.name + "'");
				}
				code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor(o), ")");
				continue;
			}
			logic && (val = (logic.first = val, logic));
			code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
		}
		if (top) {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		}
		this['void'] || key instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
		if (o.level < LEVEL_LIST) {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	Import.prototype.rewriteShorthand = function(o, assign){
		var that, ref$, ref1$;
		if (that = this.unfoldSoak(o)) {
			return that.rewriteShorthand(o, assign) || that;
		}
		if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, assign) : void 8) {
			this.left = that;
		}
		if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
			this.right = that;
		}
	};
	return Import;
}(Node));
exports.In = In = (function(superclass){
	var prototype = extend$((import$(In, superclass).displayName = 'In', In), superclass).prototype, constructor = In;
	Object.assign(prototype, arguments[1]);
	function In(item, array){
		this.item = item;
		this.array = array;
	}
	In.prototype.children = ['item', 'array'];
	In.prototype.compileNode = function(o){
		var array, items, value, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
		items = (array = this.array).items;
		if (!(array instanceof Arr)) {
			return sn(this, this.negated ? '!' : '', util('in'), "(", this.item.compile(o, LEVEL_LIST), ", ", array.compile(o, LEVEL_LIST), ")");
		}
		if (items.length === 0) {
			if (o.warn) {
				this.warn("value can never be `in` an empty array");
			}
			value = !!this.negated + "";
			return this.item.isComplex()
				? sn(this, "(", this.item.compile(o, LEVEL_LIST), ", ", value, ")")
				: sn(this, value);
		}
		code = [];
		ref$ = items.length === 1
			? [ref$ = this.item.compile(o, LEVEL_PAREN), ref$]
			: this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
		ref$ = this.negated
			? [' !== ', ' && ']
			: [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
		for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
			i = i$;
			test = items[i$];
			if (code.length > 0) {
				code.push(cnj);
			}
			if (test instanceof Splat) {
				code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
				if (!(i || sub === ref)) {
					code = ["(" + sub + ", "].concat(arrayFrom$(code), [")"]);
				}
			} else {
				code.push(i || sub === ref
					? ref
					: "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
			}
		}
		sub === ref || o.scope.free(ref);
		if (o.level < LEVEL_OP + PREC[items.length === 1 ? '===' : '||']) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
		}
	};
	return In;
}(Node, Negatable));
exports.Existence = Existence = (function(superclass){
	var prototype = extend$((import$(Existence, superclass).displayName = 'Existence', Existence), superclass).prototype, constructor = Existence;
	Object.assign(prototype, arguments[1]);
	function Existence(it, negated){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.it = it;
		this$.negated = negated;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Existence.prototype.children = ['it'];
	Existence.prototype.compileNode = function(o){
		var node, ref$, code, op, eq, anaphPre, anaphPost, that;
		node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
		code = [node.compile(o, LEVEL_OP + PREC['=='])];
		if (this.doAnaphorize) {
			o.scope.declare('that', Var('that'));
		}
		if (node instanceof Var && !o.scope.check(code.join(""), true)) {
			ref$ = this.negated
				? ['||', '=']
				: ['&&', '!'], op = ref$[0], eq = ref$[1];
			if (this.doAnaphorize) {
				ref$ = this.negated
					? [["(that = undefined) || "], []]
					: [[], [" && (that = "].concat(arrayFrom$(code), [", true)"])], anaphPre = ref$[0], anaphPost = ref$[1];
			}
			code = ["typeof "].concat(arrayFrom$(code), [" " + eq + "= 'undefined' " + op + " "], arrayFrom$(code), [" " + eq + "== null"]);
			if ((that = anaphPre) != null) {
				code = that.concat(code);
			}
			if ((that = anaphPost) != null) {
				code = code.concat(that);
			}
		} else {
			if (this.doAnaphorize) {
				code = ["(that = "].concat(arrayFrom$(code), [")"]);
			}
			code.push(" " + (op = this.negated ? '==' : '!=') + " null");
		}
		if (o.level < LEVEL_OP + PREC[op]) {
			return sn.apply(null, [this].concat(arrayFrom$(code)));
		} else {
			return sn(this, "(", code, ")");
		}
	};
	return Existence;
}(Node, Negatable));
exports.Fun = Fun = (function(superclass){
	var prototype = extend$((import$(Fun, superclass).displayName = 'Fun', Fun), superclass).prototype, constructor = Fun;
	function Fun(params, body, bound, curried, hushed, generator, async){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.params = params || [];
		this$.body = body || Block();
		this$.bound = bound && 'this$';
		this$.curried = curried || false;
		this$.hushed = hushed != null ? hushed : false;
		this$.generator = generator != null ? generator : false;
		this$.async = async != null ? async : false;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Fun.prototype.children = ['params', 'body'];
	Fun.prototype.show = function(){
		var that;
		return [this.name] + [(that = this.bound) ? "~" + that : void 8];
	};
	Fun.prototype.named = function(it){
		return this.name = it, this.statement = true, this;
	};
	Fun.prototype.isCallable = YES;
	Fun.prototype.isStatement = function(){
		return !!this.statement;
	};
	Fun.prototype.traverseChildren = function(arg$, xscope){
		if (xscope) {
			return superclass.prototype.traverseChildren.apply(this, arguments);
		}
	};
	Fun.prototype.rewriteShorthand = VOID;
	Fun.prototype.makeReturn = function(){
		if (this.statement) {
			return this.returns = true, this;
		} else {
			return superclass.prototype.makeReturn.apply(this, arguments);
		}
	};
	Fun.prototype.ripName = function(it){
		this.name || (this.name = it.varName());
	};
	Fun.prototype.compileNode = function(o){
		var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this, isBound = this.bound === 'this$';
		this.bound = false;
		pscope = o.scope;
		sscope = pscope.shared || pscope;
		scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper && sscope);
		scope.fun = this;
		if (that = this.proto) {
			scope.assign('prototype', that.compile(o) + ".prototype");
		}
		if (that = this.cname) {
			scope.assign('constructor', that);
		}
		if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
			o.indent = this.tab = '';
		}
		o.indent += TAB;
		body = this.body, name = this.name, tab = this.tab;
		if (isBound) {
			code = ['('];
		} else {
			code = [];
		}
		if (
			this.async ||
			this.body.traverseChildren(t => t.op === "await" || null)
		) {
			this.ctor && this.carp("a constructor can't be async");
			o.inAsync = true;
			code.push('async ');
		} else if (!this.wrapper) {
			o.inAsync = false;
		}
		if (!isBound) {
			code.push('function');
		}
		if (
			this.generator ||
			this.body.traverseChildren(t => t.op === "yield" || t.op === "yieldfrom" || null)
		) {
			this.ctor && this.carp("a constructor can't be a generator");
			o.inGenerator = true;
			code.push('*');
		} else if (!this.wrapper) {
			o.inGenerator = false;
		}
		if (isBound) {
			if (this.ctor) {
				scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
				body.lines.push(Return(Literal('this$')));
			} else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
				this.bound = that;
			// } else if (this.usesThis()) {
			// 	sscope.assign('this$', 'this');
			}
		}
		if (this.statement) {
			name || this.carp('nameless function declaration');
			pscope === o.block.scope || this.carp('misplaced function declaration');
			this.accessor && this.carp('named accessor');
			pscope.add(name, 'function', this);
		}
		if (this.statement || name && this.labeled) {
			code.push(' ', scope.add(name, 'function', this));
		}
		this.hushed || this.ctor || this.newed || body.makeReturn();
		code.push("(", this.compileParams(o, scope), ")");
		if (isBound) {
			code.push(' => ');
		}
		code = [sn.apply(null, [this].concat(arrayFrom$(code)))];
		code.push("{");
		if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
			code.push("\n", bodyCode, "\n" + tab);
		}
		code.push(isBound && '})' || '}');
		curryCodeCheck = function(){
			if (this$.curried && this$.hasSplats) {
				this$.carp('cannot curry a function with a variable number of arguments');
			}
			if (this$.curried && this$.params.length > 1 && !this$.classBound) {
				if (this$.bound) {
					return [util('curry'), "(("].concat(arrayFrom$(code), ["), true)"]);
				} else {
					return [util('curry'), "("].concat(arrayFrom$(code), [")"]);
				}
			} else {
				return code;
			}
		};
		if (inLoop) {
			return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(arrayFrom$(curryCodeCheck()))));
		}
		if (this.returns) {
			code.push("\n" + tab + "return ", name, ";");
		} else if (this.bound && this.ctor) {
			code.push(' function ctor$(){} ctor$.prototype = prototype;');
		}
		code = curryCodeCheck();
		if (this.front && !this.statement) {
			return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
		} else {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		}
	};
	Fun.prototype.compileParams = function(o, scope){
		var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
		params = this.params, length = params.length, body = this.body;
		for (i$ = params.length - 1; i$ >= 0; --i$) {
			p = params[i$];
			if (!(p.isEmpty() || p.filler)) {
				break;
			}
			--params.length;
		}
		for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
			i = i$;
			p = params[i$];
			if (p.left instanceof Splat) {
				p.carp('invalid splat');
			}
			if (p instanceof Splat) {
				if (i < params.length - 1) {
					this.hasSplats = true;
					splace = i;
				} else {
					params[i] = Var("..." + p.it.value);
				}
			} else if (p instanceof Arr || p instanceof Obj) {
				params[i] = Binary('=', p, new p.constructor());
			} else if (p.op === '=') {
				params[i] = Binary(p.logic || '?', p.left, p.right);
			}
		}
		if (splace != null) {
			rest = params.splice(splace, 9e9);
		} else if (this.accessor) {
			if (that = params[1]) {
				that.carp('excess accessor parameter');
			}
		} else if (!(length || this.wrapper)) {
			if (body.traverseChildren(function(it){
				return it.value === 'it' || null;
			})) {
				params[0] = Var('it');
			}
		}
		names = [];
		assigns = [];
		for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
			p = params[i$];
			vr = p;
			if (df = vr.getDefault()) {
				vr = vr.first;
			}
			if (vr.isEmpty()) {
				vr = Var(scope.temporary('arg'));
			} else if (vr.value === '..') {
				vr = Var(o.ref = scope.temporary());
			} else if (!(vr instanceof Var)) {
				unaries = [];
				while (vr instanceof Unary) {
					hasUnary = true;
					unaries.push(vr);
					vr = vr.it;
				}
				v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
				assigns.push(Assign(vr, (fn$())));
				vr = v;
			} else if (df) {
				assigns.push(Assign(vr, p.second, '=', p.op, true));
			}
			names.push(scope.add(vr.value, 'arg', p), ', ');
		}
		if (rest) {
			while (splace--) {
				rest.unshift(Arr());
			}
			assigns.push(Assign(Arr(rest), Literal('arguments')));
		}
		if (assigns.length) {
			(ref$ = this.body).prepend.apply(ref$, assigns);
		}
		names.pop();
		return sn.apply(null, [null].concat(arrayFrom$(names)));
		function fn$(){
			switch (false) {
			case !df:
				return Binary(p.op, v, p.second);
			case !hasUnary:
				return fold(function(x, y){
					y.it = x;
					return y;
				}, v, unaries.reverse());
			default:
				return v;
			}
		}
	};
	Fun.prototype.usesThis = function(){
		return Node.prototype.traverseChildren.call(this, function(it){
			switch (false) {
			case !(it instanceof Literal && it.value === 'this'):
				return true;
			case !(it instanceof Fun && it.bound && it.usesThis()):
				return true;
			}
		});
	};
	return Fun;
}(Node));
exports.Class = Class = (function(superclass){
	var prototype = extend$((import$(Class, superclass).displayName = 'Class', Class), superclass).prototype, constructor = Class;
	function Class(arg$){
		var body;
		this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
		this.fun = Fun([], body);
	}
	Class.prototype.children = ['title', 'sup', 'mixins', 'fun'];
	Class.prototype.isCallable = YES;
	Class.prototype.ripName = function(it){
		this.name = it.varName();
	};
	Class.prototype.getRef = function(){
		var ref$, that;
		if (that = ((ref$ = this.title) != null ? ref$.varName() : void 8) || this.name) {
			return Var(that);
		}
	};
	Class.prototype.compile = function(o, level){
		var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
		fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
		CopyL(this, fun);
		boundFuncs = [];
		curriedBoundFuncs = [];
		decl = title != null ? title.varName() : void 8;
		name = decl || this.name;
		if (ID.test(name || '')) {
			fun.cname = name;
		} else {
			name = 'constructor';
		}
		proto = Var('prototype');
		vname = fun.proto = Var(fun.bound = name);
		ctorName = 'constructor$$';
		importProtoObj = function(node, i){
			var j, prop, key, i$, ref$, len$, v;
			j = 0;
			for (; j < node.items.length; j++) {
				prop = node.items[j];
				key = prop.key;
				if ((key instanceof Key && key.name === ctorName) || (key instanceof Literal && key.value === "'" + ctorName + "'")) {
					if (ctor) {
						node.carp('redundant constructor');
					}
					ctor = prop.val;
					node.items.splice(j--, 1);
					ctorPlace = i;
				}
				if (!(prop.val instanceof Fun || prop.accessor)) {
					continue;
				}
				if (key.isComplex()) {
					key = Var(o.scope.temporary('key'));
					prop.key = Assign(key, prop.key);
				}
				if (prop.val.bound) {
					if (prop.val.curried) {
						curriedBoundFuncs.push(prop.key);
					} else {
						boundFuncs.push(prop.key);
					}
					prop.val.bound = false;
					prop.val.classBound = true;
				}
				for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ < len$; ++i$) {
					v = ref$[i$];
					v.meth = key;
				}
			}
			if (node.items.length) {
				return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
			} else {
				return Literal('void');
			}
		};
		for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
			i = i$;
			node = lines[i$];
			if (node instanceof Obj) {
				lines[i] = importProtoObj(node, i);
			} else if (node instanceof Fun && !node.statement) {
				ctor && node.carp('redundant constructor');
				ctor = node;
			} else if (node instanceof Assign && node.left instanceof Chain && node.left.head.value === 'this' && node.right instanceof Fun) {
				node.right.stat = node.left.tails[0].key;
			} else {
				node.traverseChildren(fn$);
			}
		}
		ctor || (ctor = lines[lines.length] = this.sup
			? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
			: Fun());
		if (!(ctor instanceof Fun)) {
			lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
			lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
		}
		ctor.name = name;
		ctor.ctor = true;
		ctor.statement = true;
		for (i$ = 0, len$ = boundFuncs.length; i$ < len$; ++i$) {
			f = boundFuncs[i$];
			ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'" + f.name + "'"), Var('prototype')]))));
		}
		for (i$ = 0, len$ = curriedBoundFuncs.length; i$ < len$; ++i$) {
			f = curriedBoundFuncs[i$];
			ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'_" + f.name + "'")]))));
		}
		lines.push(vname);
		args = [];
		if (that = this.sup) {
			args.push(that);
			imports = Chain(Import(Literal('this'), Var('superclass')));
			fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
		}
		if (that = this.mixins) {
			res$ = [];
			for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
				args[args.length] = that[i$];
				res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
			}
			imports = res$;
			body.prepend.apply(body, imports);
		}
		if (fun.cname && !this.sup) {
			body.prepend(Literal(name + ".displayName = '" + name + "'"));
		}
		clas = Parens(Call.make(fun, args), true);
		if (decl && title.isComplex()) {
			clas = Assign(vname, clas);
		}
		if (title) {
			clas = Assign(title, clas);
		}
		return sn(null, clas.compile(o, level));
		function fn$(it){
			var i$, ref$, len$, k, child;
			if (it instanceof Block) {
				for (i$ = 0, len$ = (ref$ = it.lines).length; i$ < len$; ++i$) {
					k = i$;
					child = ref$[i$];
					if (child instanceof Obj) {
						it.lines[k] = importProtoObj(child, i);
					}
				}
			}
		}
	};
	return Class;
}(Node));
exports.Super = Super = (function(superclass){
	var prototype = extend$((import$(Super, superclass).displayName = 'Super', Super), superclass).prototype, constructor = Super;
	function Super(){}
	Super.prototype.isCallable = YES;
	Super.prototype.compile = function(o){
		var scope, that, result, ref$;
		scope = o.scope;
		if (!this.sproto) {
			for (; that = !scope.get('superclass') && scope.fun; scope = scope.parent) {
				result = that;
				if (that = result.meth) {
					return sn(this, 'superclass.prototype', Index(that).compile(o));
				}
				if (that = result.stat) {
					return sn(this, 'superclass', Index(that).compile(o));
				}
				if (that = scope.fun.inClass) {
					return sn(this, that, ".superclass.prototype.", scope.fun.name);
				} else if (that = scope.fun.inClassStatic) {
					return sn(this, that, ".superclass.", scope.fun.name);
				}
			}
			if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
				return sn(this, that, ".superclass");
			}
		}
		return sn(this, 'superclass');
	};
	Super.prototype.maybeKey = function(){
		return Key('super', true);
	};
	return Super;
}(Node));
exports.Parens = Parens = (function(superclass){
	var prototype = extend$((import$(Parens, superclass).displayName = 'Parens', Parens), superclass).prototype, constructor = Parens;
	function Parens(it, keep, string, lb, rb){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.it = it;
		this$.keep = keep;
		this$.string = string;
		this$.lb = lb;
		this$.rb = rb;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Parens.prototype.children = ['it'];
	Parens.prototype.show = function(){
		return this.string && '""';
	};
	prototype.delegate(['isComplex', 'isCallable', 'isArray', 'isRegex', 'isNextUnreachable', 'getRef'], function(it){
		return this.it[it]();
	});
	Parens.prototype.isString = function(){
		return this.string || this.it.isString();
	};
	Parens.prototype.unparen = function(){
		if (this.keep) {
			return this;
		} else {
			return this.it.unparen();
		}
	};
	Parens.prototype.compile = function(o, level){
		var it;
		level == null && (level = o.level);
		it = this.it;
		it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
		if (this.calling && (!level || this['void'])) {
			it.head.hushed = true;
		}
		if (!(this.keep || this.newed || level >= LEVEL_OP + PREC[it.op])) {
			return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
		}
		if (it.isStatement()) {
			return it.compileClosure(o);
		} else {
			return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
		}
	};
	Parens.prototype.maybeKey = THIS;
	Parens.prototype.extractKeyRef = function(o, assign, tempOwner){
		var v, ref$, ref, key, val;
		if (tempOwner != null && (v = this.it) instanceof Var && (ref$ = v.temp, delete v.temp, ref$)) {
			(tempOwner.temps || (tempOwner.temps = [])).push(v.value);
		}
		if (this.it instanceof Chain && assign) {
			ref$ = this.it.cacheReference(o), this.it = ref$[0], ref = ref$[1];
			return Parens(ref);
		}
		ref$ = this.it.cache(o, true), key = ref$[0], val = ref$[1];
		if (assign) {
			ref$ = [val, key], key = ref$[0], val = ref$[1];
		}
		this.it = val.unparen();
		return Parens(key);
	};
	Parens.prototype.rewriteShorthand = function(o){
		var that;
		if (that = this.it.rewriteShorthand(o)) {
			this.it = that;
		}
	};
	return Parens;
}(Node));
exports.Splat = Splat = (function(superclass){
	var ref$, prototype = extend$((import$(Splat, superclass).displayName = 'Splat', Splat), superclass).prototype, constructor = Splat;
	function Splat(it, filler){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.it = it;
		this$.filler = filler;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;
	Splat.prototype.isAssignable = YES;
	Splat.prototype.assigns = function(){
		return this.it.assigns();
	};
	Splat.prototype.compile = function(){
		return this.carp('invalid splat');
	};
	Splat.compileArray = function(o, list, apply){
		var index, i$, len$, node, args, atoms, ref$;
		expand(list);
		index = 0;
		for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
			node = list[i$];
			if (node instanceof Splat) {
				break;
			}
			++index;
		}
		if (index >= list.length) {
			return sn(this, '');
		}
		if (!list[1]) {
			return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
		}
		args = [];
		atoms = [];
		for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ < len$; ++i$) {
			node = ref$[i$];
			if (node instanceof Splat) {
				if (atoms.length) {
					args.push(Arr(atoms.splice(0, 9e9)));
				}
				args.push(ensureArray(node.it));
			} else {
				atoms.push(node);
			}
		}
		if (atoms.length) {
			args.push(Arr(atoms));
		}
		return sn(null, (index
			? Arr(list)
			: args.shift()).compile(o, LEVEL_CALL), sn(this, ".concat("), List.compile(o, args), sn(this, ")"));
	};
	function expand(nodes){
		var index, node, it;
		index = -1;
		while (node = nodes[++index]) {
			if (node instanceof Splat) {
				it = node.it;
				if (it.isEmpty()) {
					nodes.splice(index--, 1);
				} else if (it instanceof Arr) {
					nodes.splice.apply(nodes, [index, 1].concat(arrayFrom$(expand(it.items))));
					index += it.items.length - 1;
				}
			}
		}
		return nodes;
	}
	function ensureArray(node){
		if (node.isArray()) {
			return node;
		}
		util('slice');
		return Call.make(Util('arrayFrom'), [node]);
	}
	return Splat;
}(Node));
exports.Jump = Jump = (function(superclass){
	var prototype = extend$((import$(Jump, superclass).displayName = 'Jump', Jump), superclass).prototype, constructor = Jump;
	function Jump(verb, label){
		this.verb = verb;
		this.label = label;
	}
	Jump.prototype.show = function(){
		var that;
		return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
	};
	Jump.prototype.isStatement = YES;
	Jump.prototype.makeReturn = THIS;
	Jump.prototype.isNextUnreachable = YES;
	Jump.prototype.getJump = function(ctx){
		ctx || (ctx = {});
		if (!ctx[this.verb]) {
			return this;
		}
		if (this.label) {
			return !(ctx.labels != null ? ctx.labels : ctx.labels = []).includes(this.label) && this;
		}
	};
	Jump.prototype.compileNode = function(o){
		if (this.label) {
			(o.labels != null ? o.labels : o.labels = []).includes(this.label) || this.carp("unknown label \"" + this.label + "\"");
		} else {
			o[this.verb] || this.carp("stray " + this.verb);
		}
		return sn(this, this.show() + ';');
	};
	Jump.extended = function(sub){
		sub.prototype.children = ['it'];
		this[sub.displayName.toLowerCase()] = sub;
	};
	return Jump;
}(Node));
exports.Throw = Throw = (function(superclass){
	var prototype = extend$((import$(Throw, superclass).displayName = 'Throw', Throw), superclass).prototype, constructor = Throw;
	function Throw(it){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.it = it;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Throw.prototype.getJump = VOID;
	Throw.prototype.compileNode = function(o){
		var ref$;
		return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
	};
	return Throw;
}(Jump));
exports.Return = Return = (function(superclass){
	var prototype = extend$((import$(Return, superclass).displayName = 'Return', Return), superclass).prototype, constructor = Return;
	function Return(it){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		if (it && it.value !== 'void') {
			this$.it = it;
		}
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Return.prototype.getJump = THIS;
	Return.prototype.compileNode = function(o){
		var that;
		return sn.apply(null, [this, "return"].concat(
			(that = this.it)
				? [' ', that.compile(o, LEVEL_PAREN)]
				: [], [";"]
		));
	};
	return Return;
}(Jump));
exports.While = While = (function(superclass){
	var prototype = extend$((import$(While, superclass).displayName = 'While', While), superclass).prototype, constructor = While;
	function While(test, un, mode){
		this.un = un;
		mode && (mode instanceof Node
			? this.update = mode
			: this.post = true);
		if (this.post || test.value !== '' + !un) {
			this.test = test;
		}
	}
	While.prototype.children = ['test', 'body', 'update', 'else'];
	While.prototype.aSource = 'test';
	While.prototype.aTargets = ['body', 'update'];
	While.prototype.show = function(){
		return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
	};
	prototype.isStatement = prototype.isArray = YES;
	While.prototype.makeComprehension = function(toAdd, loops){
		this.isComprehension = true;
		while (loops.length) {
			toAdd = loops.pop().addBody(Block(toAdd));
			if (!toAdd.isComprehension) {
				toAdd.inComprehension = true;
			}
		}
		return this.addBody(Block(toAdd));
	};
	While.prototype.getJump = function(ctx){
		var ref$, i$, ref1$, len$, node;
		ctx || (ctx = {});
		ctx['continue'] = true;
		ctx['break'] = true;
		for (i$ = 0, len$ = (ref1$ = ((ref$ = this.body) != null ? ref$.lines : void 8) || []).length; i$ < len$; ++i$) {
			node = ref1$[i$];
			if (node.getJump(ctx)) {
				return node;
			}
		}
	};
	While.prototype.addBody = function(body){
		var top;
		this.body = body;
		if (this.guard) {
			this.body = Block(If(this.guard, this.body));
		}
		top = this.body.lines[0];
		if ((top != null ? top.verb : void 8) === 'continue' && !top.label) {
			this.body.lines.length = 0;
		}
		return this;
	};
	While.prototype.addGuard = function(guard){
		this.guard = guard;
		return this;
	};
	While.prototype.addObjComp = function(objComp){
		this.objComp = objComp != null ? objComp : true;
		return this;
	};
	While.prototype.makeReturn = function(it){
		var ref$, last, ref1$, ref2$;
		if (this.hasReturned) {
			return this;
		}
		if (it) {
			if (this.objComp) {
				this.body = Block(this.body.makeReturn(it, true));
			} else {
				if (!(this.body || this.index)) {
					this.addBody(Block(Var(this.index = 'ridx$')));
				}
				last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
				if ((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension)) {
					(ref1$ = this.body).makeReturn.apply(ref1$, arguments);
					if ((ref1$ = this['else']) != null) {
						ref1$.makeReturn.apply(ref1$, arguments);
					}
					this.hasReturned = true;
				} else {
					this.resVar = it;
					if ((ref2$ = this['else']) != null) {
						ref2$.makeReturn.apply(ref2$, arguments);
					}
				}
			}
		} else {
			this.getJump() || (this.returns = true);
		}
		return this;
	};
	While.prototype.compileNode = function(o){
		var ref$, test, head, that;
		o.loop = true;
		this.test && (this.un
			? this.test = this.test.invert()
			: this.anaphorize());
		if (this.post) {
			return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
		}
		test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
		if (!(this.update || this['else'])) {
			head = !snEmpty(test)
				? [sn(this, "while ("), test]
				: [sn(this, 'for (;;')];
		} else {
			head = [sn(this, 'for (')];
			if (this['else']) {
				head.push(this.yet = o.scope.temporary('yet'), " = true");
			}
			head.push(sn(this, ";"), test.toString() && ' ', test, sn(this, ";"));
			if (that = this.update) {
				head.push(' ', that.compile(o, LEVEL_PAREN));
			}
		}
		return sn.apply(null, [null].concat(arrayFrom$(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
	};
	While.prototype.compileBody = function(o){
		var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ = this;
		o['break'] = o['continue'] = true;
		lines = this.body.lines, yet = this.yet, tab = this.tab;
		code = [];
		ret = [];
		mid = [];
		empty = this.objComp ? '{}' : '[]';
		getResultName = function(){
			return _resultName != null
				? _resultName
				: _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
		};
		last = lines != null ? lines[lines.length - 1] : void 8;
		if (!(this.isComprehension || this.inComprehension) || (last != null && last.isComprehension)) {
			hasLoop = false;
			if (last != null) {
				last.traverseChildren(function(it){
					var ref$;
					if (it instanceof Block && (ref$ = it.lines)[ref$.length - 1] instanceof While) {
						hasLoop = true;
					}
				});
			}
			if (this.returns && !this.resVar) {
				this.resVar = res = o.scope.assign(getResultName(), empty);
			}
			if (this.resVar && (last instanceof While || hasLoop)) {
				temp = o.scope.temporary('lresult');
				lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
					? Obj()
					: Arr(), '='));
				if (lines[key$ = lines.length - 1] != null) {
					lines[key$] = lines[key$].makeReturn(temp);
				}
				mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" + this.tab);
			} else {
				this.hasReturned = true;
				if (this.resVar) {
					this.body.makeReturn(this.resVar);
				}
			}
		}
		if (this.returns) {
			if ((!last instanceof While && !this.hasReturned) || this.isComprehension || this.inComprehension) {
				if (lines[key$ = lines.length - 1] != null) {
					lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
				}
			}
			ret.push("\n" + this.tab + "return ", res || empty, ";");
			if ((ref$ = this['else']) != null) {
				ref$.makeReturn();
			}
		}
		yet && lines.unshift(JS(yet + " = false;"));
		if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
			code.push("\n", bodyCode, "\n" + tab);
		}
		code.push.apply(code, mid);
		code.push('}');
		if (this.post) {
			code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
		}
		if (yet) {
			code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
			o.scope.free(yet);
		}
		return sn.apply(null, [null].concat(arrayFrom$(code), arrayFrom$(ret)));
	};
	return While;
}(Node));
exports.For = For = (function(superclass){
	var prototype = extend$((import$(For, superclass).displayName = 'For', For), superclass).prototype, constructor = For;
	function For(it){
		var i$, x$, ref$, len$;
		Object.assign(this, it);
		if (this.item instanceof Var && !this.item.value) {
			this.item = null;
		}
		for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ < len$; ++i$) {
			x$ = ref$[i$];
			this[x$] = true;
		}
		if (this.own && !this.object) {
			this.carp('`for own` requires `of`');
		}
	}
	For.prototype.children = ['item', 'source', 'from', 'to', 'step', 'body'];
	For.prototype.aSource = null;
	For.prototype.show = function(){
		return ((this.kind || []).concat(this.index)).join(' ');
	};
	For.prototype.addBody = function(body){
		var ref$, assignments, x$, that, assigned, name;
		if (this['let']) {
			if (ref$ = this.ref, delete this.ref, ref$) {
				this.item = Literal('..');
			}
			assignments = (x$ = [], (that = this.index) && x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) && x$.push(Assign(that, Literal('item$$'))), x$);
			body = Block(this.guard
				? (assigned = (function(){
					var i$, x$, ref$, len$, j$, ref1$, len1$, results$ = [];
					for (i$ = 0, len$ = (ref$ = assignments).length; i$ < len$; ++i$) {
						x$ = ref$[i$];
						if (that = x$.assigns()) {
							for (j$ = 0, len1$ = (ref1$ = that).length; j$ < len1$; ++j$) {
								name = ref1$[j$];
								results$.push(Var(name));
							}
						}
					}
					return results$;
				}()), assignments.concat([If((ref$ = this.guard, delete this.guard, ref$), Call['let'](assigned, body))]))
				: Call['let'](assignments, body));
		}
		superclass.prototype.addBody.call(this, body);
		if (this['let']) {
			delete this.index;
			delete this.item;
		}
		return this;
	};
	For.prototype.isNextUnreachable = NO;
	For.prototype.compileNode = function(o){
		var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
		o.loop = true;
		temps = this.temps = [];
		if (this.object && this.index) {
			o.scope.declare(idx = this.index);
		} else {
			temps.push(idx = o.scope.temporary('i'));
		}
		if (!this.body) {
			this.addBody(Block(Var(idx)));
		}
		if (!this.object) {
			ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
			pvar === step || temps.push(pvar);
		}
		if (this.from) {
			if (this.ref) {
				this.item = Var(idx);
			}
			ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
			fvar = this.from.compile(o, LEVEL_LIST);
			vars = idx + " = " + fvar;
			if (tail !== tvar) {
				vars += ", " + tail;
				temps.push(tvar);
			}
			if (!this.step && +fvar > +tvar) {
				pvar = step = -1;
			}
			eq = this.op === 'til' ? '' : '=';
			cond = +pvar
				? idx + " " + '<>'.charAt(pvar < 0) + eq + " " + tvar
				: pvar + " < 0 ? " + idx + " >" + eq + " " + tvar + " : " + idx + " <" + eq + " " + tvar;
		} else {
			if (this.ref) {
				this.item = Var(o.scope.temporary('x'));
			}
			if (this.item || this.object && this.own || this['let']) {
				ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
				svar === srcPart || temps.push(svar);
			} else {
				svar = srcPart = this.source.compile(o, LEVEL_PAREN);
			}
			if (!this.object) {
				if (0 > pvar && ~~pvar === +pvar) {
					vars = idx + " = " + srcPart + ".length - 1";
					cond = idx + " >= 0";
				} else {
					temps.push(lvar = o.scope.temporary('len'));
					vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
					cond = idx + " < " + lvar;
				}
			}
		}
		this['else'] && (this.yet = o.scope.temporary('yet'));
		head = [sn(this, this.let ? 'for (let ' : 'for (')];
		if (this.object) {
			head.push(idx, " in ");
		}
		if (that = this.yet) {
			head.push(that, " = true, ");
		}
		if (this.object) {
			head.push(srcPart);
		} else {
			step === pvar || (vars += ', ' + step);
			head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
				? (pvar < 0 ? '--' : '++') + idx
				: idx + (pvar < 0
					? ' -= ' + pvar.toString().slice(1)
					: ' += ' + pvar)));
		}
		this.own && head.push(sn(this, ") if ("), o.scope.assign('own$', '{}.hasOwnProperty'), ".call(", svar, ", ", idx, ")");
		head.push(sn(this, ') {'));
		if (this['let']) {
			this.body.traverseChildren(function(it){
				switch (it.value) {
				case 'index$$':
					it.value = idx;
					break;
				case 'item$$':
					it.value = svar + "[" + idx + "]";
				}
			});
		}
		o.indent += TAB;
		if (this.index && !this.object) {
			head.push('\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');
		}
		if (this.item && !this.item.isEmpty() && !this.from) {
			head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
		}
		if (this.ref) {
			o.ref = this.item.value;
		}
		body = this.compileBody(o);
		if ((this.item || (this.index && !this.object)) && '}' === body.toString().charAt(0)) {
			head.push('\n' + this.tab);
		}
		return sn.apply(null, [null].concat(arrayFrom$(head), [body]));
	};
	return For;
}(While));
exports.StepSlice = StepSlice = (function(superclass){
	var prototype = extend$((import$(StepSlice, superclass).displayName = 'StepSlice', StepSlice), superclass).prototype, constructor = StepSlice;
	StepSlice.prototype.makeReturn = function(makeReturnArg){
		this.makeReturnArg = makeReturnArg;
		return superclass.prototype.makeReturn.apply(this, arguments);
	};
	StepSlice.prototype.compileNode = function(o){
		var ref$, sub, ref, temps, code;
		this.index = o.scope.temporary('x');
		ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
		this.guard = Binary('<', Literal(this.index), Chain(ref).add(Index(Key('length'))));
		this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
		if (this.makeReturnArg != null) {
			this.makeReturn(this.makeReturnArg);
		}
		code = [];
		if (temps) {
			code.push(sub.compile(o), ';' + '\n' + o.indent);
		}
		code.push(superclass.prototype.compileNode.apply(this, arguments));
		return sn.apply(null, [this].concat(arrayFrom$(code)));
	};
	function StepSlice(){
		StepSlice.superclass.apply(this, arguments);
	}
	return StepSlice;
}(For));
exports.Try = Try = (function(superclass){
	var prototype = extend$((import$(Try, superclass).displayName = 'Try', Try), superclass).prototype, constructor = Try;
	function Try(attempt, thrown, recovery, ensure){
		var ref$;
		this.attempt = attempt;
		this.thrown = thrown;
		this.recovery = recovery;
		this.ensure = ensure;
		if ((ref$ = this.recovery) != null) {
			ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
		}
	}
	Try.prototype.children = ['attempt', 'recovery', 'ensure'];
	Try.prototype.show = function(){
		return this.thrown;
	};
	Try.prototype.isStatement = YES;
	Try.prototype.isCallable = function(){
		var ref$;
		return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) && this.attempt.isCallable();
	};
	Try.prototype.getJump = function(it){
		var ref$;
		return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
	};
	Try.prototype.isNextUnreachable = function(){
		var ref$, that;
		return ((ref$ = this.ensure) != null ? ref$.isNextUnreachable() : void 8) || this.attempt.isNextUnreachable() && ((that = this.recovery) != null ? that.isNextUnreachable() : true);
	};
	Try.prototype.makeReturn = function(){
		var ref$;
		this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
		if (this.recovery != null) {
			this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
		}
		return this;
	};
	Try.prototype.compileNode = function(o){
		var code, that;
		o.indent += TAB;
		code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
		if (that = this.recovery || !this.ensure && JS('')) {
			code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
		}
		if (that = this.ensure) {
			code.push(sn(that, ' finally '), this.compileBlock(o, that));
		}
		return sn.apply(null, [null].concat(arrayFrom$(code)));
	};
	return Try;
}(Node));
exports.Switch = Switch = (function(superclass){
	var prototype = extend$((import$(Switch, superclass).displayName = 'Switch', Switch), superclass).prototype, constructor = Switch;
	function Switch(type, topic, cases, $default){
		var last, ref$;
		this.type = type;
		this.topic = topic;
		this.cases = cases;
		this['default'] = $default;
		if (type === 'match') {
			if (topic) {
				this.topic = Arr(topic);
			}
		} else {
			if (topic) {
				if (topic.length > 1) {
					throw "can't have more than one topic in switch statement";
				}
				this.topic = this.topic[0];
			}
		}
		if (this.cases.length && (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 && last.tests[0] instanceof Var && last.tests[0].value === '_') {
			this.cases.pop();
			this['default'] = last.body;
		}
	}
	Switch.prototype.children = ['topic', 'cases', 'default'];
	Switch.prototype.aSource = 'topic';
	Switch.prototype.aTargets = ['cases', 'default'];
	Switch.prototype.show = function(){
		return this.type;
	};
	Switch.prototype.isStatement = YES;
	Switch.prototype.isCallable = function(){
		var i$, ref$, len$, c;
		for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
			c = ref$[i$];
			if (!c.isCallable()) {
				return false;
			}
		}
		if (this['default']) {
			return this['default'].isCallable();
		} else {
			return true;
		}
	};
	Switch.prototype.getJump = function(ctx){
		var i$, ref$, len$, c, that;
		ctx || (ctx = {});
		ctx['break'] = true;
		for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
			c = ref$[i$];
			if (that = c.body.getJump(ctx)) {
				return that;
			}
		}
		return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
	};
	Switch.prototype.isNextUnreachable = function(){
		var i$, ref$, len$, c;
		for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
			c = ref$[i$];
			if (!c.body.isNextUnreachable()) {
				return false;
			}
		}
		return (ref$ = this['default']) != null ? ref$.isNextUnreachable() : void 8;
	};
	Switch.prototype.makeReturn = function(){
		var i$, ref$, len$, c;
		for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
			c = ref$[i$];
			c.makeReturn.apply(c, arguments);
		}
		if ((ref$ = this['default']) != null) {
			ref$.makeReturn.apply(ref$, arguments);
		}
		return this;
	};
	Switch.prototype.compileNode = function(o){
		var tab, topic, ref$, targetNode, target, t, code, stop, i$, len$, i, c, that;
		tab = this.tab;
		topic = this.type === 'match'
			? (this.topic && (ref$ = Chain(this.topic).cacheReference(o), targetNode = ref$[0], target = ref$[1]), t = target
				? [targetNode]
				: [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
			: !!this.topic && this.anaphorize().compile(o, LEVEL_PAREN);
		code = [sn(this, "switch (", snSafe(topic), ") {\n")];
		stop = this['default'] || this.cases.length - 1;
		o['break'] = true;
		for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
			i = i$;
			c = ref$[i$];
			code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
		}
		if (this['default']) {
			o.indent = tab + TAB;
			if (that = this['default'].compile(o, LEVEL_TOP)) {
				code.push(tab + "default:\n", that, "\n");
			}
		}
		return sn.apply(null, [null].concat(arrayFrom$(code), [tab + '}']));
	};
	return Switch;
}(Node));
exports.Case = Case = (function(superclass){
	var prototype = extend$((import$(Case, superclass).displayName = 'Case', Case), superclass).prototype, constructor = Case;
	function Case(tests, body){
		this.tests = tests;
		this.body = body;
	}
	Case.prototype.children = ['tests', 'body'];
	Case.prototype.isCallable = function(){
		return this.body.isCallable();
	};
	Case.prototype.makeReturn = function(){
		var ref$, ref1$;
		if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
			(ref1$ = this.body).makeReturn.apply(ref1$, arguments);
		}
		return this;
	};
	Case.prototype.compileCase = function(o, tab, nobr, bool, type, target){
		var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
		tests = [];
		for (i$ = 0, len$ = (ref$ = this.tests).length; i$ < len$; ++i$) {
			test = ref$[i$];
			if (test instanceof Arr && type !== 'match') {
				for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ < len1$; ++j$) {
					t = ref1$[j$];
					tests.push(t);
				}
			} else {
				tests.push(test);
			}
		}
		tests.length || tests.push(Literal('void'));
		if (type === 'match') {
			for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
				i = i$;
				test = tests[i$];
				tar = Chain(target).add(Index(Literal(i), '.', true));
				tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
			}
		}
		if (bool) {
			binary = type === 'match' ? '&&' : '||';
			t = tests[0];
			i = 0;
			while (that = tests[++i]) {
				t = Binary(binary, t, that);
			}
			tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
		}
		code = [];
		for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
			t = tests[i$];
			code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
		}
		lines = this.body.lines;
		last = lines[lines.length - 1];
		if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
			lines[lines.length - 1] = JS('// fallthrough');
		}
		o.indent = tab += TAB;
		if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
			code.push(bodyCode, '\n');
		}
		if (!(nobr || ft || (last != null && last.isNextUnreachable()))) {
			code.push(tab + 'break;\n');
		}
		return sn.apply(null, [null].concat(arrayFrom$(code)));
	};
	return Case;
}(Node));
exports.If = If = (function(superclass){
	var prototype = extend$((import$(If, superclass).displayName = 'If', If), superclass).prototype, constructor = If;
	function If($if, then, un){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$['if'] = $if;
		this$.then = then;
		this$.un = un;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	If.prototype.children = ['if', 'then', 'else'];
	If.prototype.aSource = 'if';
	If.prototype.aTargets = ['then'];
	If.prototype.show = function(){
		return this.un && '!';
	};
	If.prototype.terminator = '';
	prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex', 'isNextUnreachable'], function(it){
		var ref$;
		return ((ref$ = this['else']) != null ? ref$[it]() : void 8) && this.then[it]();
	});
	If.prototype.getJump = function(it){
		var ref$;
		return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
	};
	If.prototype.makeReturn = function(){
		var ref$;
		this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
		if (this['else'] != null) {
			this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
		}
		return this;
	};
	If.prototype.compileNode = function(o){
		if (this.un) {
			this['if'] = this['if'].invert();
		} else {
			this.soak || this.anaphorize();
		}
		if (o.level) {
			return this.compileExpression(o);
		} else {
			return this.compileStatement(o);
		}
	};
	If.prototype.compileStatement = function(o){
		var code, els;
		code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
		o.indent += TAB;
		code.push(this.compileBlock(o, Block(this.then)));
		if (!(els = this['else'])) {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		}
		return sn.apply(null, [null].concat(
			arrayFrom$(code), [
				sn(els, ' else '), els instanceof constructor
					? els.compile((o.indent = this.tab, o), LEVEL_TOP)
					: this.compileBlock(o, els)
			]
		));
	};
	If.prototype.compileExpression = function(o){
		var thn, els, code, pad;
		thn = this.then, els = this['else'] || Literal('void');
		this['void'] && (thn['void'] = els['void'] = true);
		if (!this['else'] && (this.cond || this['void'])) {
			return Parens(Binary('&&', this['if'], Parens(thn.unwrap()))).compile(o);
		}
		code = [sn(this, this['if'].compile(o, LEVEL_COND))];
		pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
		code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
		if (o.level < LEVEL_COND) {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		} else {
			return sn(null, "(", code, ")");
		}
	};
	If.unfoldSoak = function(o, parent, name){
		var that;
		if (that = parent[name].unfoldSoak(o)) {
			parent[name] = that.then;
			return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;
		}
	};
	return If;
}(Node));
exports.Label = Label = (function(superclass){
	var ref$, prototype = extend$((import$(Label, superclass).displayName = 'Label', Label), superclass).prototype, constructor = Label;
	function Label(label, it){
		var fun;
		this.label = label || '_';
		this.it = it;
		if (this.it.curried) {
			this.carp("can't use label with a curried function (attempted label '" + this.label + "')");
		}
		if (fun = (it instanceof Fun || it instanceof Class) && it || it.calling && it.it.head) {
			fun.name || (fun.name = this.label, fun.labeled = true);
			return it;
		}
	}
	ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;
	Label.prototype.show = function(){
		return this.label;
	};
	Label.prototype.isStatement = YES;
	Label.prototype.getJump = function(ctx){
		var ref$;
		ctx || (ctx = {});
		((ref$ = ctx.labels) != null
			? ref$
			: ctx.labels = []).push(this.label);
		return this.it.getJump((ctx['break'] = true, ctx));
	};
	Label.prototype.makeReturn = function(){
		var ref$;
		this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
		return this;
	};
	Label.prototype.compileNode = function(o){
		var label, it, labels;
		label = this.label, it = this.it;
		labels = o.labels = arrayFrom$(o.labels || []);
		if (labels.includes(label)) {
			this.carp("duplicate label \"" + label + "\"");
		}
		labels.push(label);
		it.isStatement() || (it = Block(it));
		return sn(null, sn(this, label, ": "), it instanceof Block
			? (o.indent += TAB, this.compileBlock(o, it))
			: it.compile(o));
	};
	return Label;
}(Node));
exports.Cascade = Cascade = (function(superclass){
	var prototype = extend$((import$(Cascade, superclass).displayName = 'Cascade', Cascade), superclass).prototype, constructor = Cascade;
	function Cascade(input, output, prog1){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.input = input;
		this$.output = output;
		this$.prog1 = prog1;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Cascade.prototype.show = function(){
		return this.prog1;
	};
	Cascade.prototype.children = ['input', 'output'];
	Cascade.prototype.terminator = '';
	prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
		return this[this.prog1 ? 'input' : 'output'][it]();
	});
	Cascade.prototype.getJump = function(it){
		return this.output.getJump(it);
	};
	Cascade.prototype.makeReturn = function(ret){
		this.ret = ret;
		return this;
	};
	Cascade.prototype.compileNode = function(o){
		var level, input, output, prog1, ref, ref$, code, out;
		level = o.level;
		input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
		if (prog1 && ('ret' in this || level && !this['void'])) {
			output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
		}
		if ('ret' in this) {
			output = output.makeReturn(this.ret);
		}
		if (ref) {
			prog1 || (output = Assign(Var(ref), output));
		} else {
			ref = o.scope.temporary('x');
		}
		if (input instanceof Cascade) {
			input.ref = ref;
		} else {
			input && (input = Assign(Var(ref), input));
		}
		o.level && (o.level = LEVEL_PAREN);
		code = [input.compile(o)];
		out = Block(output).compile((o.ref = new String(ref), o));
		if (prog1 === 'cascade' && !o.ref.erred) {
			this.carp("unreferred cascadee");
		}
		if (!level) {
			return sn.apply(null, [null].concat(arrayFrom$(code), [input.terminator, "\n", out]));
		}
		code.push(", ", out);
		if (level > LEVEL_PAREN) {
			return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
		} else {
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		}
	};
	return Cascade;
}(Node));
exports.JS = JS = (function(superclass){
	var prototype = extend$((import$(JS, superclass).displayName = 'JS', JS), superclass).prototype, constructor = JS;
	function JS(code, literal, comment){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.code = code;
		this$.literal = literal;
		this$.comment = comment;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	JS.prototype.show = function(){
		if (this.comment) {
			return this.code;
		} else {
			return "`" + this.code + "`";
		}
	};
	JS.prototype.terminator = '';
	prototype.isAssignable = prototype.isCallable = function(){
		return !this.comment;
	};
	JS.prototype.compile = function(it){
		return sn(this, snSafe(this.literal
			? entab(this.code, it.indent)
			: this.code));
	};
	return JS;
}(Node));
exports.Require = Require = (function(superclass){
	var prototype = extend$((import$(Require, superclass).displayName = 'Require', Require), superclass).prototype, constructor = Require;
	function Require(body){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.body = body;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Require.prototype.children = ['body'];
	Require.prototype.compile = function(o){
		var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
		getValue = function(item, throwError){
			switch (false) {
			case !(item instanceof Key):
				return item.name;
			case !(item instanceof Var):
				return item.value;
			case !(item instanceof Literal):
				return item.value;
			default:
				if (throwError) {
					return this$.carp('invalid require! argument');
				} else {
					return item;
				}
			}
		};
		processItem = function(item){
			var ref$, asg, value, asgValue, toAsg, main;
			ref$ = (function(){
				var ref$;
				switch (false) {
				case !(item instanceof Prop):
					return [
						item.val, (ref$ = item.key) != null
							? ref$
							: item.val
					];
				default:
					return [item, item];
				}
			}()), asg = ref$[0], value = ref$[1];
			asgValue = getValue(asg);
			toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
			value = stripString(getValue(value, true));
			main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
			return sn(item, Assign(toAsg, main).compile(o));
		};
		if (this.body.items != null) {
			code = [];
			for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ < len$; ++i$) {
				item = ref$[i$];
				code.push(processItem(item), ";\n" + o.indent);
			}
			code.pop();
			return sn.apply(null, [null].concat(arrayFrom$(code)));
		} else {
			return sn(null, processItem(this.body));
		}
	};
	return Require;
}(Node));
exports.Util = Util = (function(superclass){
	var prototype = extend$((import$(Util, superclass).displayName = 'Util', Util), superclass).prototype, constructor = Util;
	function Util(verb){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.verb = verb;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Util.prototype.show = Jump.prototype.show;
	Util.prototype.isCallable = YES;
	Util.prototype.compile = function(){
		return sn(this, util(this.verb));
	};
	Util.Extends = function(){
		return Call.make(Util('extend'), [arguments[0], arguments[1]]);
	};
	return Util;
}(Node));
exports.Vars = Vars = (function(superclass){
	var prototype = extend$((import$(Vars, superclass).displayName = 'Vars', Vars), superclass).prototype, constructor = Vars;
	function Vars(vars){
		var this$ = this instanceof ctor$ ? this : new ctor$;
		this$.vars = vars;
		return this$;
	} function ctor$(){} ctor$.prototype = prototype;
	Vars.prototype.children = ['vars'];
	Vars.prototype.makeReturn = THIS;
	Vars.prototype.compile = function(o, level){
		var i$, ref$, len$, v, value;
		for (i$ = 0, len$ = (ref$ = this.vars).length; i$ < len$; ++i$) {
			v = ref$[i$], value = v.value;
			if (!(v instanceof Var)) {
				v.carp('invalid variable declaration');
			}
			if (o.scope.check(value)) {
				v.carp("redeclaration of \"" + value + "\"");
			}
			o.scope.declare(value, v);
		}
		return sn(this, Literal('void').compile(o, level));
	};
	return Vars;
}(Node));
exports.L = function(a, b, node){
	if (node && typeof node === "object") {
		node.first_line = a.first_line + 1;
		node.first_column = a.first_column;
		node.last_line = b.last_line + 1;
		node.last_column = b.last_column;
		node.line = a.first_line + 1;
		node.column = a.first_column;
	}
	return node;
};
exports.CopyL = CopyL = function(a, node){
	if (node && typeof node === "object") {
		node.first_line = a.first_line;
		node.first_column = a.first_column;
		node.last_line = a.last_line;
		node.last_column = a.last_column;
		node.line = a.line;
		node.column = a.column;
	}
	return node;
};
exports.Box = function(v){
	if (typeof v === "object") {
		return v;
	} else {
		return new v.constructor(v);
	}
};
exports.Decl = function(type, nodes, lno){
	if (!nodes[0]) {
		throw SyntaxError("empty " + type + " on line " + lno);
	}
	return DECLS[type](nodes);
};
DECLS = {
	'export': function(lines){
		var i, out, node, that, ref$;
		i = -1;
		out = Util('out');
		while (node = lines[++i]) {
			if (node instanceof Block) {
				lines.splice.apply(lines, [i--, 1].concat(arrayFrom$(node.lines)));
				continue;
			}
			if (that = node instanceof Fun && node.name) {
				lines.splice(i++, 0, Assign(Chain(out, [Index(Key(that))]), Var(that)));
				continue;
			}
			lines[i] = (that = node.varName() || node instanceof Assign && node.left.varName() || node instanceof Class && ((ref$ = node.title) != null ? ref$.varName() : void 8))
				? Assign(Chain(out, [Index(Key(that))]), node)
				: Import(out, node);
		}
		return Block(lines);
	},
	'import': function(lines, all){
		var i$, len$, i, line;
		for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
			i = i$;
			line = lines[i$];
			lines[i] = Import(Literal('this'), line, all);
		}
		return Block(lines);
	},
	importAll: function(it){
		return this['import'](it, true);
	},
	'const': function(lines){
		var i$, len$, node;
		for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
			node = lines[i$];
			node.op === '=' || node.carp('invalid constant variable declaration');
			node['const'] = true;
		}
		return Block(lines);
	},
	'var': Vars
};
function Scope(parent, shared){
	this.parent = parent;
	this.shared = shared;
	this.variables = {};
}
ref$ = Scope.prototype;
ref$.READ_ONLY = {
	'const': 'constant',
	'function': 'function',
	undefined: 'undeclared'
};
ref$.add = function(name, type, node){
	var t, u, that;
	u = name.replace(/^\.\.\./, "")
	if (node && (t = this.variables[u + "."])) {
		if (that = this.READ_ONLY[t] || this.READ_ONLY[type]) {
			node.carp("redeclaration of " + that + " \"" + u + "\"");
		} else if (t === type && type === 'arg') {
			node.carp("duplicate parameter \"" + u + "\"");
		} else if (t === 'upvar') {
			node.carp("accidental shadow of \"" + u + "\"");
		}
		if (t === 'arg' || t === 'function') {
			return name;
		}
	}
	this.variables[u + "."] = type;
	return name;
};
ref$.get = function(name){
	return this.variables[name + "."];
};
ref$.declare = function(name, node, constant){
	var that, scope;
	if (that = this.shared) {
		if (this.check(name)) {
			return;
		}
		scope = that;
	} else {
		scope = this;
	}
	return scope.add(name, constant && name !== "that" ? 'const' : 'var', node);
};
ref$.assign = function(name, value){
	return this.add(name, {
		value: value
	});
};
ref$.temporary = function(name){
	var ref$;
	name || (name = 'ref');
	while ((ref$ = this.variables[name + "$."]) !== 'reuse' && ref$ !== void 8) {
		name = name.length < 2 && name < 'z'
			? String.fromCharCode(name.charCodeAt() + 1)
			: name.replace(/\d*$/, fn$);
	}
	return this.add(name + '$', 'var');
	function fn$(it){
		return ++it;
	}
};
ref$.free = function(name){
	return this.add(name, 'reuse');
};
ref$.check = function(name, above){
	var type, ref$;
	if ((type = this.variables[name + "."]) || !above) {
		return type;
	}
	return (ref$ = this.parent) != null ? ref$.check(name, above) : void 8;
};
ref$.checkReadOnly = function(name){
	var that, ref$, key$;
	if (that = this.READ_ONLY[this.check(name, true)]) {
		return that;
	}
	(ref$ = this.variables)[key$ = name + "."] || (ref$[key$] = 'upvar');
	return '';
};
ref$.emit = function(code, tab){
	var vrs, asn, fun, name, ref$, type, that, val, declCode;
	vrs = [];
	asn = [];
	fun = [];
	for (name in ref$ = this.variables) {
		type = ref$[name];
		name = name.slice(0, -1);
		if (type === 'var' || type === 'const' || type === 'reuse') {
			vrs.push(name, ", ");
		} else if (that = type.value) {
			if (~(val = entab(that, tab)).toString().lastIndexOf('function(', 0)) {
				if (val instanceof SourceNode) {
					snRemoveLeft(val, 8);
				} else {
					val = val.slice(8);
				}
				fun.push("function ", name, val, "\n" + tab);
			} else {
				asn.push(name, " = ", val, ", ");
			}
		}
	}
	declCode = vrs.concat(asn);
	declCode.pop();
	fun.pop();
	if (declCode.length > 0) {
		code = sn.apply(null, [this, tab + "var "].concat(arrayFrom$(declCode), [";\n", code]));
	}
	if (fun.length > 0) {
		return sn.apply(null, [this, code, "\n" + tab].concat(arrayFrom$(fun)));
	} else {
		return sn(this, code);
	}
};
function YES(){
	return true;
}
function NO(){
	return false;
}
function THIS(){
	return this;
}
function VOID(){}
UTILS = {
	clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
	extend: "function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",
	bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
	'import': 'function(obj, src){\n  return Object.assign(obj, src);\n}',
	importAll: 'function(obj, src){\n  return Object.assign(obj, src);\n}',
	copyWithout: 'function(src, ex){\n  var obj = {}, own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key) && !own.call(ex, key)) obj[key] = src[key];\n  return obj;\n}',
	repeatString: 'function(str, n){\n  return str.repeat(n < 0 ? 0 : n);\n}',
	repeatArray: 'function(arr, n){\n  for (var r = []; n-- > 0;) r.push(...arr);\n  return r;\n}',
	'in': 'function(x, xs){\n  return [].includes.call(xs, x);\n}',
	out: "typeof exports != 'undefined' && exports || this",
	curry: 'function(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}',
	flip: 'function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}',
	partialize: 'function(f, args, where){\n  var context = this;\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len < wlen && len ?\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n  };\n}',
	not: 'function(x){ return !x; }',
	compose: 'function() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}',
	deepEq: "function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  var first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case '[object String]': return a == String(b);\n      case '[object Number]':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        return +a == +b;\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == '[object Array]') {\n      alength = a.length;\n      blength = b.length;\n      if (first) {\n        switch (type) {\n        case '===': result = alength === blength; break;\n        case '<==': result = alength <= blength; break;\n        case '<<=': result = alength < blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === '<<=') {\n            result = size < sizeB;\n          } else if (type === '<==') {\n            result = size <= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}",
	arrayFrom: 'Array.from || (x => slice$.call(x, 0))',
	split: "''.split",
	replace: "''.replace",
	toString: '{}.toString',
	join: '[].join',
	slice: '[].slice',
	splice: '[].splice'
};
LEVEL_TOP = 0;
LEVEL_PAREN = 1;
LEVEL_LIST = 2;
LEVEL_COND = 3;
LEVEL_OP = 4;
LEVEL_CALL = 5;
(function(){
	this['&&'] = this['||'] = this['xor'] = 0.2;
	this['.&.'] = this['.^.'] = this['.|.'] = 0.3;
	this['=='] = this['!='] = this['~='] = this['!~='] = this['==='] = this['!=='] = 0.4;
	this['<'] = this['>'] = this['<='] = this['>='] = this.of = this['instanceof'] = 0.5;
	this['<<='] = this['>>='] = this['<=='] = this['>=='] = this['++'] = 0.5;
	this['.<<.'] = this['.>>.'] = this['.>>>.'] = 0.6;
	this['+'] = this['-'] = 0.7;
	this['*'] = this['/'] = this['%'] = 0.8;
}.call(PREC = {
	unary: 0.9
}));
TAB = '  ';
ID = /^(?!\d)[\w$\xAA-\uFFDC]+$/;
SIMPLENUM = /^\d+$/;
function util(it){
	return Scope.root.assign(it + '$', UTILS[it]);
}
function entab(code, tab){
	return code.replace(/\n/g, '\n' + tab);
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function repeatArray$(arr, n){
  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
    if (n & 1) r.push.apply(r, arr);
  return r;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
},{"source-map":31}],2:[function(require,module,exports){
(function (){
// Generated by LiveScript 1.6.1
var lexer, parser, ast, SourceNode, toString$ = {}.toString;
lexer = require('./lexer');
parser = require('./parser').parser;
ast = require('./ast');
SourceNode = require('source-map').SourceNode;
parser.yy = ast;
parser.lexer = {
	lex: function(){
		var ref$, tag, first_line, first_column, last_line, last_column;
		ref$ = this.tokens[++this.pos] || [''], tag = ref$[0], this.yytext = ref$[1], first_line = ref$[2], first_column = ref$[3];
		ref$ = this.tokens[this.pos + 1] || [''], last_line = ref$[2], last_column = ref$[3];
		this.yylineno = first_line;
		this.yylloc = {
			first_line: first_line,
			first_column: first_column,
			last_line: last_line,
			last_column: last_column
		};
		return tag;
	},
	setInput: function(it){
		this.pos = -1;
		return this.tokens = it;
	},
	upcomingInput: function(){
		return '';
	}
};
exports.VERSION = '1.4.2';
exports.compile = function(code, options){
	var result, ast, output, filename, outputFilename, mapPath, base64;
	code = code.replace(/(?<=^|\n)\t+/g, s => '  '.repeat(s.length))
	options == null && (options = {});
	options.warn == null && (options.warn = true);
	options.header == null && (options.header = true);
	if (options.header === true) {
		options.header = "// Generated by LiveScript " + exports.VERSION + "\n";
	}
	try {
		if (options.json) {
			result = Function(exports.compile(code, {
				bare: true,
				run: true,
				print: true
			}))();
			return JSON.stringify(result, null, 2) + "\n";
		} else {
			ast = parser.parse(lexer.lex(code));
			if (options.run && options.print) {
				ast.makeReturn();
			}
			output = ast.compileRoot(options);
			if (options.map && options.map !== 'none') {
				filename = options.filename, outputFilename = options.outputFilename;
				if (!filename) {
					filename = "unnamed-" + Math.floor(Math.random() * 4294967296).toString(16) + ".ls";
				}
				output.setFile(filename.replace(/\/+$/g).split('/').pop());
				result = output.toStringWithSourceMap();
				if (options.map === 'embedded') {
					result.map.setSourceContent(filename, code);
				}
				if (options.map === 'linked' || options.map === 'debug') {
					mapPath = outputFilename.replace(/\/+$/g).split('/').pop() + ".map";
					result.code += "\n//# sourceMappingURL=" + mapPath + "\n";
				} else {
					base64 = result.map.toString()
					if (isNode) {
						base64 = require('buffer').Buffer.alloc(base64).toString('base64');
					} else {
						base64 = btoa(base64);
					}
					result.code += "\n//# sourceMappingURL=data:application/json;base64," + base64;
				}
				return result;
			} else {
				return output.toString();
			}
		}
	} catch (e) {
		if (options.filename) {
			e.message += "\nat " + options.filename;
		}
		throw e;
	}
};
exports.ast = function(it){
	return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);
};
exports.tokens = lexer.lex;
exports.lex = function(it){
	return lexer.lex(it, {raw: true});
};
exports.run = function(code, options){
	var output;
	output = exports.compile(code, {bare: false, ...options, run: true});
	return globalThis.eval(typeof output === 'string' ? output : output.code);
};
exports.eval = function(code, options){
	return exports.run(code, {...options, print: true});
};
exports.tokens.rewrite = lexer.rewrite;
Object.assign(exports.ast, parser.yy);
if (require.extensions) {
	require('./node')(exports);
} else {
	exports.require = require;
}
}).call(this)
},{"./ast":1,"./lexer":3,"./node":4,"./parser":5,"source-map":31}],3:[function(require,module,exports){
// Generated by LiveScript 1.6.1
var string, TABS, unlines, enlines, enslash, reslash, camelize, deheregex, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, JS_KEYWORDS, LS_KEYWORDS, ID, ID_INTERPOLATE, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, slice$ = [].slice, arrayFrom$ = Array.from || (x => slice$.call(x));
exports.lex = function(code, options){
	return clone$(exports).tokenize(code || '', options || {});
};
exports.rewrite = function(it){
	var ref$;
	it || (it = this.tokens);
	firstPass(it);
	addImplicitIndentation(it);
	rewriteBlockless(it);
	addImplicitParentheses(it);
	expandLiterals(it);
	addImplicitBraces(it);
	if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
		it.shift();
	}
	return it;
};
exports.tokenize = function(code, o){
	var i, prevIndex, c, charsConsumed, that;
	this.inter || (code = code.replace(/[\r\u2028\u2029\uFEFF]/g, ''));
	code = '\n' + code;
	this.tokens = [this.last = ['NEWLINE', '\n', 0, 0]];
	this.line = ~-o.line;
	this.column = o.column || 0;
	this.dents = [];
	this.closes = [];
	this.parens = [];
	this.flags = [];
	i = 0;
	prevIndex = i;
	this.charsCounted = 0;
	this.isAtPrefix = true;
	while (c = code.charAt(i)) {
		charsConsumed = i - prevIndex;
		prevIndex = i;
		if (this.charsCounted > charsConsumed) {
			throw new Error('Location information out-of-sync in lexer');
		}
		this.column += charsConsumed - this.charsCounted;
		this.charsCounted = 0;
		switch (c) {
		case ' ':
			i += this.doSpace(code, i);
			break;
		case '\n':
			i += this.doLine(code, i);
			break;
		case '\\':
			i += this.doBackslash(code, i);
			break;
		case "'":
		case '"':
			i += this.doString(code, i, c);
			break;
		case "0":
		case "1":
		case "2":
		case "3":
		case "4":
		case "5":
		case "6":
		case "7":
		case "8":
		case "9":
			i += this.doNumber(code, i);
			break;
		case '/':
			switch (code.charAt(i + 1)) {
			case '*':
				i += this.doComment(code, i);
				break;
			case '/':
				i += this.doHeregex(code, i);
				break;
			default:
				i += this.doRegex(code, i) || this.doLiteral(code, i);
			}
			break;
		case '`':
			if ('`' === code.charAt(i + 1)) {
				i += this.doJS(code, i);
			} else {
				i += this.doLiteral(code, i);
			}
			break;
		default:
			i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
		}
	}
	this.dedent(this.dent);
	if (that = this.closes.pop()) {
		this.carp("missing `" + that + "`");
	}
	if (this.inter) {
		this.rest == null && this.carp('unterminated interpolation');
	} else {
		this.last.spaced = true;
		this.newline();
	}
	o.raw || this.rewrite();
	return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.reset = function(){
	this.dent = 0;
	this.identifiers = {};
};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
	if (this.hasOwn.call(this.identifiers, camel) && this.identifiers[camel] !== id) {
		throw new ReferenceError("Inconsistent use of " + camel + " as " + id + " on line " + (-~this.line));
	} else {
		return this.identifiers[camel] = id;
	}
};
exports.doID = function(code, index){
	var regexMatch, input, id, last, ref$, tag, ref1$, that;
	input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
	if (!input) {
		return 0;
	}
	id = camelize(regexMatch[1]);
	if (/-/.test(regexMatch[1])) {
		this.checkConsistency(id, regexMatch[1]);
	}
	if (NONASCII.test(id)) {
		try {
			Function("var " + id);
		} catch (e) {
			this.carp("invalid identifier '" + id + "'");
		}
	}
	last = this.last;
	if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {
		this.token('ID', JS_KEYWORDS.includes(id) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
		if (regexMatch[2]) {
			this.token(':', ':');
		}
		return input.length;
	}
	switch (id) {
	case 'true':
	case 'false':
	case 'on':
	case 'off':
	case 'yes':
	case 'no':
	case 'null':
	case 'void':
	case 'arguments':
	case 'debugger':
		tag = 'LITERAL';
		break;
	case 'new':
	case 'do':
	case 'typeof':
	case 'delete':
		tag = 'UNARY';
		break;
	case 'yield':
	case 'await':
		tag = 'YIELD';
		break;
	case 'return':
	case 'throw':
		tag = 'HURL';
		break;
	case 'break':
	case 'continue':
		tag = 'JUMP';
		break;
	case 'this':
	case 'eval':
	case 'super':
		return this.token('LITERAL', id, true).length;
	case 'for':
		id = [];
		this.fset('for', true);
		this.fset('to', false);
		this.fset('by', true);
		break;
	case 'then':
		this.fset('for', false);
		this.fset('to', false);
		break;
	case 'catch':
	case 'function':
		id = '';
		break;
	case 'in':
	case 'of':
		if (this.fget('for')) {
			this.fset('for', false);
			if (id === 'in') {
				this.fset('by', true);
				id = '';
				if (last[0] === 'ID' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === ',' || ref$ === ']' || ref$ === '}')) {
					id = this.tokens.pop()[1];
					if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {
						this.tokens.pop();
					}
				}
			}
			break;
		}
		// fallthrough
	case 'instanceof':
		if (last[1] === '!') {
			id = this.tokens.pop()[1] + id;
		}
		tag = (ref$ = this.tokens)[ref$.length - 1][0] === '(' ? 'BIOPR' : 'RELATION';
		break;
	case 'not':
		if (last.alias && last[1] === '===') {
			return last[1] = '!==', 3;
		}
		tag = 'UNARY';
		id = '!';
		break;
	case 'and':
	case 'or':
	case 'xor':
	case 'is':
	case 'isnt':
		this.unline();
		tag = id === 'is' || id === 'isnt' ? 'COMPARE' : 'LOGIC';
		if (last[0] === '(') {
			tag = 'BIOP';
		}
		this.token(tag, (function(){
			switch (id) {
			case 'is':
				return '===';
			case 'isnt':
				return '!==';
			case 'or':
				return '||';
			case 'and':
				return '&&';
			case 'xor':
				return 'xor';
			}
		}()));
		this.last.alias = true;
		return id.length;
	case 'unless':
		tag = 'IF';
		break;
	case 'until':
		tag = 'WHILE';
		break;
	case 'const':
	case 'var':
		tag = 'DECL';
		break;
	case 'with':
		tag = (function(){
			switch (false) {
			case !able(this.tokens):
				return 'CLONEPORT';
			case last[0] !== '(':
				return 'BIOP';
			default:
				return 'WITH';
			}
		}.call(this));
		break;
	case 'when':
		tag = 'CASE';
		// fallthrough
	case 'case':
		if (this.doCase()) {
			return input.length;
		}
		break;
	case 'match':
		tag = 'SWITCH';
		break;
	case 'loop':
		this.token('WHILE', id);
		this.token('LITERAL', 'true');
		return input.length;
	case 'let':
	case 'own':
		if (last[0] === 'FOR' && !last[1].includes(id)) {
			last[1].push(id);
			return 3;
		}
		// fallthrough
	default:
		if (KEYWORDS_SHARED.includes(id)) {
			break;
		}
		if (KEYWORDS_UNUSED.includes(id)) {
			this.carp("reserved word '" + id + "'");
		}
		if (!last[1] && ((ref$ = last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LABEL')) {
			last[1] = id;
			last.spaced = false;
			return input.length;
		}
		tag = 'ID';
		switch (id) {
		case 'otherwise':
			if ((ref$ = last[0]) === 'CASE' || ref$ === '|') {
				last[0] = 'DEFAULT';
				return id.length;
			}
			break;
		case 'all':
			if (that = last[1] === '<<<' && '<' || last[1] === 'import' && 'All') {
				last[1] += that;
				return 3;
			}
			break;
		case 'from':
			if (last[1] === 'yield') {
				last[1] += 'from';
				return 4;
			}
			this.forange() && (tag = 'FROM');
			break;
		case 'to':
		case 'til':
			this.forange() && this.tokens.push(['FROM', '', this.line, this.column], ['STRNUM', '0', this.line, this.column]);
			if (this.fget('from')) {
				this.fset('from', false);
				this.fset('by', true);
				tag = 'TO';
			} else if (!last.callable && last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === '[') {
				last[0] = 'RANGE';
				last.op = id;
				return id.length;
			} else if (this.closes.includes(']')) {
				this.token('TO', id);
				return id.length;
			}
			break;
		case 'by':
			if (last[0] === 'STRNUM' && !(ref$ = this.tokens)[ref$.length - 2][0] && (ref$ = this.tokens)[ref$.length - 3][0] === '[') {
				tag = 'RANGE_BY';
			} else if (this.closes.includes(']')) {
				tag = 'BY';
			} else if (this.fget('by') && last[0] !== 'FOR') {
				tag = 'BY';
				this.fset('by', false);
			}
			break;
		case 'ever':
			if (last[0] === 'FOR') {
				this.fset('for', false);
				last[0] = 'WHILE';
				tag = 'LITERAL';
				id = 'true';
			}
		}
	}
	tag || (tag = regexMatch[1].toUpperCase());
	if ((tag === 'COMPARE' || tag === 'LOGIC' || tag === 'RELATION') && last[0] === '(') {
		tag = tag === 'RELATION' ? 'BIOPR' : 'BIOP';
	}
	if (tag === 'THEN' || tag === 'IF' || tag === 'WHILE') {
		this.fset('for', false);
		this.fset('by', false);
	}
	if (tag === 'RELATION' || tag === 'THEN' || tag === 'ELSE' || tag === 'CASE' || tag === 'DEFAULT' || tag === 'CATCH' || tag === 'FINALLY' || tag === 'IN' || tag === 'OF' || tag === 'FROM' || tag === 'TO' || tag === 'BY' || tag === 'EXTENDS' || tag === 'IMPLEMENTS' || tag === 'WHERE') {
		this.unline();
	}
	this.token(tag, id);
	return input.length;
};
exports.doNumber = function(code, lastIndex){
	var input, regexMatch, last, radix, num, rnum, bound, ref$;
	NUMBER.lastIndex = lastIndex;
	if (!(input = (regexMatch = NUMBER.exec(code))[0])) {
		return 0;
	}
	last = this.last;
	if (regexMatch[5] && (last[0] === 'DOT' || this.adi())) {
		this.token('STRNUM', regexMatch[4].replace(NUMBER_OMIT, ''));
		return regexMatch[4].length;
	}
	if (radix = regexMatch[1]) {
		num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, ''), radix);
		bound = false;
		if (radix > 36 || radix < 2) {
			if (/[0-9]/.exec(rnum)) {
				this.carp("invalid number base " + radix + " (with number " + rnum + "),base must be from 2 to 36");
			} else {
				bound = true;
			}
		}
		if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
			this.strnum(regexMatch[1]);
			this.token('DOT', '.~');
			this.token('ID', regexMatch[2]);
			return input.length;
		}
		num += '';
	} else {
		num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');
		if (regexMatch[3] && num.charAt() === '0' && ((ref$ = num.charAt(1)) !== '' && ref$ !== '.')) {
			this.carp("deprecated octal literal " + regexMatch[4]);
		}
	}
	if (!last.spaced && last[0] === '+-') {
		last[0] = 'STRNUM';
		last[1] += num;
		return input.length;
	}
	this.strnum(num);
	return input.length;
};
exports.doString = function(code, index, q){
	var parts, str;
	if (q === code.charAt(index + 1)) {
		return q === code.charAt(index + 2)
			? this.doHeredoc(code, index, q)
			: (this.strnum(q + q), 2);
	}
	if (q === '"') {
		parts = this.interpolate(code, index, q);
		this.addInterpolated(parts, unlines);
		return parts.size;
	}
	str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
	this.strnum(unlines(this.string(q, str.slice(1, -1))));
	return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
	var end, raw, doc, parts, tabs, i$, len$, i, t;
	if (q === "'") {
		~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
		raw = code.slice(index + 3, end);
		doc = raw.replace(LASTDENT, '');
		this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));
		return this.countLines(raw).length + 6;
	}
	parts = this.interpolate(code, index, q + q + q);
	tabs = heretabs(code.slice(index + 3, index + parts.size - 3).replace(LASTDENT, ''));
	for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
		i = i$;
		t = parts[i$];
		if (t[0] === 'S') {
			if (i + 1 === parts.length) {
				t[1] = t[1].replace(LASTDENT, '');
			}
			t[1] = detab(t[1], tabs);
			if (i === 0) {
				t[1] = lchomp(t[1]);
			}
		}
	}
	this.addInterpolated(parts, enlines);
	return parts.size;
};
exports.doComment = function(code, index){
	var comment, end, ref$;
	comment = ~(end = code.indexOf('*/', index + 2))
		? code.slice(index, end + 2)
		: code.slice(index) + '*/';
	if ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN') {
		this.token('COMMENT', detab(comment, this.dent));
		this.token('NEWLINE', '\n');
	}
	return this.countLines(comment).length;
};
exports.doJS = function(code, lastIndex){
	var js, ref$;
	JSTOKEN.lastIndex = lastIndex;
	js = JSTOKEN.exec(code)[0] || this.carp('unterminated JS literal');
	this.token('LITERAL', (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);
	return this.countLines(js).length;
};
exports.doRegex = function(code, index){
	var divisible, ref$, input, body, flag;
	if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {
		if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === ' ' || ref$ === '=')) {
			return 0;
		}
	}
	ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
	if (input) {
		this.regex(body, flag);
	} else if (!divisible && this.last[0] !== '(') {
		this.carp('unterminated regex');
	}
	return input.length;
};
exports.doHeregex = function(code, index){
	var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
	tokens = this.tokens, last = this.last;
	parts = this.interpolate(code, index, '//');
	rest = code.slice(index + parts.size);
	flag = this.validate(/^(?:[dgimsuy]{1,7}|[?$]?)/.exec(rest)[0]);
	if (parts[1]) {
		if (flag === '$') {
			this.adi();
			this.token('(', '"');
		} else {
			tokens.push(['ID', 'RegExp', last[2], last[3]], ['CALL(', '', last[2], last[3]]);
			if (flag === '?') {
				for (i$ = parts.length - 1; i$ >= 0; --i$) {
					i = i$;
					t = parts[i$];
					if (t[0] === 'TOKENS') {
						dynaflag = parts.splice(i, 1)[0][1];
						break;
					}
				}
			}
		}
		for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
			i = i$;
			t = parts[i$];
			if (t[0] === 'TOKENS') {
				tokens.push.apply(tokens, t[1]);
			} else {
				val = deheregex(t[1]);
				if (one && !val) {
					continue;
				}
				one = tokens.push((t[0] = 'STRNUM', t[1] = this.string("'", enslash(val)), t));
			}
			tokens.push(['+-', '+', tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]]);
		}
		--tokens.length;
		if (dynaflag || flag >= 'g') {
			this.token(',', ',');
			if (dynaflag) {
				tokens.push.apply(tokens, dynaflag);
			} else {
				this.token('STRNUM', "'" + flag + "'");
			}
		}
		this.token(flag === '$' ? ')' : ')CALL', '');
	} else {
		this.regex(reslash(deheregex(parts[0][1])), flag);
	}
	return parts.size + flag.length;
};
exports.doBackslash = function(code, lastIndex){
	var ref$, input, word;
	BSTOKEN.lastIndex = lastIndex;
	ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];
	if (word) {
		this.strnum(this.string("'", word));
	} else {
		this.countLines(input);
	}
	return input.length;
};
exports.doLine = function(code, index){
	var ref$, input, tabs, length, last, that, delta, tag, val;
	ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];
	length = this.countLines(input).length;
	last = this.last;
	last.eol = true;
	last.spaced = true;
	if (index + length >= code.length) {
		return length;
	}
	if (that = tabs && (this.emender || (this.emender = RegExp('[^' + tabs.charAt() + ']'))).exec(tabs)) {
		this.carp("contaminated indent " + escape(that));
	}
	if (0 > (delta = tabs.length - this.dent)) {
		this.dedent(-delta);
		this.newline();
	} else {
		tag = last[0], val = last[1];
		if (tag === 'ASSIGN' && ((ref$ = val + '') !== '=' && ref$ !== ':=' && ref$ !== '+=') || tag === 'CREMENT' && val === '++' && (ref$ = this.tokens)[ref$.length - 2].spaced || (tag === '+-' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'MATH' || tag === 'COMPARE' || tag === 'RELATION' || tag === 'SHIFT' || tag === 'IN' || tag === 'OF' || tag === 'TO' || tag === 'BY' || tag === 'FROM' || tag === 'EXTENDS' || tag === 'IMPLEMENTS')) {
			return length;
		}
		if (delta) {
			this.indent(delta);
		} else {
			this.newline();
		}
	}
	this.fset('for', false);
	this.fset('by', false);
	return length;
};
exports.doSpace = function(code, lastIndex){
	var input;
	SPACE.lastIndex = lastIndex;
	if (input = SPACE.exec(code)[0]) {
		this.last.spaced = true;
	}
	return input.length;
};
exports.doCase = function(){
	var ref$, ref1$;
	this.fset('for', false);
	if (((ref$ = this.last[0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':') || (this.last[0] === 'INDENT' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':'))) {
		this.token('SWITCH', 'switch');
		return this.token('CASE', 'case');
	}
};
exports.doLiteral = function(code, index){
	var sym, tag, val, ref$, that;
	if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {
		return 0;
	}
	switch (tag = val = sym) {
	case '|':
		tag = 'CASE';
		if (this.doCase()) {
			return sym.length;
		}
		break;
	case '|>':
		tag = 'PIPE';
		break;
	case '`':
		tag = 'BACKTICK';
		break;
	case '<<':
	case '>>':
		tag = 'COMPOSE';
		break;
	case '<|':
		tag = 'BACKPIPE';
		break;
	case '+':
	case '-':
		tag = '+-';
		break;
	case '&&':
	case '||':
		tag = 'LOGIC';
		break;
	case '.&.':
	case '.|.':
	case '.^.':
		tag = 'BITWISE';
		break;
	case '^^':
		tag = 'CLONE';
		break;
	case '**':
	case '^':
		tag = 'POWER';
		break;
	case '?':
		if (this.last[0] === '(') {
			this.token('PARAM(', '(');
			this.token(')PARAM', ')');
			this.token('->', '->');
			this.token('ID', 'it');
		} else {
			if (this.last.spaced) {
				tag = 'LOGIC';
			}
		}
		break;
	case '/':
	case '%':
	case '%%':
		tag = 'MATH';
		break;
	case '++':
	case '--':
		tag = 'CREMENT';
		break;
	case '<<<':
	case '<<<<':
		tag = 'IMPORT';
		break;
	case ';':
		tag = 'NEWLINE';
		this.fset('by', false);
		break;
	case '..':
		this.token('LITERAL', '..', true);
		return 2;
	case '.':
		if (this.last[1] === '?') {
			this.last[0] = '?';
		}
		tag = 'DOT';
		break;
	case ',':
		switch (this.last[0]) {
		case ',':
		case '[':
		case '(':
		case 'CALL(':
			this.token('LITERAL', 'void');
			break;
		case 'FOR':
		case 'OWN':
			this.token('ID', '');
		}
		break;
	case '!=':
	case '~=':
		if (!(able(this.tokens) || ((ref$ = this.last[0]) === '(' || ref$ === 'CREMENT'))) {
			this.tokens.push(val === '!='
				? ['UNARY', '!', this.line, this.column]
				: ['UNARY', '~', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
			return 2;
		}
		// fallthrough
	case '!~=':
	case '==':
		val = (function(){
			switch (val) {
			case '~=':
				return '==';
			case '!~=':
				return '!=';
			case '==':
				return '===';
			case '!=':
				return '!==';
			}
		}());
		tag = 'COMPARE';
		break;
	case '===':
	case '!==':
		val += '=';
		// fallthrough
	case '<':
	case '>':
	case '<=':
	case '>=':
	case '<==':
	case '>==':
	case '>>=':
	case '<<=':
		tag = 'COMPARE';
		break;
	case '.<<.':
	case '.>>.':
	case '.>>>.':
	case '<?':
	case '>?':
		tag = 'SHIFT';
		break;
	case '(':
		if (!(((ref$ = this.last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LET') || this.able(true) || this.last[1] === '.@')) {
			this.token('(', '(');
			this.closes.push(')');
			this.parens.push(this.last);
			return 1;
		}
		tag = 'CALL(';
		this.closes.push(')CALL');
		break;
	case '[':
	case '{':
		this.adi();
		this.closes.push(']}'.charAt(val === '{'));
		break;
	case '}':
		if (this.inter && val !== (ref$ = this.closes)[ref$.length - 1]) {
			this.rest = code.slice(index + 1);
			return 9e9;
		}
		// fallthrough
	case ']':
	case ')':
		if (tag === ')' && ((ref$ = this.last[0]) === '+-' || ref$ === 'COMPARE' || ref$ === 'LOGIC' || ref$ === 'MATH' || ref$ === 'POWER' || ref$ === 'SHIFT' || ref$ === 'BITWISE' || ref$ === 'CONCAT' || ref$ === 'COMPOSE' || ref$ === 'RELATION' || ref$ === 'PIPE' || ref$ === 'BACKPIPE' || ref$ === 'IMPORT' || ref$ === 'CLONEPORT' || ref$ === 'ASSIGN')) {
			(ref$ = this.tokens)[ref$.length - 1][0] = (function(){
				switch (this.last[0]) {
				case 'RELATION':
					return 'BIOPR';
				case 'PIPE':
					this.parameters(false, -1);
					return 'BIOPP';
				default:
					return 'BIOP';
				}
			}.call(this));
		}
		if (')' === (tag = val = this.pair(val))) {
			this.lpar = this.parens.pop();
		}
		break;
	case '=':
	case ':':
		if (val === ':') {
			switch (this.last[0]) {
			case 'ID':
			case 'STRNUM':
			case ')':
				break;
			case '...':
				this.last[0] = 'STRNUM';
				break;
			default:
				tag = 'LABEL';
				val = '';
			}
			this.token(tag, val);
			return sym.length;
		}
		// fallthrough
	case ':=':
	case '+=':
	case '-=':
	case '*=':
	case '/=':
	case '%=':
	case '%%=':
	case '<?=':
	case '>?=':
	case '**=':
	case '^=':
	case '.&.=':
	case '.|.=':
	case '.^.=':
	case '.<<.=':
	case '.>>.=':
	case '.>>>.=':
	case '++=':
	case '|>=':
		if (this.last[1] === '.' || this.last[0] === '?' && this.adi()) {
			this.last[1] += val;
			return val.length;
		}
		if (this.last[0] === 'LOGIC') {
			(val = Object(val)).logic = this.tokens.pop()[1];
		} else if ((val === '+=' || val === '-=') && !able(this.tokens) && ((ref$ = this.last[0]) !== '+-' && ref$ !== 'UNARY' && ref$ !== 'LABEL')) {
			this.token('UNARY', val.charAt());
			val = '=';
		}
		tag = 'ASSIGN';
		break;
	case '::=':
		this.token('DOT', '.');
		this.token('ID', 'prototype');
		this.token('IMPORT', '<<');
		return sym.length;
	case '*':
		if (this.last[0] === 'FUNCTION') {
			this.last[0] = 'GENERATOR';
			return sym.length;
		}
		if (that = ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN' || ref$ === '=>') && (INLINEDENT.lastIndex = index + 1, INLINEDENT).exec(code)[0].length) {
			this.tokens.push(['LITERAL', 'void', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
			this.indent(index + that - 1 - this.dent - code.lastIndexOf('\n', index - 1));
			return that;
		}
		tag = able(this.tokens) || this.last[0] === 'CREMENT' && able(this.tokens, this.tokens.length - 1) || this.last[0] === '(' ? 'MATH' : 'STRNUM';
		break;
	case '@':
		this.adi();
		if (this.last[0] === 'DOT' && this.last[1] === '.' && (ref$ = this.tokens)[ref$.length - 2][0] === 'ID' && (ref$ = this.tokens)[ref$.length - 2][1] === 'constructor') {
			this.tokens.pop();
			this.tokens.pop();
			this.token('LITERAL', 'this', true);
			this.adi();
			this.token('ID', 'constructor', true);
		} else {
			this.token('LITERAL', 'this', true);
		}
		return 1;
	case '@@':
		this.adi();
		this.token('ID', 'constructor', true);
		return 2;
	case '&':
		this.token('LITERAL', 'arguments');
		return 1;
	case '!':
		switch (false) {
		default:
			if (!this.last.spaced) {
				if (this.last[1] === 'require') {
					this.last[0] = 'REQUIRE';
					this.last[1] = 'require!';
				} else if (able(this.tokens, null, true)) {
					this.token('CALL(', '!');
					this.token(')CALL', ')');
				} else if (this.last[1] === 'typeof') {
					this.last[1] = 'classof';
				} else if (this.last[1] === 'delete') {
					this.last[1] = 'jsdelete';
				} else {
					break;
				}
				return 1;
			}
		}
		tag = 'UNARY';
		break;
	case '|':
		tag = 'BITWISE';
		break;
	case '~':
		if (this.dotcat(val)) {
			return 1;
		}
		tag = 'UNARY';
		break;
	case '::':
		this.adi();
		val = 'prototype';
		tag = 'ID';
		break;
	case '=>':
		this.unline();
		this.fset('for', false);
		tag = 'THEN';
		break;
	default:
		if (/^!?(?:--?|~~?)>>?\*?$/.test(val)) {
			this.parameters(tag = '->');
		} else if (/^\*?<(?:--?|~~?)!?$/.test(val)) {
			this.parameters(tag = '<-');
		} else {
			switch (val.charAt(0)) {
			case '(':
				this.token('CALL(', '(');
				tag = ')CALL';
				val = ')';
				break;
			case '<':
				if (val.length < 4) {
					this.carp('unterminated words');
				}
				this.token('WORDS', val.slice(2, -2), this.adi());
				return this.countLines(val).length;
			}
		}
	}
	if ((tag === '+-' || tag === 'COMPARE' || tag === 'LOGIC' || tag === 'MATH' || tag === 'POWER' || tag === 'SHIFT' || tag === 'BITWISE' || tag === 'CONCAT' || tag === 'RELATION' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'IMPORT') && this.last[0] === '(') {
		tag = tag === 'BACKPIPE' ? 'BIOPBP' : 'BIOP';
	}
	if (tag === ',' || tag === 'CASE' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'COMPARE' || tag === 'MATH' || tag === 'POWER' || tag === 'IMPORT' || tag === 'SHIFT' || tag === 'BITWISE') {
		this.unline();
	}
	this.token(tag, val);
	return sym.length;
};
exports.token = function(tag, value, callable){
	this.tokens.push(this.last = [tag, value, this.line, this.column]);
	if (callable) {
		this.last.callable = true;
	}
	return value;
};
exports.indent = function(delta){
	this.dent += delta;
	this.dents.push(this.token('INDENT', delta));
	this.closes.push('DEDENT');
};
exports.dedent = function(debt){
	var dent;
	this.dent -= debt;
	while (debt > 0 && (dent = this.dents.pop())) {
		if (debt < dent && !this.inter) {
			this.carp("unmatched dedent (" + debt + " for " + dent + ")");
		}
		this.pair('DEDENT');
		debt -= typeof dent === 'number' ? this.token('DEDENT', dent) : dent;
	}
};
exports.newline = function(){
	var ref$;
	if (!(this.last[0] === 'NEWLINE' && this.last[1] === '\n')) {
		this.tokens.push(this.last = (ref$ = ['NEWLINE', '\n', this.line, this.column], ref$.spaced = true, ref$));
	}
};
exports.unline = function(){
	var ref$;
	if (!this.tokens[1]) {
		return;
	}
	switch (this.last[0]) {
	case 'INDENT':
		(ref$ = this.dents)[ref$.length - 1] += '';
		// fallthrough
	case 'NEWLINE':
		this.tokens.length--;
	}
};
exports.parameters = function(arrow, offset){
	var i$, ref$, i, t, ref1$;
	if (this.last[0] === ')' && ')' === this.last[1]) {
		this.lpar[0] = 'PARAM(';
		this.last[0] = ')PARAM';
		return;
	}
	if (arrow === '->') {
		this.token('PARAM(', '');
	} else {
		for (i$ = (ref$ = this.tokens).length - 1; i$ >= 0; --i$) {
			i = i$;
			t = ref$[i$];
			if ((ref1$ = t[0]) === 'NEWLINE' || ref1$ === 'INDENT' || ref1$ === 'THEN' || ref1$ === '=>' || ref1$ === '(') {
				break;
			}
		}
		this.tokens.splice(i + 1, 0, ['PARAM(', '', t[2], t[3]]);
	}
	if (offset) {
		this.tokens.splice(this.tokens.length + offset, 0, [')PARAM', '', t[2], t[3]]);
	} else {
		this.token(')PARAM', '');
	}
};
exports.interpolate = function(str, idx, end){
	var parts = [], end0 = end[0], pos = 0, i = -1, ref$, oldLine, oldColumn, ch, n = -1, inComment, id, prop, stringified, length, tag, delta, nested, clone, ref1$;
	str = str.slice(idx + end.length);
	ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
	this.countLines(end);
	while (ch = str[++i]) {
		++n;
		switch (ch) {
		case end0:
			if (end !== str.slice(i, i + end.length)) {
				continue;
			}
			parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
			this.countLines(end);
			return parts.size = pos + i + end.length * 2, parts;
		case '#':
			if (inComment) continue;
			id = (ID_INTERPOLATE.lastIndex = i + 1, ID_INTERPOLATE).exec(str)[1];
			if (!(id || str[i + 1] === '{')) {
				if (end === '//') {
					if (!n || /\s/.test(str[i - 1])) {
						inComment = true;
					}
				}
				continue;
			}
			break;
		case '\n':
			if (inComment) {
				inComment = false;
			}
			continue;
		case '\\':
			if (inComment) continue;
			++i;
			continue;
		default:
			continue;
		}
		if (i || nested && !stringified) {
			stringified = parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
			ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
		}
		if (id) {
			length = id.length;
			if (id === '@') {
				id = 'this'
			} else if (id[0] === '@') {
				prop = id.substring(1);
				if (/^\d+$/.test(prop)) {
					id = 'this[' + prop + ']'
				} else {
					id = 'this.' + camelize(prop);
				}
			} else {
				id = camelize(id);
				// try {
				// 	Function("'use strict'; var " + id);
				// } catch (e) {
				// 	this.carp("invalid variable interpolation '" + id + "'");
				// }
			}
			tag = 'ID';
			str = str.slice(delta = i + 1 + length);
			parts.push(['TOKENS', nested = [[tag, id, this.line, this.column]]]);
		} else {
			clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);
			nested = clone.tokenize(str.slice(i + 2), {
				line: this.line,
				column: this.column + 2,
				raw: true
			});
			delta = str.length - clone.rest.length;
			this.countLines(str.slice(i, delta));
			str = clone.rest;
			while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
				nested.shift();
			}
			if (nested.length) {
				nested.unshift(['(', '(', oldLine, oldColumn]);
				nested.push([')', ')', this.line, this.column - 1]);
				parts.push(['TOKENS', nested]);
			}
			ref1$ = [this.line, this.column], oldLine = ref1$[0], oldColumn = ref1$[1];
		}
		pos += delta;
		i = -1;
	}
	this.carp("missing `" + end + "`");
};
exports.addInterpolated = function(parts, nlines){
	var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;
	if (!parts[1]) {
		return this.strnum(nlines(this.string('"', parts[0][1])));
	}
	tokens = this.tokens, last = this.last;
	ref$ = !last.spaced && last[1] === '%'
		? (--tokens.length, this.last = last = tokens[tokens.length - 1], ['[', ']', [',', ',']])
		: ['(', ')', ['+-', '+']], left = ref$[0], right = ref$[1], joint = ref$[2];
	callable = this.adi();
	tokens.push([left, '"', last[2], last[3]]);
	for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
		i = i$;
		t = parts[i$];
		if (t[0] === 'TOKENS') {
			tokens.push.apply(tokens, t[1]);
		} else {
			if (i > 1 && !t[1]) {
				continue;
			}
			tokens.push(['STRNUM', nlines(this.string('"', t[1])), t[2], t[3]]);
		}
		tokens.push(joint.concat(tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]));
	}
	--tokens.length;
	this.token(right, '', callable);
};
exports.strnum = function(it){
	this.token('STRNUM', it, this.adi() || this.last[0] === 'DOT');
};
exports.regex = function(body, flag){
	try {
		RegExp(body);
	} catch (e) {
		this.carp(e.message);
	}
	if (flag === '$') {
		return this.strnum(this.string("'", enslash(body)));
	}
	return this.token('LITERAL', "/" + (body || '(?:)') + "/" + this.validate(flag));
};
exports.adi = function(){
	if (this.last.spaced || !able(this.tokens)) {
		return;
	}
	return this.token('DOT', '.');
};
exports.dotcat = function(it){
	if (this.last[1] === '.' || this.adi()) {
		return this.last[1] += it;
	}
};
exports.pair = function(it){
	var wanted, ref$;
	if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || ')CALL' === wanted && it === ')')) {
		if ('DEDENT' !== wanted) {
			this.carp("unmatched `" + it + "`");
		}
		this.dedent((ref$ = this.dents)[ref$.length - 1]);
		return this.pair(it);
	}
	this.unline();
	this.fclear();
	return this.closes.pop();
};
exports.able = function(call){
	return !this.last.spaced && able(this.tokens, null, call);
};
exports.countLines = function(it){
	var pos;
	if (!this.isAtPrefix) {
		this.column += it.length;
	}
	while (pos = 1 + it.indexOf('\n', pos)) {
		if (!this.isAtPrefix) {
			this.column = 0;
		}
		this.column += it.length - pos;
		++this.line;
		this.isAtPrefix = false;
	}
	this.charsCounted += it.length;
	return it;
};
exports.forange = function(){
	var ref$, ref1$, ref2$;
	if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) === 'NEWLINE' || ref2$ === 'INDENT')]) != null ? ref$[0] : void 8) === 'FOR' || this.last[0] === 'FOR') {
		this.fset('for', false);
		this.fset('from', true);
		return true;
	} else {
		return false;
	}
};
exports.validate = function(flag){
	var that;
	if (that = flag && /(.).*\1/.exec(flag)) {
		this.carp("duplicate regex flag `" + that[1] + "`");
	}
	return flag;
};
exports.fget = function(key){
	var ref$;
	return (ref$ = this.flags[this.closes.length]) != null ? ref$[key] : void 8;
};
exports.fset = function(key, val){
	var ref$, key$;
	((ref$ = this.flags)[key$ = this.closes.length] || (ref$[key$] = {}))[key] = val;
};
exports.fclear = function(){
	this.flags.splice(this.closes.length);
};
exports.carp = function(it){
	carp(it, this.line);
};
exports.string = function(q, body){
	return string(q, body, this.line);
};
function carp(msg, lno){
	throw SyntaxError(msg + " on line " + (-~lno));
}
function able(tokens, i, call){
	var token, tag;
	i == null && (i = tokens.length);
	tag = (token = tokens[i - 1])[0];
	return (tag === 'ID' || tag === ']' || tag === '?') || (call
		? token.callable || (tag === ')' || tag === ')CALL' || tag === 'BIOPBP') && token[1]
		: tag === '}' || tag === ')' || tag === ')CALL' || tag === 'STRNUM' || tag === 'LITERAL' || tag === 'WORDS');
}
string = (function(re){
	return function(q, body, lno){
		body = body.replace(re, function(it, oct, xu, rest){
			if (it === q || it === '\\') {
				return '\\' + it;
			}
			if (oct) {
				return '\\x' + (0x100 + parseInt(oct, 8)).toString(16).slice(1);
			}
			if (xu) {
				carp('malformed character escape sequence', lno);
			}
			if (!rest || q === rest) {
				return it;
			} else {
				return rest;
			}
		});
		return q + body + q;
	};
}.call(this, /['"]|\\(?:([0-3]?[0-7]{2}|[1-7]|0(?=[89]))|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|u\{(?:10|[\dA-Fa-f])?[\dA-Fa-f]{1,4}\}|([xu])|[\\0bfnrtv]|[^\n\S]|([\w\W]))?/g));
function heretabs(doc){
	var dent, that, ref$;
	dent = 0 / 0;
	while (that = TABS.exec(doc)) {
		dent <= (ref$ = that[0].length - 1) || (dent = ref$);
	}
	return dent;
}
TABS = /\n(?!$)[^\n\S]*/mg;
function detab(str, len){
	if (len) {
		return str.replace(detab[len] || (detab[len] = RegExp('\\n[^\\n\\S]{1,' + len + '}', 'g')), '\n');
	} else {
		return str;
	}
}
unlines = function(it){
	return it.replace(/\n[^\n\S]*/g, '');
};
enlines = function(it){
	return it.replace(/\n/g, '\\n');
};
enslash = function(it){
	return it.replace(/\\/g, '\\\\');
};
reslash = function(it){
	return it.replace(/(\\.)|\//g, (s, s1) => s1 || '\\/');
};
camelize = function(it){
	return it.replace(/-[a-z]/ig, it => it[1].toUpperCase());
};
deheregex = function(it){
	return it.replace(/(^|\s+)#.*|^\s+|\\(?= )|\\?\n+/gm, "");
	// return it.replace(/(\\)?\n\s*|\s+(?:#.*)|\n$/g, function(arg$, bs){
	// 	bs || (bs = '');
	// 	if ('\\' === bs) {
	// 		return '';
	// 	} else {
	// 		return bs;
	// 	}
	// });
};
function lchomp(it){
	return it.slice(1 + it.lastIndexOf('\n', 0));
}
function decode(val, lno){
	if (!isNaN(val)) {
		return [+val];
	}
	val = val.length > 8
		? 'ng'
		: Function('return ' + val)();
	val.length === 1 || carp('bad string in range', lno);
	return [val.charCodeAt(), true];
}
function uxxxx(it){
	return '"\\u' + ('000' + it.toString(16)).slice(-4) + '"';
}
character = typeof JSON == 'undefined' || JSON === null
	? uxxxx
	: function(it){
		switch (it) {
		case 0x2028:
		case 0x2029:
			return uxxxx(it);
		default:
			return JSON.stringify(String.fromCharCode(it));
		}
	};
function firstPass(tokens){
	var prev, i, token, tag, val, line, column, next, parens, i$, j, ts, ref$;
	prev = ['NEWLINE', '\n', 0];
	i = 0;
	while (token = tokens[++i]) {
		tag = token[0], val = token[1], line = token[2], column = token[3];
		switch (tag) {
		case 'ASSIGN':
			if (LS_KEYWORDS.includes(prev[1]) && tokens[i - 2][0] !== 'DOT') {
				carp("cannot assign to reserved word '" + prev[1] + "'", line);
			}
			break;
		case 'DOT':
			switch (false) {
			case !(prev[0] === ']' && tokens[i - 2][0] === '[' && tokens[i - 3][0] === 'DOT'):
				tokens.splice(i - 2, 3);
				tokens[i - 3][1] = '[]';
				i -= 3;
				break;
			case !(prev[0] === '}' && tokens[i - 2][0] === '{' && tokens[i - 3][0] === 'DOT'):
				tokens.splice(i - 2, 3);
				tokens[i - 3][1] = '{}';
				i -= 3;
				break;
			case !(val === '.' && token.spaced && prev.spaced):
				tokens[i] = ['COMPOSE', '<<', line, column];
				break;
			default:
				next = tokens[i + 1];
				if (prev[0] === '(' && next[0] === ')') {
					tokens[i][0] = 'BIOP';
				} else if (prev[0] === '(') {
					tokens.splice(i, 0, ['PARAM(', '(', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column], ['ID', 'it', line, column]);
				} else if (next[0] === ')') {
					tokens.splice(i + 1, 0, ['[', '[', line, column], ['ID', 'it', line, column], [']', ']', line, column]);
					parens = 1;
					LOOP: for (i$ = i + 1; i$ >= 0; --i$) {
						j = i$;
						switch (tokens[j][0]) {
						case ')':
							++parens;
							break;
						case '(':
							if (--parens === 0) {
								tokens.splice(j + 1, 0, ['PARAM(', '(', line, column], ['ID', 'it', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column]);
								break LOOP;
							}
						}
					}
				}
			}
			break;
		case 'CREMENT':
			if (!(val === '++' && (next = tokens[i + 1]))) {
				break;
			}
			ts = ['ID', 'LITERAL', 'STRNUM'];
			if (prev.spaced && token.spaced || !(prev.spaced || token.spaced) && ts.includes(prev[0]) && ts.includes(next[0])) {
				tokens[i][0] = 'CONCAT';
			}
			if (prev[0] === '(' && next[0] === ')' || prev[0] === '(' && token.spaced || next[0] === ')' && prev.spaced) {
				tokens[i][0] = 'BIOP';
			}
			break;
		case 'ID':
			if (val !== 'async') {
				break;
			}
			next = tokens[i + 1];
			if ((ref$ = next[0]) === 'FUNCTION' || ref$ === 'GENERATOR') {
				token[0] = 'ASYNC';
			}
		}
		prev = token;
		continue;
	}
}
function rewriteBlockless(tokens){
	var i, token, tag;
	i = -1;
	while (token = tokens[++i]) {
		tag = token[0];
		if (tag === 'IF' || tag === 'CLASS' || tag === 'CATCH') {
			detectEnd(tokens, i + 1, ok, go);
		}
	}
	function ok(it){
		return it[0] === 'NEWLINE' || it[0] === 'INDENT';
	}
	function go(it, i){
		var lno, cno;
		if (tag === 'IF') {
			if (it[0] !== 'INDENT' || !it[1] && !it.then || BLOCK_USERS.includes(tokens[i - 1][0])) {
				token[0] = 'POST_IF';
			}
		} else if (it[0] !== 'INDENT') {
			tokens.splice(i, 0, ['INDENT', 0, lno = tokens[i - 1][2], cno = tokens[i - 1][3]], ['DEDENT', 0, lno, cno]);
		}
	}
}
function addImplicitIndentation(tokens){
	var i, token, tag, next, indent, dedent, ref$, ref1$, idx;
	i = 0;
	while (token = tokens[++i]) {
		tag = token[0];
		if (tag !== '->' && tag !== 'THEN' && tag !== 'ELSE' && tag !== 'DEFAULT' && tag !== 'TRY' && tag !== 'FINALLY' && tag !== 'DECL') {
			continue;
		}
		switch (next = tokens[i + 1][0]) {
		case 'IF':
			if (tag === 'ELSE') {
				continue;
			}
			break;
		case 'INDENT':
		case 'THEN':
			if (tag === 'THEN') {
				tokens.splice(i--, 1);
			}
			continue;
		}
		indent = ['INDENT', 0, token[2], token[3]];
		dedent = ['DEDENT', 0];
		if (tag === 'THEN') {
			(tokens[i] = indent).then = true;
		} else {
			tokens.splice(++i, 0, indent);
		}
		switch (false) {
		case tag !== 'DECL':
			break;
		case next !== 'DOT' && next !== '?' && next !== ',' && next !== 'PIPE' && next !== 'BACKPIPE':
			--i;
			// fallthrough
		case !((next === 'ID' || next === 'STRNUM' || next === 'LITERAL') && ',' === ((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8)):
			go(0, i += 2);
			++i;
			continue;
		case !((next === '(' || next === '[' || next === '{') && ',' === ((ref1$ = tokens[idx = 1 + indexOfPair(tokens, i + 1)]) != null ? ref1$[0] : void 8)):
			go(0, idx);
			++i;
			continue;
		}
		detectEnd(tokens, i + 1, ok, go);
	}
	function ok(token, i){
		var t0, t;
		t0 = token[0];
		t = tag;
		if (tag === t0 || tag === 'THEN' && t0 === 'SWITCH') {
			tag = '';
		}
		switch (t0) {
		case 'NEWLINE':
			return token[1] !== ';';
		case 'DOT':
		case '?':
		case ',':
		case 'PIPE':
		case 'BACKPIPE':
			return tokens[i - 1].eol;
		case 'ELSE':
			return t === 'THEN';
		case 'CATCH':
			return t === 'TRY';
		case 'FINALLY':
			return t === 'TRY' || t === 'CATCH' || t === 'THEN';
		case 'CASE':
		case 'DEFAULT':
			return t === 'CASE' || t === 'THEN';
		}
	}
	function go(arg$, i){
		var prev;
		prev = tokens[i - 1];
		tokens.splice(prev[0] === ',' ? i - 1 : i, 0, (dedent[2] = prev[2], dedent[3] = prev[3], dedent));
	}
}
function addImplicitParentheses(tokens){
	var i, brackets, token, endi, ref$, tpair, tag, prev, ref1$, skipBlock, seenSwitch;
	i = 0;
	brackets = [];
	while (token = tokens[++i]) {
		if (token[1] === 'do' && tokens[i + 1][0] === 'INDENT') {
			endi = indexOfPair(tokens, i + 1);
			if (tokens[endi + 1][0] === 'NEWLINE' && ((ref$ = tokens[endi + 2]) != null ? ref$[0] : void 8) === 'WHILE') {
				token[0] = 'DO';
				tokens[endi + 2].done = true;
				tokens.splice(endi + 1, 1);
			} else {
				(token = tokens[1 + i])[0] = '(';
				(tpair = tokens[endi])[0] = ')';
				token.doblock = true;
				tokens.splice(i, 1);
			}
		}
		tag = token[0];
		prev = tokens[i - 1];
		tag === '[' && brackets.push(prev[0] === 'DOT');
		if (prev[0] === ']') {
			if (brackets.pop()) {
				prev.index = true;
			} else {
				continue;
			}
		}
		if (!(((ref1$ = prev[0]) === 'FUNCTION' || ref1$ === 'GENERATOR' || ref1$ === 'LET' || ref1$ === 'WHERE') || prev.spaced && able(tokens, i, true))) {
			continue;
		}
		if (token.doblock) {
			token[0] = 'CALL(';
			tpair[0] = ')CALL';
			continue;
		}
		if (!exp(token)) {
			continue;
		}
		if (tag === 'CREMENT') {
			if (token.spaced || !CHAIN.includes((ref1$ = tokens[i + 1]) != null ? ref1$[0] : void 8)) {
				continue;
			}
		}
		skipBlock = seenSwitch = false;
		tokens.splice(i++, 0, ['CALL(', '', token[2], token[3]]);
		detectEnd(tokens, i, ok, go);
	}
	function exp(token){
		var tag;
		tag = token[0];
		return ARG.includes(tag) || !token.spaced && (tag === '+-' || tag === 'CLONE');
	}
	function ok(token, i){
		var tag, ref$, pre;
		tag = token[0];
		if (tag === 'POST_IF' || tag === 'PIPE' || tag === 'BACKPIPE') {
			return true;
		}
		if (!skipBlock) {
			if (token.alias && ((ref$ = token[1]) === '&&' || ref$ === '||' || ref$ === 'xor') || (tag === 'TO' || tag === 'BY' || tag === 'IMPLEMENTS')) {
				return true;
			}
		}
		pre = tokens[i - 1];
		switch (tag) {
		case 'NEWLINE':
			return pre[0] !== ',';
		case 'DOT':
		case '?':
			return !skipBlock && (pre.spaced || pre[0] === 'DEDENT');
		case 'SWITCH':
			seenSwitch = true;
			// fallthrough
		case 'IF':
		case 'CLASS':
		case 'FUNCTION':
		case 'GENERATOR':
		case 'LET':
		case 'WITH':
		case 'CATCH':
			skipBlock = true;
			break;
		case 'CASE':
			if (seenSwitch) {
				skipBlock = true;
			} else {
				return true;
			}
			break;
		case 'INDENT':
			if (skipBlock) {
				return skipBlock = false;
			}
			return !BLOCK_USERS.includes(pre[0]);
		case 'WHILE':
			if (token.done) {
				return false;
			}
			// fallthrough
		case 'FOR':
			skipBlock = true;
			return able(tokens, i) || pre[0] === 'CREMENT' || pre[0] === '...' && pre.spaced;
		}
		return false;
	}
	function go(token, i){
		tokens.splice(i, 0, [')CALL', '', tokens[i - 1][2], tokens[i - 1][3]]);
	}
}
function addImplicitBraces(tokens){
	var stack, i, token, tag, start, paren, index, pre, ref$, ref1$, inline;
	stack = [];
	i = 0;
	while (token = tokens[++i]) {
		if (':' !== (tag = token[0])) {
			switch (false) {
			case !CLOSERS.includes(tag):
				start = stack.pop();
				break;
			case !OPENERS.includes(tag):
				if (tag === 'INDENT' && tokens[i - 1][0] === '{') {
					tag = '{';
				}
				stack.push([tag, i]);
			}
			continue;
		}
		paren = tokens[i - 1][0] === ')';
		index = paren
			? start[1]
			: i - 1;
		pre = tokens[index - 1];
		if (!(((ref1$ = pre[0]) === ':' || ref1$ === 'ASSIGN' || ref1$ === 'IMPORT') || ((ref$ = stack[stack.length - 1]) != null ? ref$[0] : void 8) !== '{')) {
			continue;
		}
		stack.push(['{']);
		inline = !pre.doblock && ((ref1$ = pre[0]) !== 'NEWLINE' && ref1$ !== 'INDENT');
		while (((ref1$ = tokens[index - 2]) != null ? ref1$[0] : void 8) === 'COMMENT') {
			index -= 2;
		}
		tokens.splice(index, 0, ['{', '{', tokens[index][2], tokens[index][3]]);
		detectEnd(tokens, ++i + 1, ok, go);
	}
	function ok(token, i){
		var tag, ref$, t1, ref1$;
		switch (tag = token[0]) {
		case ',':
			break;
		case 'NEWLINE':
			if (inline) {
				return true;
			}
			break;
		case 'DEDENT':
			return true;
		case 'POST_IF':
		case 'FOR':
		case 'WHILE':
			return inline;
		default:
			return false;
		}
		t1 = (ref$ = tokens[i + 1]) != null ? ref$[0] : void 8;
		return t1 !== (tag === ',' ? 'NEWLINE' : 'COMMENT') && ':' !== ((ref1$ = tokens[t1 === '('
			? 1 + indexOfPair(tokens, i + 1)
			: i + 2]) != null ? ref1$[0] : void 8);
	}
	function go(token, i){
		tokens.splice(i, 0, ['}', '', token[2], token[3]]);
	}
}
function expandLiterals(tokens){
	var i, fromNum, token, sig, ref$, ref1$, ref2$, lno, cno, ref3$, ref4$, char, toNum, tochar, byNum, byp, ref5$, ts, enc, add, i$, n, ref6$, ref7$, len$, word, that;
	i = 0;
	while (token = tokens[++i]) {
		switch (token[0]) {
		case 'STRNUM':
			if (~'-+'.indexOf(sig = token[1].charAt(0))) {
				token[1] = token[1].slice(1);
				tokens.splice(i++, 0, ['+-', sig, token[2], token[3]]);
			}
			if (token.callable) {
				continue;
			}
			break;
		case 'TO':
		case 'TIL':
			if (!(tokens[i - 1][0] === '[' && ((tokens[i + 2][0] === ']' && (((ref2$ = tokens[i + 1][1].charAt(0)) === '\'' || ref2$ === '"'))) || (tokens[i + 2][0] === 'BY' && ((ref$ = tokens[i + 3]) != null ? ref$[0] : void 8) === 'STRNUM' && ((ref1$ = tokens[i + 4]) != null ? ref1$[0] : void 8) === ']')))) {
				continue;
			}
			if (tokens[i + 2][0] === 'BY') {
				tokens[i + 2][0] = 'RANGE_BY';
			}
			token.op = token[1];
			fromNum = 0;
			// fallthrough
		case 'RANGE':
			lno = token[2];
			cno = token[3];
			if (fromNum != null || (tokens[i - 1][0] === '[' && tokens[i + 1][0] === 'STRNUM' && ((tokens[i + 2][0] === ']' && (((ref4$ = tokens[i + 1][1].charAt(0)) === "'" || ref4$ === '"'))) || (tokens[i + 2][0] === 'RANGE_BY' && ((ref2$ = tokens[i + 3]) != null ? ref2$[0] : void 8) === 'STRNUM' && ((ref3$ = tokens[i + 4]) != null ? ref3$[0] : void 8) === ']')))) {
				if (fromNum == null) {
					ref4$ = decode(token[1], lno), fromNum = ref4$[0], char = ref4$[1];
				}
				ref4$ = decode(tokens[i + 1][1], lno), toNum = ref4$[0], tochar = ref4$[1];
				if (toNum == null || char ^ tochar) {
					carp('bad "to" in range', lno);
				}
				byNum = 1;
				if (byp = ((ref4$ = tokens[i + 2]) != null ? ref4$[0] : void 8) === 'RANGE_BY') {
					if (!(byNum = +((ref5$ = tokens[i + 3]) != null ? ref5$[1] : void 8))) {
						carp('bad "by" in range', tokens[i + 2][2]);
					}
				} else if (fromNum > toNum) {
					byNum = -1;
				}
				ts = [];
				enc = char ? character : String;
				add = fn$;
				if (token.op === 'to') {
					for (i$ = fromNum; byNum < 0 ? i$ >= toNum : i$ <= toNum; i$ += byNum) {
						n = i$;
						add();
					}
				} else {
					for (i$ = fromNum; byNum < 0 ? i$ > toNum : i$ < toNum; i$ += byNum) {
						n = i$;
						add();
					}
				}
				ts.pop() || carp('empty range', lno);
				tokens.splice.apply(tokens, [i, 2 + 2 * byp].concat(arrayFrom$(ts)));
				i += ts.length - 1;
			} else {
				token[0] = 'STRNUM';
				if (((ref6$ = tokens[i + 2]) != null ? ref6$[0] : void 8) === 'RANGE_BY') {
					tokens.splice(i + 2, 1, ['BY', 'by', lno, cno]);
				}
				tokens.splice(i + 1, 0, ['TO', token.op, lno, cno]);
			}
			fromNum = null;
			break;
		case 'WORDS':
			ts = [['[', '[', lno = token[2], cno = token[3]]];
			for (i$ = 0, len$ = (ref7$ = token[1].match(/\S+/g) || '').length; i$ < len$; ++i$) {
				word = ref7$[i$];
				ts.push(['STRNUM', string("'", word, lno), lno, cno], [',', ',', lno, cno]);
			}
			tokens.splice.apply(tokens, [i, 1].concat(arrayFrom$(ts), [[']', ']', lno, cno]]));
			i += ts.length;
			break;
		case 'INDENT':
			if (that = tokens[i - 1]) {
				if (that[1] === 'new') {
					tokens.splice(i++, 0, ['PARAM(', '', token[2], token[3]], [')PARAM', '', token[2], token[3]], ['->', '', token[2], token[3]]);
				} else if ((ref7$ = that[0]) === 'FUNCTION' || ref7$ === 'GENERATOR' || ref7$ === 'LET') {
					tokens.splice(i, 0, ['CALL(', '', token[2], token[3]], [')CALL', '', token[2], token[3]]);
					i += 2;
				}
			}
			continue;
		case 'LITERAL':
		case '}':
			break;
		case ')':
		case ')CALL':
			if (token[1]) {
				continue;
			}
			break;
		case ']':
			if (token.index) {
				continue;
			}
			break;
		case 'CREMENT':
			if (!able(tokens, i)) {
				continue;
			}
			break;
		case 'BIOP':
			if (!token.spaced && ((ref7$ = token[1]) === '+' || ref7$ === '-') && tokens[i + 1][0] !== ')') {
				tokens[i][0] = '+-';
			}
			continue;
		default:
			continue;
		}
		if (token.spaced && ARG.includes(tokens[i + 1][0])) {
			tokens.splice(++i, 0, [',', ',', token[2], token[3]]);
		}
	}
	function fn$(){
		if (0x10000 < ts.push(['STRNUM', enc(n), lno, cno], [',', ',', lno, cno])) {
			carp('range limit exceeded', lno);
		}
	}
}
function detectEnd(tokens, i, ok, go){
	var levels, token, tag;
	levels = 0;
	for (; token = tokens[i]; ++i) {
		if (!levels && ok(token, i)) {
			return go(token, i);
		}
		tag = token[0];
		if (0 > (levels += OPENERS.includes(tag) || -CLOSERS.includes(tag))) {
			return go(token, i);
		}
	}
}
function indexOfPair(tokens, i){
	var level, end, start, that;
	level = 1;
	end = INVERSES[start = tokens[i][0]];
	while (that = tokens[++i]) {
		switch (that[0]) {
		case start:
			++level;
			break;
		case end:
			if (!--level) {
				return i;
			}
		}
	}
	return -1;
}
KEYWORDS_SHARED = ['true', 'false', 'null', 'this', 'void', 'super', 'return', 'throw', 'break', 'continue', 'if', 'else', 'for', 'while', 'switch', 'case', 'default', 'try', 'catch', 'finally', 'function', 'class', 'extends', 'implements', 'new', 'do', 'delete', 'typeof', 'in', 'instanceof', 'let', 'with', 'var', 'const', 'debugger', 'yield'];
KEYWORDS_UNUSED = ['enum', 'interface', 'package', 'private', 'protected', 'public', 'static'];
JS_KEYWORDS = KEYWORDS_SHARED.concat(KEYWORDS_UNUSED);
LS_KEYWORDS = ['xor', 'match', 'where'];
ID = /((?!\s)[a-z_$\xAA-\uFFDC](?:[\w$\xAA-\uFFDC]|-[a-z])*)([^\n\S]*:(?![:=]))?|/ig;
ID_INTERPOLATE = /((?!\s)(?:@?[a-z_$\xAA-\uFFDC](?:[\w$\xAA-\uFFDC]|-[a-z])*)|@\d*)([^\n\S]*:(?![:=]))?|/ig;
SYMBOL = /[-\/^]=|[/%+:*]{1,2}=|\|>=|\.(?:[&\|\^]|<<|>>>?)\.=?|\.{1,3}|\^\^|\*?<(?:--?|~~?)!?|!?(?:--?|~~?)>>?\*?|([-+&|:])\1|\/\/|%%|&|\([^\n\S]*\)|[!=]==?|!?\~=|@@?|<\[(?:[\s\S]*?\]>)?|<<<<?|<\||[<>]==|<<=|>>=|<<|>>|[<>]\??=?|\|>|\||=>|\*\*|\^|`|[^\s#]?/g;
SPACE = /[^\n\S]*(?:#.*)?/g;
MULTIDENT = /(?:\s*#.*)*(?:\n([^\n\S]*))*/g;
SIMPLESTR = /'[^\\']*(?:\\[\s\S][^\\']*)*'|/g;
JSTOKEN = /``[^\\`]*(?:\\[\s\S][^\\`]*)*``|/g;
BSTOKEN = RegExp('\\\\(?:(\\S[^\\s,;)}\\]]*)|(?:' + SPACE.source + '\\n?)*)', 'g');
NUMBER = /0x[\dA-Fa-f][\dA-Fa-f_]*n?|(\d*)~([\dA-Za-z]\w*)|\d[\d_]*n|((\d[\d_]*)(\.\d[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)[$\w]*|/g;
NUMBER_OMIT = /_+/g;
REGEX = /\/([^[\/\n\\]*(?:(?:\\.|\[[^\]\n\\]*(?:\\.[^\]\n\\]*)*\])[^[\/\n\\]*)*)\/([dgimsuy]{1,7}|\$?)|/g;
HEREGEX_OMIT = /\s+(?:#.*)?/g;
LASTDENT = /\n[^\n\S]*$/;
INLINEDENT = /[^\n\S]*[^#\s]?/g;
NONASCII = /[\x80-\uFFFF]/;
OPENERS = ['(', '[', '{', 'CALL(', 'PARAM(', 'INDENT'];
CLOSERS = [')', ']', '}', ')CALL', ')PARAM', 'DEDENT'];
INVERSES = import$((function(){
	var i$, ref$, len$, resultObj$ = {};
	for (i$ = 0, len$ = (ref$ = OPENERS).length; i$ < len$; ++i$) {
		i = i$;
		o = ref$[i$];
		resultObj$[o] = CLOSERS[i];
	}
	return resultObj$;
}()), (function(){
	var i$, ref$, len$, resultObj$ = {};
	for (i$ = 0, len$ = (ref$ = CLOSERS).length; i$ < len$; ++i$) {
		i = i$;
		c = ref$[i$];
		resultObj$[c] = OPENERS[i];
	}
	return resultObj$;
}()));
CHAIN = ['(', '{', '[', 'ID', 'STRNUM', 'LITERAL', 'LET', 'WITH', 'WORDS'];
ARG = CHAIN.concat(['...', 'UNARY', 'YIELD', 'CREMENT', 'PARAM(', 'FUNCTION', 'GENERATOR', 'IF', 'SWITCH', 'TRY', 'CLASS', 'RANGE', 'LABEL', 'DECL', 'DO', 'BIOPBP']);
BLOCK_USERS = [',', ':', '->', 'ELSE', 'ASSIGN', 'IMPORT', 'UNARY', 'DEFAULT', 'TRY', 'FINALLY', 'HURL', 'DECL', 'DO', 'LET', 'FUNCTION', 'GENERATOR', '...'];
function clone$(it){
	function fun(){} fun.prototype = it;
	return new fun;
}
function import$(obj, src){
	var own = {}.hasOwnProperty;
	for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	return obj;
}
},{}],4:[function(require,module,exports){
(function (global){
// Generated by LiveScript 1.6.1
module.exports = function(LiveScript){
	var fs, path, events;
	fs = require('fs');
	path = require('path');
	events = require('events');
	LiveScript.run = function(code, options, arg$){
		var filename, ref, js, context, main, dirname;
		if (options != null) {
			filename = options.filename;
		}
		ref$ = arg$ != null
			? arg$
			: {}, js = ref$.js, context = ref$.context;
		main = require.main;
		dirname = filename
			? path.dirname(fs.realpathSync(filename = path.resolve(filename)))
			: filename = '.';
		main.paths = main.constructor._nodeModulePaths(dirname);
		main.filename = filename;
		if (!js) {
			code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = false, ref$));
			if (code.code) {
				code = code.code;
			}
		}
		if (context) {
			global.__runContext = context;
			code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
		}
		filename += '(js)';
		try {
			return main._compile(code, filename);
		} catch (e) {
			throw hackTrace(e, code, filename);
		}
	};
	if (isNode) {
		Object.assign(LiveScript, require('events').EventEmitter.prototype);
	}
	require.extensions['.ls'] = function(module, filename){
		var file, js;
		file = fs.readFileSync(filename, 'utf8');
		js = '.json.ls' === filename.substr(-8)
			? 'module.exports = ' + LiveScript.compile(file, {
				filename: filename,
				json: true
			})
			: LiveScript.compile(file, {
				filename: filename,
				bare: false,
				map: "embedded"
			}).code;
		try {
			return module._compile(js, filename);
		} catch (e) {
			throw hackTrace(e, js, filename);
		}
	};
};
function hackTrace(error, js, filename){
	var stack, traces, i$, len$, i, trace, index, lno, end, length, lines, j$, ref$, n;
	if (error != null) {
		stack = error.stack;
	}
	if (!stack) {
		return error;
	}
	traces = stack.split('\n');
	if (!(traces.length > 1)) {
		return error;
	}
	for (i$ = 0, len$ = traces.length; i$ < len$; ++i$) {
		i = i$;
		trace = traces[i$];
		if (0 > (index = trace.indexOf("(" + filename + ":"))) {
			continue;
		}
		lno = (/:(\d+):/.exec(trace.slice(index + filename.length)) || '')[1];
		if (!(lno = +lno)) {
			continue;
		}
		end = lno + 4;
		length = ('' + end).length;
		lines || (lines = js.split('\n'));
		for (j$ = 1 > (ref$ = lno - 4) ? 1 : ref$; j$ <= end; ++j$) {
			n = j$;
			traces[i] += "\n" + ('    ' + n).slice(-length) + "" + '|+'.charAt(n === lno) + " " + [lines[n - 1]];
		}
	}
	return error.stack = traces.join('\n'), error;
}
function import$(obj, src){
	var own = {}.hasOwnProperty;
	for (var key in src) if (own.call(src, key)) obj[key] = src[key];
	return obj;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (){
/* parser generated by jison 0.4.18 */
/*
	Returns a Parser object of the following structure:

	Parser: {
		yy: {}
	}

	Parser.prototype: {
		yy: {},
		trace: function(),
		symbols_: {associative list: name ==> number},
		terminals_: {associative list: number ==> name},
		productions_: [...],
		performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
		table: [...],
		defaultActions: {...},
		parseError: function(str, hash),
		parse: function(input),

		lexer: {
				EOF: 1,
				parseError: function(str, hash),
				setInput: function(input),
				input: function(),
				unput: function(str),
				more: function(),
				less: function(n),
				pastInput: function(),
				upcomingInput: function(),
				showPosition: function(),
				test_match: function(regex_match_array, rule_index),
				next: function(),
				lex: function(),
				begin: function(condition),
				popState: function(),
				_currentRules: function(),
				topState: function(),
				pushState: function(condition),

				options: {
						ranges: boolean           (optional: true ==> token location info will include a .range[] member)
						flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
						backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
				},

				performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
				rules: [...],
				conditions: {associative list: name ==> set},
		}
	}


	token location info (@$, _$, etc.): {
		first_line: n,
		last_line: n,
		first_column: n,
		last_column: n,
		range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	}


	the parseError function receives a 'hash' object with these members for lexer and parser errors: {
		text:        (matched text)
		token:       (the produced terminal token, if any)
		line:        (yylineno)
	}
	while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
		loc:         (yylloc)
		expected:    (string describing the set of expected tokens)
		recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	}
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,60],$V1=[1,31],$V2=[1,34],$V3=[1,35],$V4=[1,36],$V5=[1,37],$V6=[1,38],$V7=[1,8],$V8=[1,15],$V9=[1,14],$Va=[1,39],$Vb=[1,41],$Vc=[1,29],$Vd=[1,6],$Ve=[1,10],$Vf=[1,9],$Vg=[1,11],$Vh=[1,16],$Vi=[1,17],$Vj=[1,18],$Vk=[1,19],$Vl=[1,20],$Vm=[1,21],$Vn=[1,22],$Vo=[1,23],$Vp=[1,44],$Vq=[1,24],$Vr=[1,25],$Vs=[1,26],$Vt=[1,27],$Vu=[1,28],$Vv=[1,30],$Vw=[1,43],$Vx=[1,45],$Vy=[1,20,25,47],$Vz=[20,47],$VA=[2,64],$VB=[1,49],$VC=[1,50],$VD=[1,51],$VE=[1,52],$VF=[1,53],$VG=[1,54],$VH=[1,55],$VI=[1,56],$VJ=[1,57],$VK=[1,58],$VL=[1,59],$VM=[1,60],$VN=[1,61],$VO=[1,62],$VP=[1,63],$VQ=[30,46,47,48],$VR=[2,50],$VS=[1,68],$VT=[1,67],$VU=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102,105],$VV=[2,75],$VW=[1,77],$VX=[1,78],$VY=[1,73],$VZ=[1,79],$V_=[1,71],$V$=[1,72],$V01=[1,74],$V11=[1,75],$V21=[1,83],$V31=[1,87],$V41=[1,86],$V51=[1,84],$V61=[1,95],$V71=[1,109],$V81=[48,105],$V91=[2,201],$Va1=[1,113],$Vb1=[2,1],$Vc1=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103,104,105],$Vd1=[2,2],$Ve1=[19,46,47,48],$Vf1=[1,120],$Vg1=[1,119],$Vh1=[22,46,47],$Vi1=[2,156],$Vj1=[1,130],$Vk1=[1,125],$Vl1=[1,128],$Vm1=[1,129],$Vn1=[25,47],$Vo1=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,99,102,103,104,105],$Vp1=[30,47,48],$Vq1=[2,58],$Vr1=[1,169],$Vs1=[12,19,20,30,46,47,48],$Vt1=[2,55],$Vu1=[2,71],$Vv1=[12,46,47,48],$Vw1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,66,67,68,70,71,72,79,81,82,102,105],$Vx1=[20,46,47,48],$Vy1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,79,81,82,102,105],$Vz1=[1,206],$VA1=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,102,105],$VB1=[1,209],$VC1=[46,48,82],$VD1=[2,203],$VE1=[1,215],$VF1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,82,102,105],$VG1=[19,47,48],$VH1=[1,227],$VI1=[20,22,46,47],$VJ1=[9,13,20,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],$VK1=[2,165],$VL1=[1,251],$VM1=[19,20,22,47,48,81,102],$VN1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,62,63,66,67,68,70,71,72,79,81,82,102,105],$VO1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,63,67,71,72,79,81,82,102,105],$VP1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,62,63,67,70,71,72,79,81,82,102,105],$VQ1=[1,264],$VR1=[1,265],$VS1=[2,59],$VT1=[12,47,48],$VU1=[20,47,48],$VV1=[1,302],$VW1=[1,303],$VX1=[1,311],$VY1=[4,7,14,16,21,23,29,31,32,38,41,44,48,49,59,60,61,75,76,77,78,80,81,83,84,85,90,93,97,102],$VZ1=[1,336],$V_1=[1,337],$V$1=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,88,89,102,105],$V02=[2,46],$V12=[1,369];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"Chain":3,"ID":4,"KeyLike":5,"List":6,"LITERAL":7,"Index":8,"CALL(":9,"ArgList":10,"OptComma":11,")CALL":12,"?":13,"LET":14,"Block":15,"[":16,"Expression":17,"LoopHeads":18,"]":19,"DEDENT":20,"{":21,"}":22,"(":23,"BIOP":24,")":25,"BIOPR":26,"BIOPBP":27,"BIOPP":28,"PARAM(":29,")PARAM":30,"UNARY":31,"CREMENT":32,"BACKTICK":33,"TO":34,"BY":35,"FROM":36,"DOT":37,"WITH":38,"LoopHead":39,"Else":40,"STRNUM":41,"Parenthetical":42,"Properties":43,"LABEL":44,"Arg":45,",":46,"NEWLINE":47,"INDENT":48,"...":49,"Lines":50,"Line":51,"<-":52,"COMMENT":53,"REQUIRE":54,"SplatChain":55,"CLONEPORT":56,"ASSIGN":57,"IMPORT":58,"+-":59,"CLONE":60,"YIELD":61,"COMPARE":62,"LOGIC":63,"MATH":64,"POWER":65,"SHIFT":66,"BITWISE":67,"CONCAT":68,"COMPOSE":69,"RELATION":70,"PIPE":71,"BACKPIPE":72,"!?":73,"->":74,"FUNCTION":75,"GENERATOR":76,"ASYNC":77,"IF":78,"POST_IF":79,"DO":80,"WHILE":81,"CASE":82,"HURL":83,"JUMP":84,"SWITCH":85,"Exprs":86,"Cases":87,"DEFAULT":88,"ELSE":89,"TRY":90,"CATCH":91,"FINALLY":92,"CLASS":93,"OptExtends":94,"OptImplements":95,"EXTENDS":96,"DECL":97,"KeyColon":98,":":99,"Property":100,"Body":101,"FOR":102,"IN":103,"OF":104,"IMPLEMENTS":105,"Root":106,"$accept":0,"$end":1},
terminals_: {2:"error",4:"ID",7:"LITERAL",9:"CALL(",12:")CALL",13:"?",14:"LET",16:"[",19:"]",20:"DEDENT",21:"{",22:"}",23:"(",24:"BIOP",25:")",26:"BIOPR",27:"BIOPBP",28:"BIOPP",29:"PARAM(",30:")PARAM",31:"UNARY",32:"CREMENT",33:"BACKTICK",34:"TO",35:"BY",36:"FROM",37:"DOT",38:"WITH",41:"STRNUM",44:"LABEL",46:",",47:"NEWLINE",48:"INDENT",49:"...",52:"<-",53:"COMMENT",54:"REQUIRE",56:"CLONEPORT",57:"ASSIGN",58:"IMPORT",59:"+-",60:"CLONE",61:"YIELD",62:"COMPARE",63:"LOGIC",64:"MATH",65:"POWER",66:"SHIFT",67:"BITWISE",68:"CONCAT",69:"COMPOSE",70:"RELATION",71:"PIPE",72:"BACKPIPE",73:"!?",74:"->",75:"FUNCTION",76:"GENERATOR",77:"ASYNC",78:"IF",79:"POST_IF",80:"DO",81:"WHILE",82:"CASE",83:"HURL",84:"JUMP",85:"SWITCH",88:"DEFAULT",89:"ELSE",90:"TRY",91:"CATCH",92:"FINALLY",93:"CLASS",96:"EXTENDS",97:"DECL",99:":",102:"FOR",103:"IN",104:"OF",105:"IMPLEMENTS"},
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,2],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[3,3],[3,3],[5,1],[5,1],[8,2],[8,2],[8,2],[6,4],[6,4],[6,5],[6,5],[10,0],[10,1],[10,3],[10,4],[10,6],[45,1],[45,2],[45,1],[11,0],[11,1],[50,0],[50,1],[50,3],[50,2],[51,1],[51,2],[51,6],[51,1],[51,1],[51,2],[15,3],[55,2],[17,3],[17,3],[17,5],[17,1],[17,3],[17,3],[17,6],[17,3],[17,6],[17,2],[17,2],[17,3],[17,2],[17,3],[17,3],[17,3],[17,4],[17,4],[17,4],[17,2],[17,2],[17,2],[17,3],[17,3],[17,3],[17,6],[17,5],[17,1],[17,2],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,2],[17,6],[17,6],[17,6],[17,7],[17,7],[17,4],[17,3],[17,4],[17,6],[17,2],[17,5],[17,1],[17,1],[17,2],[17,3],[17,5],[17,5],[17,2],[17,4],[17,4],[17,2],[17,2],[17,4],[17,6],[17,5],[17,7],[17,4],[17,5],[17,4],[17,3],[17,2],[17,2],[17,5],[86,1],[86,3],[98,2],[98,2],[100,2],[100,5],[100,1],[100,2],[100,1],[43,0],[43,1],[43,3],[43,4],[43,4],[42,3],[101,1],[101,1],[101,3],[40,0],[40,2],[40,5],[39,4],[39,6],[39,6],[39,8],[39,2],[39,4],[39,4],[39,6],[39,4],[39,6],[39,6],[39,8],[39,6],[39,5],[39,8],[39,7],[39,8],[39,7],[39,10],[39,9],[39,10],[39,9],[39,2],[39,4],[39,4],[39,6],[18,1],[18,2],[18,3],[18,3],[87,3],[87,4],[94,2],[94,0],[95,2],[95,0],[106,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 5:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].add($$[$0]));
break;
case 6:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 7:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 8:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
break;
case 9:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 10:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 11:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 12: case 18: case 20:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 13:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 14:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 15:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
				? yy.Binary($$[$0-1].slice(1)).invertIt()
				: yy.Binary($$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],'!' === $$[$0-2].charAt(0)
				? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
				: yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 17:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
				? yy.Binary($$[$0-1].slice(1), $$[$0-2]).invertIt()
				: yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 19:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 22: case 23:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Unary($$[$0-1]))));
break;
case 24:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 25:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 26:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 27:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
				from: $$[$0-3],
				op: $$[$0-2],
				to: $$[$0-1],
				inComprehension: true
			}))));
break;
case 28:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], new yy.For({
				from: $$[$0-5],
				op: $$[$0-4],
				to: $$[$0-3],
				step: $$[$0-1],
				inComprehension: true
			}))));
break;
case 29:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({
				from: $$[$0-3],
				op: $$[$0-2],
				to: $$[$0-1],
				inComprehension: true
			}))));
break;
case 30:
this.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0-1], new yy.For({
				from: $$[$0-5],
				op: $$[$0-4],
				to: $$[$0-3],
				step: $$[$0-1],
				inComprehension: true
			}))));
break;
case 31:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
				from: yy.Chain(yy.Literal(0)),
				op: $$[$0-2],
				to: $$[$0-1],
				inComprehension: true
			}))));
break;
case 32:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({
				from: yy.Chain(yy.Literal(0)),
				op: $$[$0-4],
				to: $$[$0-3],
				step: $$[$0-1],
				inComprehension: true
			}))));
break;
case 33:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.StepSlice({
				op: $$[$0-4],
				target: $$[$0-8],
				from: $$[$0-5],
				to: $$[$0-3],
				step: $$[$0-1]
			}))));
break;
case 34:
this.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-7],_$[$0], new yy.StepSlice({
				op: $$[$0-4],
				target: $$[$0-7],
				from: yy.Literal(0),
				to: $$[$0-3],
				step: $$[$0-1]
			}))));
break;
case 35:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.Slice({
				type: $$[$0-2],
				target: $$[$0-6],
				from: $$[$0-3],
				to: $$[$0-1]
			}))));
break;
case 36:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({
				type: $$[$0-1],
				target: $$[$0-5],
				from: $$[$0-2]
			}))));
break;
case 37:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({
				type: $$[$0-2],
				target: $$[$0-5],
				to: $$[$0-1]
			}))));
break;
case 38:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
				type: $$[$0-1],
				target: $$[$0-4]
			}))));
break;
case 39:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.Cascade($$[$0-1], $$[$0], 'with'))));
break;
case 40:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain($$[$0-2].addBody($$[$0-1]).addElse($$[$0])));
break;
case 41:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 42: case 55: case 58: case 59: case 63: case 64: case 162: case 163:

break;
case 43:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Index(yy.L(_$[$0],_$[$0],yy.Key($$[$0])), $$[$0-1], true));
break;
case 44: case 45:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Index($$[$0], $$[$0-1], true));
break;
case 46:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 47:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 48:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 49:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 50: case 156:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
case 51: case 147: case 157: case 194:
this.$ = yy.L(_$[$0], _$[$0],[$$[$0]]);
break;
case 52: case 148: case 158: case 196: case 197:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].concat($$[$0]));
break;
case 53: case 159:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 54:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 56:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 57:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 60:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 62: case 164:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
case 65:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));
break;
case 66:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 67: case 155:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 68:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
case 69:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 70:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 71:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 72:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
				prec: 'yy.UNARY'
			})), $$[$0], false));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
				prec: 'yy.UNARY'
			})), $$[$0].unwrap(), false));
break;
case 74:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 75:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 76:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
case 79:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import($$[$0-2], $$[$0], $$[$0-1] === '<<<<'));
break;
case 80:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === '<<<<'));
break;
case 81:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0].unwrap()));
break;
case 82:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1].unwrap(), true));
break;
case 83:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0].unwrap())));
break;
case 84:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1], true));
break;
case 85: case 86: case 87:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0].unwrap(), [$$[$0-2]], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 88: case 89: case 90:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Assign(yy.Splat($$[$0].unwrap()), [$$[$0-3]], yy.L(_$[$0-2],_$[$0-2],yy.Box($$[$0-2]))));
break;
case 91: case 92: case 93:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0]));
break;
case 94: case 95: case 96:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0])));
break;
case 97:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 98:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 99:
this.$ = yy.L(_$[$0], _$[$0],yy.Yield($$[$0]));
break;
case 100:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
case 110:
this.$ = yy.L(_$[$0-2], _$[$0],'!' === $$[$0-1].charAt(0)
				? yy.Binary($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert()
				: yy.Binary($$[$0-1], $$[$0-2], $$[$0]));
break;
case 111:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe($$[$0], $$[$0-1]));
break;
case 112:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 113:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 114:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1]), />>/.test($$[$0-1])));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true, false).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true, true).named($$[$0-5]));
break;
case 119:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless')).addElse($$[$0]));
break;
case 120:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Try($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 138:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Try($$[$0-3], $$[$0-1], yy.L(_$[$0-2],_$[$0-1], $$[$0])));
break;
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Class({
				title: $$[$0-3].unwrap(),
				sup: $$[$0-2],
				mixins: $$[$0-1],
				body: $$[$0]
			}));
break;
case 142:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Class({
				sup: $$[$0-2],
				mixins: $$[$0-1],
				body: $$[$0]
			}));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 149:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Key($$[$0-1]));
break;
case 150:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1]);
break;
case 151:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop($$[$0-1], $$[$0]));
break;
case 152:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Prop($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 153:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(null, $$[$0]));
break;
case 154:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.Splat(), $$[$0]));
break;
case 160:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 161:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Parens($$[$0-1].chomp().unwrap(), false, $$[$0-2] === '"', yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 165: case 201: case 203:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 166: case 200: case 202:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
case 167:
this.$ = yy.L(_$[$0-4], _$[$0],yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless').addElse($$[$0]));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
				kind: $$[$0-3],
				item: $$[$0-2].unwrap(),
				index: $$[$0-1],
				source: $$[$0]
			}));
break;
case 169:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
				kind: $$[$0-5],
				item: $$[$0-4].unwrap(),
				index: $$[$0-3],
				source: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 170:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
				kind: $$[$0-5],
				item: $$[$0-4].unwrap(),
				index: $$[$0-3],
				source: $$[$0-2],
				step: $$[$0]
			}));
break;
case 171:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
				kind: $$[$0-7],
				item: $$[$0-6].unwrap(),
				index: $$[$0-5],
				source: $$[$0-4],
				step: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 172:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.For({
				kind: $$[$0-1],
				source: $$[$0],
				ref: true
			}));
break;
case 173:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
				kind: $$[$0-3],
				source: $$[$0-2],
				ref: true,
				guard: $$[$0]
			}));
break;
case 174:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
				kind: $$[$0-3],
				source: $$[$0-2],
				ref: true,
				step: $$[$0]
			}));
break;
case 175:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
				kind: $$[$0-5],
				source: $$[$0-4],
				ref: true,
				step: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 176:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
				object: true,
				kind: $$[$0-3],
				index: $$[$0-2],
				source: $$[$0]
			}));
break;
case 177:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
				object: true,
				kind: $$[$0-5],
				index: $$[$0-4],
				source: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 178:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
				object: true,
				kind: $$[$0-5],
				index: $$[$0-4],
				item: $$[$0-2].unwrap(),
				source: $$[$0]
			}));
break;
case 179:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
				object: true,
				kind: $$[$0-7],
				index: $$[$0-6],
				item: $$[$0-4].unwrap(),
				source: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 180:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
				kind: $$[$0-5],
				index: $$[$0-4],
				from: $$[$0-2],
				op: $$[$0-1],
				to: $$[$0]
			}));
break;
case 181:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.For({
				kind: $$[$0-4],
				from: $$[$0-2],
				op: $$[$0-1],
				to: $$[$0],
				ref: true
			}));
break;
case 182:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
				kind: $$[$0-7],
				index: $$[$0-6],
				from: $$[$0-4],
				op: $$[$0-3],
				to: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 183:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.For({
				kind: $$[$0-6],
				from: $$[$0-4],
				op: $$[$0-3],
				to: $$[$0-2],
				guard: $$[$0],
				ref: true
			}));
break;
case 184:
this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
				kind: $$[$0-7],
				index: $$[$0-6],
				from: $$[$0-4],
				op: $$[$0-3],
				to: $$[$0-2],
				step: $$[$0]
			}));
break;
case 185:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.For({
				kind: $$[$0-6],
				from: $$[$0-4],
				op: $$[$0-3],
				to: $$[$0-2],
				step: $$[$0],
				ref: true
			}));
break;
case 186:
this.$ = yy.L(_$[$0-9], _$[$0],new yy.For({
				kind: $$[$0-9],
				index: $$[$0-8],
				from: $$[$0-6],
				op: $$[$0-5],
				to: $$[$0-4],
				step: $$[$0-2],
				guard: $$[$0]
			}));
break;
case 187:
this.$ = yy.L(_$[$0-8], _$[$0],new yy.For({
				kind: $$[$0-8],
				from: $$[$0-6],
				op: $$[$0-5],
				to: $$[$0-4],
				step: $$[$0-2],
				guard: $$[$0],
				ref: true
			}));
break;
case 188:
this.$ = yy.L(_$[$0-9], _$[$0],new yy.For({
				kind: $$[$0-9],
				index: $$[$0-8],
				from: $$[$0-6],
				op: $$[$0-5],
				to: $$[$0-4],
				guard: $$[$0-2],
				step: $$[$0]
			}));
break;
case 189:
this.$ = yy.L(_$[$0-8], _$[$0],new yy.For({
				kind: $$[$0-8],
				from: $$[$0-6],
				op: $$[$0-5],
				to: $$[$0-4],
				guard: $$[$0-2],
				step: $$[$0],
				ref: true
			}));
break;
case 190:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until'));
break;
case 191:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until').addGuard($$[$0]));
break;
case 192:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', $$[$0]));
break;
case 193:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]));
break;
case 195:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 198:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))]);
break;
case 199:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 204:
return this.$
break;
}
},
table: [o([1,47],$V0,{106:1,101:2,50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{1:[3]},{1:[2,204]},o($Vr,[2,162],{47:$Vx}),o($Vr,[2,163],{47:[1,46]}),o($Vy,[2,61]),o($Vz,$V0,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:47,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy,$VA,{15:48,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,10:64,45:65,17:66,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy,[2,67]),o($Vy,[2,68],{5:32,6:33,39:40,42:42,3:69,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,41:$Vb,81:$Vp,102:$Vw}),{3:70,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($VU,$VV,{8:76,9:$VW,13:$VX,32:$VY,37:$VZ,56:$V_,57:$V$,73:$V01,96:$V11}),{32:[1,81],57:[1,80]},{3:82,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:$V21,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:85,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$V31,49:$V41,55:13,57:$V51,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:89,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:[1,90],55:13,57:[1,88],59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:92,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:[1,93],55:13,57:[1,91],59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o([1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,99],{3:12,55:13,5:32,6:33,39:40,42:42,17:94,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{9:[1,96]},{9:[1,97]},{75:[1,98],76:[1,99]},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:100,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:101,48:$Vd},o([1,12,19,20,22,24,25,26,30,33,34,35,46,47,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,125],{3:12,55:13,5:32,6:33,39:40,42:42,17:102,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:[1,103],49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,[2,126],{4:[1,104]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:107,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,82:$V71,83:$Vq,84:$Vr,85:$Vs,86:105,87:106,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:110,48:$Vd},o($V81,$V91,{5:32,6:33,39:40,42:42,3:111,94:112,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,41:$Vb,81:$Vp,96:$Va1,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:115,16:$V4,17:114,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{48:[1,116]},o([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,104,105],$Vb1),o($Vc1,$Vd1),o($Vc1,[2,3]),o($Vc1,[2,4]),{9:[1,117]},o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:121,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:$Vf1,36:$Vg1,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vh1,$Vi1,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:$Vj1,7:$V2,14:$V3,16:[1,122],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vn1,$V0,{50:3,15:4,51:5,3:12,55:13,5:32,6:33,39:40,42:42,17:133,101:141,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,24:[1,132],26:[1,134],27:[1,135],28:[1,136],29:[1,137],31:[1,138],32:[1,139],33:[1,140],38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:142,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:143,48:$Vd},o($Vo1,[2,41]),o($Vo1,[2,42]),{3:144,4:[1,146],5:32,6:33,7:$V2,14:$V3,16:$V4,17:145,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,36:[1,147],38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:148,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vy,[2,63],{17:7,3:12,55:13,5:32,6:33,39:40,42:42,51:149,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([1,25,47],$V0,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:150,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{20:[1,151],47:$Vx},o($Vy,[2,65]),{3:152,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:153,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,154],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:155,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:156,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:157,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:158,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:159,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:160,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:161,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:162,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:163,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:164,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:165,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:166,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:167,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vp1,$Vq1,{11:168,46:$Vr1}),o($Vs1,[2,51]),o($Vs1,$Vt1,{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vs1,[2,57],{55:13,5:32,6:33,39:40,42:42,17:170,3:171,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:172,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([32,57],$Vu1,{8:76,9:$VW,13:$VX,37:$VZ}),o($Vy,[2,69],{8:76,9:$VW,13:$VX,37:$VZ}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:174,16:$V4,17:173,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:175,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,176],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,82]),o($VU,[2,113]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:177,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,5]),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:178,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,7]),{4:[1,180],5:181,6:182,16:[1,179],21:[1,183],23:[1,184],41:$Vb,42:42},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:185,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,84]),o($VU,[2,81],{8:76,9:$VW,13:$VX,37:$VZ}),{3:186,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:187,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,188],81:$Vp,102:$Vw},o($Vw1,[2,91],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:189,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,190],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:191,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:192,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,193],81:$Vp,102:$Vw},o($Vw1,[2,92],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:194,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:195,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,196],81:$Vp,102:$Vw},o($Vw1,[2,93],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:197,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vy1,[2,100],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),{3:69,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:198,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:199,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{9:[1,200]},{9:[1,201]},{15:202,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{81:[1,203]},o($Vy1,[2,123],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:204,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,[2,127]),{46:$Vz1,82:$V71,87:205},o($VA1,[2,131],{82:$VB1,88:[1,207],89:[1,208]}),o($VU,[2,134]),o($VC1,[2,147],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:210,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,135],{91:[1,211],92:[1,212]}),o($V81,$V91,{8:76,94:213,9:$VW,13:$VX,37:$VZ,96:$Va1}),{48:$VD1,95:214,105:$VE1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:216,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VF1,[2,144],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VU,[2,145]),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:217,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:218,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Ve1,$Vt1,{18:219,39:221,33:$VB,34:[1,220],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,81:$Vp,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:222,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:223,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VG1,$Vq1,{11:224,46:$Vr1}),o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:225,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:$Vf1,36:$Vg1,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([22,47],$Vq1,{11:226,46:$VH1}),o($VI1,[2,157]),o([20,46,47],$Vi1,{3:12,55:13,6:33,39:40,42:42,100:124,98:126,17:127,5:131,43:228,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:229,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,230],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VI1,[2,153],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:231,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VI1,[2,155]),o($VJ1,$Vb1,{99:[1,232]}),o($VJ1,$Vd1,{99:[1,233]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:235,21:$V5,23:$V6,25:[1,234],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vn1,$VA,{15:48,24:[1,236],26:[1,237],33:[1,238],48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:240,21:$V5,23:$V6,25:[1,239],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{9:[1,242],25:[1,241]},{25:[1,243]},o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:244,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:85,21:$V5,23:$V6,25:[1,245],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$V31,49:$V41,55:13,57:$V51,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:82,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,25:[1,246],38:$Va,39:40,41:$Vb,42:42,49:$V21,81:$Vp,102:$Vw},{3:247,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{25:[1,248]},{15:249,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,$VK1,{40:250,89:$VL1}),o([19,20,22,33,35,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102],$VV,{8:76,9:$VW,13:$VX,32:$VY,37:$VZ,56:$V_,57:$V$,73:$V01,96:$V11,103:[1,252]}),o($VM1,[2,172],{33:$VB,35:[1,254],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,253]}),o([9,13,19,20,22,32,33,35,37,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103],$Vb1,{36:[1,257],46:[1,256],104:[1,255]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:258,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,190],{33:$VB,46:[1,260],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,259]}),o($Vy,[2,62]),o($Vr,[2,164],{47:$Vx}),o([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,88,89,91,92,96,102,103,104,105],[2,70]),{8:76,9:$VW,13:$VX,33:[1,261],37:$VZ},o($VN1,[2,79],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:262,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,66,67,68,70,71,72,79,81,82,102,105],[2,101],{33:$VB,64:$VG,65:$VH,69:$VL}),o($VO1,[2,102],{33:$VB,58:$VC,59:$VD,62:$VE,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL,70:$VM}),o($VF1,[2,103],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($Vw1,[2,104],{33:$VB,65:$VH,69:$VL}),o($Vw1,[2,105],{33:$VB,65:$VH,69:$VL}),o($VN1,[2,106],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($VO1,[2,107],{33:$VB,58:$VC,59:$VD,62:$VE,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL,70:$VM}),o($VP1,[2,108],{33:$VB,58:$VC,59:$VD,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL}),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,65,66,67,68,70,71,72,79,81,82,102,105],[2,109],{33:$VB,69:$VL}),o($VP1,[2,110],{33:$VB,58:$VC,59:$VD,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL}),o($VF1,[2,111],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($Vy1,[2,112],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vy1,[2,120],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),{30:[1,263],47:$VQ1,48:$VR1},o([12,19,20,30,47,48],$VS1,{3:12,55:13,5:32,6:33,39:40,42:42,17:66,45:266,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vs1,[2,56],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,$VV,{8:76,9:$VW,13:$VX,32:$Vu1,57:$Vu1,37:$VZ,56:$V_,73:$V01,96:$V11}),o($Vp1,$Vq1,{11:267,46:$Vr1}),o($VN1,[2,72],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($VU,[2,73]),o($Vy1,[2,76],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:268,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VF1,[2,143],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VT1,$Vq1,{11:269,46:$Vr1}),o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,10:121,17:270,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:[1,271],38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,43]),o($Vc1,[2,44]),o($Vc1,[2,45]),o($Vh1,$Vi1,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vn1,$V0,{50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,101:141,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy1,[2,77],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($VU,[2,83],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU,[2,85],{8:76,9:$VW,13:$VX,37:$VZ}),{3:272,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,94],{33:$VB,65:$VH,69:$VL}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:273,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU1,$Vq1,{11:274,46:$Vr1}),o($VU,[2,86],{8:76,9:$VW,13:$VX,37:$VZ}),{3:275,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,95],{33:$VB,65:$VH,69:$VL}),o($VU,[2,87],{8:76,9:$VW,13:$VX,37:$VZ}),{3:276,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,96],{33:$VB,65:$VH,69:$VL}),o($VT1,$Vq1,{11:277,46:$Vr1}),o($VT1,$Vq1,{11:278,46:$Vr1}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:279,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:280,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,$VK1,{40:281,89:$VL1}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:282,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU1,$Vq1,{11:283,46:$Vr1}),o($VA1,[2,128],{82:$VB1,88:[1,284],89:[1,285]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:286,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:287,48:$Vd},{15:288,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:289,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:290,46:$Vz1,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:291,16:$V4,17:66,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,45:292,48:$Vd,49:$VT,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:293,48:$Vd},{48:$VD1,95:294,105:$VE1},{15:295,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:296,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($V81,[2,200],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU1,$Vq1,{11:297,46:$Vr1}),o($VT1,$Vq1,{11:298,46:$Vr1}),{19:[1,299],20:[1,300],39:301,47:$VV1,48:$VW1,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:304,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,194]),{33:$VB,34:[1,305],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,306],33:$VB,35:[1,307],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,308],47:$VQ1,48:$VR1},o($VG1,$Vq1,{11:309,46:$Vr1}),{22:[1,310],47:$VX1},o([20,22,47],$VS1,{3:12,55:13,6:33,39:40,42:42,98:126,17:127,5:131,100:312,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vz,$Vq1,{11:313,46:$VH1}),o($VI1,[2,151],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:314,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VI1,[2,154],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VY1,[2,149]),o($VY1,[2,150]),o($Vc1,[2,12]),{25:[1,315],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{25:[1,316]},{25:[1,317]},{3:318,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vc1,[2,15]),{25:[1,319],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,18]),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:320,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,20]),o($Vp1,$Vq1,{11:321,46:$Vr1}),o($Vc1,[2,22]),o($Vc1,[2,23]),{8:76,9:$VW,13:$VX,33:[1,322],37:$VZ},o($Vo1,[2,161]),o($Vc1,[2,39]),o($Vc1,[2,40]),{15:323,48:$Vd,78:[1,324]},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:325,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:326,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:327,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:328,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:329,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:330,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{33:$VB,34:[1,331],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:332,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:333,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:334,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU1,$Vq1,{11:335,46:$Vr1}),{52:$VZ1,74:$V_1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:66,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,45:338,49:$VT,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:339,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vs1,[2,52]),{30:[1,340],47:$VQ1,48:$VR1},o($VU1,$Vq1,{11:341,46:$Vr1}),{12:[1,342],47:$VQ1,48:$VR1},o($Ve1,$Vt1,{33:$VB,34:[1,343],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:344,19:[1,345],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,88],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU1,$Vq1,{11:346,46:$Vr1}),{20:[1,347],47:$VQ1,48:$VR1},o($VU,[2,89],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU,[2,90],{8:76,9:$VW,13:$VX,37:$VZ}),{12:[1,348],47:$VQ1,48:$VR1},{12:[1,349],47:$VQ1,48:$VR1},o($VT1,$Vq1,{11:350,46:$Vr1}),o($VT1,$Vq1,{11:351,46:$Vr1}),o($VU,[2,119]),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,102,105],[2,121],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,82:[1,352]}),{20:[1,353],47:$VQ1,48:$VR1},{15:354,48:$Vd},{15:355,48:$Vd},o($VC1,[2,148],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,[2,132]),o($VU,[2,133]),{15:356,46:$Vz1,48:$Vd},o($V$1,[2,198]),o($VU,[2,136],{92:[1,357]}),{15:358,48:$Vd},o($VU,[2,140]),{15:359,48:$Vd},o($VU,[2,142]),{46:$Vz1,48:[2,202]},{20:[1,360],47:$VQ1,48:$VR1},{12:[1,361],47:$VQ1,48:$VR1},o($Vc1,[2,9]),{19:[1,362]},o($VM1,[2,195]),{39:363,81:$Vp,102:$Vw},{39:364,81:$Vp,102:$Vw},{19:[1,365],33:$VB,35:[1,366],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:367,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,31]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:368,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,$V02,{44:$V12}),{19:[1,370],47:$VQ1,48:$VR1},o($Vc1,[2,47],{44:[1,371]}),{3:12,4:$Vj1,5:131,6:33,7:$V2,14:$V3,16:$V4,17:127,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$Vl1,53:$Vm1,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,98:126,100:372,102:$Vw},o($VI1,[2,158]),{20:[1,373],47:$VX1},o($VU1,$Vq1,{11:374,46:$Vr1}),o($Vc1,[2,13]),o($Vc1,[2,14]),o($Vc1,[2,17]),{8:76,9:$VW,13:$VX,33:[1,375],37:$VZ},o($Vc1,[2,16]),o($VT1,$Vq1,{11:376,46:$Vr1}),{30:[1,377],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:379,21:$V5,23:$V6,25:[1,378],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,166]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:380,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,168],{33:$VB,35:[1,382],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,381]}),o($VM1,[2,173],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,174],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,383]}),o($VM1,[2,176],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,384]}),{8:76,9:$VW,13:$VX,37:$VZ,104:[1,385]},{33:$VB,34:[1,386],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:387,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,191],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,192],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,388]}),o($VU,[2,74]),{20:[1,389],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:390,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:391,48:$Vd},o($Vs1,[2,53]),o($VU1,$Vq1,{11:392,46:$Vr1}),{74:$V_1},{20:[1,393],47:$VQ1,48:$VR1},o($Vc1,[2,6]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:394,19:[1,395],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{19:[1,397],33:$VB,35:[1,396],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,38]),{20:[1,398],47:$VQ1,48:$VR1},o($VU,[2,98]),{15:399,48:$Vd},{15:400,48:$Vd},{12:[1,401],47:$VQ1,48:$VR1},{12:[1,402],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:403,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,124]),o($VU,[2,129]),o($VU,[2,130]),o($V$1,[2,199]),{15:404,48:$Vd},o($VU,[2,138],{92:[1,405]}),o($VU,[2,141]),o($VU,[2,146]),{15:406,48:$Vd},o($Vc1,[2,10]),o($VM1,[2,196]),o($VM1,[2,197]),o($Vc1,[2,27]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:407,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{19:[1,408],33:$VB,35:[1,409],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,410],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,48]),o([9,13,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],$V02,{39:221,18:411,44:$V12,81:$Vp,102:$Vw}),o($Vc1,[2,49]),o($VI1,[2,159]),o($VI1,[2,160]),{20:[1,412],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:334,21:$V5,23:$V6,25:[1,413],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{12:[1,414],47:$VQ1,48:$VR1},{28:[1,415],52:$VZ1,74:$V_1},o($Vc1,[2,24]),{25:[1,416],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{15:417,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:418,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:419,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:420,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:421,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:422,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:423,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,181],{33:$VB,35:[1,425],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,424]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:426,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,80]),o($Vy,[2,66],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,[2,114]),{20:[1,427],47:$VQ1,48:$VR1},o($VU,[2,78]),{19:[1,429],33:$VB,35:[1,428],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,36]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:430,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,37]),o($VU,[2,97]),o($VU,[2,115]),o($VU,[2,116]),{15:431,48:$Vd},{15:432,48:$Vd},o($VF1,[2,122],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VU,[2,137]),{15:433,48:$Vd},o($Vc1,[2,8]),{19:[1,434],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,29]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:435,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,32]),{22:[1,436],39:301,47:$VV1,48:$VW1,81:$Vp,102:$Vw},o($VI1,[2,152]),o($Vc1,[2,25]),{25:[1,437]},{25:[1,438]},o($Vc1,[2,26]),o($Vc1,$VK1,{40:439,89:$VL1}),o($VM1,[2,169],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,170],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,440]}),o($VM1,[2,175],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,177],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,178],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,441]}),o($VM1,[2,180],{33:$VB,35:[1,443],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,442]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:444,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:445,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,193],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vs1,[2,54]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:446,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,35]),{19:[1,447],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($VU,[2,117]),o($VU,[2,118]),o($VU,[2,139]),o($Vc1,[2,28]),{19:[1,448],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,11]),o($Vc1,[2,19]),o($Vc1,[2,21]),o($Vc1,[2,167]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:449,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:450,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:451,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:452,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,183],{33:$VB,35:[1,453],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,185],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,454]}),{19:[1,455],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,34]),o($Vc1,[2,30]),o($VM1,[2,171],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,179],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,182],{33:$VB,35:[1,456],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,184],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,457]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:458,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:459,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,33]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:460,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:461,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,189],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,187],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,188],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,186],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP})],
defaultActions: {2:[2,204]},
parseError: function parseError (str, hash) {
		if (hash.recoverable) {
				this.trace(str);
		} else {
				var error = new Error(str);
				error.hash = hash;
				throw error;
		}
},
parse: function parse(input) {
		var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
		var args = lstack.slice.call(arguments, 1);
		var lexer = Object.create(this.lexer);
		var sharedState = { yy: {} };
		for (var k in this.yy) {
				if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
						sharedState.yy[k] = this.yy[k];
				}
		}
		lexer.setInput(input, sharedState.yy);
		sharedState.yy.lexer = lexer;
		sharedState.yy.parser = this;
		if (typeof lexer.yylloc == 'undefined') {
				lexer.yylloc = {};
		}
		var yyloc = lexer.yylloc;
		lstack.push(yyloc);
		var ranges = lexer.options && lexer.options.ranges;
		if (typeof sharedState.yy.parseError === 'function') {
				this.parseError = sharedState.yy.parseError;
		} else {
				this.parseError = Object.getPrototypeOf(this).parseError;
		}
		function popStack(n) {
				stack.length = stack.length - 2 * n;
				vstack.length = vstack.length - n;
				lstack.length = lstack.length - n;
		}
		_token_stack:
				var lex = function () {
						var token;
						token = lexer.lex() || EOF;
						if (typeof token !== 'number') {
								token = self.symbols_[token] || token;
						}
						return token;
				};
		var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
		while (true) {
				state = stack[stack.length - 1];
				if (this.defaultActions[state]) {
						action = this.defaultActions[state];
				} else {
						if (symbol === null || typeof symbol == 'undefined') {
								symbol = lex();
						}
						action = table[state] && table[state][symbol];
				}
										if (typeof action === 'undefined' || !action.length || !action[0]) {
								var errStr = '';
								expected = [];
								for (p in table[state]) {
										if (this.terminals_[p] && p > TERROR) {
												expected.push("'" + this.terminals_[p] + "'");
										}
								}
								if (lexer.showPosition) {
										errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
								} else {
										errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");
								}
								this.parseError(errStr, {
										text: lexer.match,
										token: this.terminals_[symbol] || symbol,
										line: lexer.yylineno,
										loc: yyloc,
										expected: expected
								});
						}
				if (action[0] instanceof Array && action.length > 1) {
						throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
				}
				switch (action[0]) {
				case 1:
						stack.push(symbol);
						vstack.push(lexer.yytext);
						lstack.push(lexer.yylloc);
						stack.push(action[1]);
						symbol = null;
						if (!preErrorSymbol) {
								yyleng = lexer.yyleng;
								yytext = lexer.yytext;
								yylineno = lexer.yylineno;
								yyloc = lexer.yylloc;
								if (recovering > 0) {
										recovering--;
								}
						} else {
								symbol = preErrorSymbol;
								preErrorSymbol = null;
						}
						break;
				case 2:
						len = this.productions_[action[1]][1];
						yyval.$ = vstack[vstack.length - len];
						yyval._$ = {
								first_line: lstack[lstack.length - (len || 1)].first_line,
								last_line: lstack[lstack.length - 1].last_line,
								first_column: lstack[lstack.length - (len || 1)].first_column,
								last_column: lstack[lstack.length - 1].last_column
						};
						if (ranges) {
								yyval._$.range = [
										lstack[lstack.length - (len || 1)].range[0],
										lstack[lstack.length - 1].range[1]
								];
						}
						r = this.performAction.apply(yyval, [
								yytext,
								yyleng,
								yylineno,
								sharedState.yy,
								action[1],
								vstack,
								lstack
						].concat(args));
						if (typeof r !== 'undefined') {
								return r;
						}
						if (len) {
								stack = stack.slice(0, -1 * len * 2);
								vstack = vstack.slice(0, -1 * len);
								lstack = lstack.slice(0, -1 * len);
						}
						stack.push(this.productions_[action[1]][0]);
						vstack.push(yyval.$);
						lstack.push(yyval._$);
						newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
						stack.push(newState);
						break;
				case 3:
						return true;
				}
		}
		return true;
}};

function Parser () {
	this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
		if (!args[1]) {
				console.log('Usage: '+args[0]+' FILE');
				process.exit(1);
		}
		var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
		return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
	exports.main(process.argv.slice(1));
}
}

}).call(this)
},{}],6:[function(require,module,exports){
	// ./util
},{}],7:[function(require,module,exports){
	// ...
},{}],8:[function(require,module,exports){
	// fs
},{}],9:[function(require,module,exports){
	// buffer
},{}],10:[function(require,module,exports){
	// events
},{}],11:[function(require,module,exports){
	// ...
},{}],12:[function(require,module,exports){
// var toString = {}.toString;

// module.exports = Array.isArray || function (arr) {
// 	return toString.call(arr) == '[object Array]';
// };

},{}],13:[function(require,module,exports){
	// path
},{}],14:[function(require,module,exports){
	// ./Func.js
},{}],15:[function(require,module,exports){
	// ./List.js
},{}],16:[function(require,module,exports){
	// ./Num.js
},{}],17:[function(require,module,exports){
	// ./Obj.js
},{}],18:[function(require,module,exports){
	// ./Str.js
},{}],19:[function(require,module,exports){
	// prelude-ls
},{}],20:[function(require,module,exports){
	// _process
},{}],21:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
	this._array = [];
	this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	var set = new ArraySet();
	for (var i = 0, len = aArray.length; i < len; i++) {
		set.add(aArray[i], aAllowDuplicates);
	}
	return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
	return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	var idx = this._array.length;
	if (!isDuplicate || aAllowDuplicates) {
		this._array.push(aStr);
	}
	if (!isDuplicate) {
		if (hasNativeMap) {
			this._set.set(aStr, idx);
		} else {
			this._set[sStr] = idx;
		}
	}
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
	if (hasNativeMap) {
		return this._set.has(aStr);
	} else {
		var sStr = util.toSetString(aStr);
		return has.call(this._set, sStr);
	}
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	if (hasNativeMap) {
		var idx = this._set.get(aStr);
		if (idx >= 0) {
				return idx;
		}
	} else {
		var sStr = util.toSetString(aStr);
		if (has.call(this._set, sStr)) {
			return this._set[sStr];
		}
	}

	throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
	if (aIdx >= 0 && aIdx < this._array.length) {
		return this._array[aIdx];
	}
	throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
	return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":30}],22:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
	return aValue < 0
		? ((-aValue) << 1) + 1
		: (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
	var isNegative = (aValue & 1) === 1;
	var shifted = aValue >> 1;
	return isNegative
		? -shifted
		: shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
	var encoded = "";
	var digit;

	var vlq = toVLQSigned(aValue);

	do {
		digit = vlq & VLQ_BASE_MASK;
		vlq >>>= VLQ_BASE_SHIFT;
		if (vlq > 0) {
			// There are still more digits in this value, so we must make sure the
			// continuation bit is marked.
			digit |= VLQ_CONTINUATION_BIT;
		}
		encoded += base64.encode(digit);
	} while (vlq > 0);

	return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	var strLen = aStr.length;
	var result = 0;
	var shift = 0;
	var continuation, digit;

	do {
		if (aIndex >= strLen) {
			throw new Error("Expected more digits in base 64 VLQ value.");
		}

		digit = base64.decode(aStr.charCodeAt(aIndex++));
		if (digit === -1) {
			throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
		}

		continuation = !!(digit & VLQ_CONTINUATION_BIT);
		digit &= VLQ_BASE_MASK;
		result = result + (digit << shift);
		shift += VLQ_BASE_SHIFT;
	} while (continuation);

	aOutParam.value = fromVLQSigned(result);
	aOutParam.rest = aIndex;
};

},{"./base64":23}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
	if (0 <= number && number < intToCharMap.length) {
		return intToCharMap[number];
	}
	throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
	var bigA = 65;     // 'A'
	var bigZ = 90;     // 'Z'

	var littleA = 97;  // 'a'
	var littleZ = 122; // 'z'

	var zero = 48;     // '0'
	var nine = 57;     // '9'

	var plus = 43;     // '+'
	var slash = 47;    // '/'

	var littleOffset = 26;
	var numberOffset = 52;

	// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	if (bigA <= charCode && charCode <= bigZ) {
		return (charCode - bigA);
	}

	// 26 - 51: abcdefghijklmnopqrstuvwxyz
	if (littleA <= charCode && charCode <= littleZ) {
		return (charCode - littleA + littleOffset);
	}

	// 52 - 61: 0123456789
	if (zero <= charCode && charCode <= nine) {
		return (charCode - zero + numberOffset);
	}

	// 62: +
	if (charCode == plus) {
		return 62;
	}

	// 63: /
	if (charCode == slash) {
		return 63;
	}

	// Invalid base64 digit.
	return -1;
};

},{}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	// This function terminates when one of the following is true:
	//
	//   1. We find the exact element we are looking for.
	//
	//   2. We did not find the exact element, but we can return the index of
	//      the next-closest element.
	//
	//   3. We did not find the exact element, and there is no next-closest
	//      element than the one we are searching for, so we return -1.
	var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	var cmp = aCompare(aNeedle, aHaystack[mid], true);
	if (cmp === 0) {
		// Found the element we are looking for.
		return mid;
	}
	else if (cmp > 0) {
		// Our needle is greater than aHaystack[mid].
		if (aHigh - mid > 1) {
			// The element is in the upper half.
			return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		}

		// The exact needle element was not found in this haystack. Determine if
		// we are in termination case (3) or (2) and return the appropriate thing.
		if (aBias == exports.LEAST_UPPER_BOUND) {
			return aHigh < aHaystack.length ? aHigh : -1;
		} else {
			return mid;
		}
	}
	else {
		// Our needle is less than aHaystack[mid].
		if (mid - aLow > 1) {
			// The element is in the lower half.
			return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		}

		// we are in termination case (3) or (2) and return the appropriate thing.
		if (aBias == exports.LEAST_UPPER_BOUND) {
			return mid;
		} else {
			return aLow < 0 ? -1 : aLow;
		}
	}
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	if (aHaystack.length === 0) {
		return -1;
	}

	var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
															aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	if (index < 0) {
		return -1;
	}

	// We have found either the exact element, or the next-closest element than
	// the one we are searching for. However, there may be more than one such
	// element. Make sure we always return the smallest of these.
	while (index - 1 >= 0) {
		if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
			break;
		}
		--index;
	}

	return index;
};

},{}],25:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
	// Optimized for most common case
	var lineA = mappingA.generatedLine;
	var lineB = mappingB.generatedLine;
	var columnA = mappingA.generatedColumn;
	var columnB = mappingB.generatedColumn;
	return lineB > lineA || lineB == lineA && columnB >= columnA ||
				 util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
	this._array = [];
	this._sorted = true;
	// Serves as infimum
	this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
	function MappingList_forEach(aCallback, aThisArg) {
		this._array.forEach(aCallback, aThisArg);
	};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
	if (generatedPositionAfter(this._last, aMapping)) {
		this._last = aMapping;
		this._array.push(aMapping);
	} else {
		this._sorted = false;
		this._array.push(aMapping);
	}
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
	if (!this._sorted) {
		this._array.sort(util.compareByGeneratedPositionsInflated);
		this._sorted = true;
	}
	return this._array;
};

exports.MappingList = MappingList;

},{"./util":30}],26:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
	var temp = ary[x];
	ary[x] = ary[y];
	ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
	return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
	// If our lower bound is less than our upper bound, we (1) partition the
	// array into two pieces and (2) recurse on each half. If it is not, this is
	// the empty array and our base case.

	if (p < r) {
		// (1) Partitioning.
		//
		// The partitioning chooses a pivot between `p` and `r` and moves all
		// elements that are less than or equal to the pivot to the before it, and
		// all the elements that are greater than it after it. The effect is that
		// once partition is done, the pivot is in the exact place it will be when
		// the array is put in sorted order, and it will not need to be moved
		// again. This runs in O(n) time.

		// Always choose a random pivot so that an input array which is reverse
		// sorted does not cause O(n^2) running time.
		var pivotIndex = randomIntInRange(p, r);
		var i = p - 1;

		swap(ary, pivotIndex, r);
		var pivot = ary[r];

		// Immediately after `j` is incremented in this loop, the following hold
		// true:
		//
		//   * Every element in `ary[p .. i]` is less than or equal to the pivot.
		//
		//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
		for (var j = p; j < r; j++) {
			if (comparator(ary[j], pivot) <= 0) {
				i += 1;
				swap(ary, i, j);
			}
		}

		swap(ary, i + 1, j);
		var q = i + 1;

		// (2) Recurse on each half.

		doQuickSort(ary, comparator, p, q - 1);
		doQuickSort(ary, comparator, q + 1, r);
	}
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
	doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],27:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	var sourceMap = aSourceMap;
	if (typeof aSourceMap === 'string') {
		sourceMap = util.parseSourceMapInput(aSourceMap);
	}

	return sourceMap.sections != null
		? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
		: new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	configurable: true,
	enumerable: true,
	get: function () {
		if (!this.__generatedMappings) {
			this._parseMappings(this._mappings, this.sourceRoot);
		}

		return this.__generatedMappings;
	}
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	configurable: true,
	enumerable: true,
	get: function () {
		if (!this.__originalMappings) {
			this._parseMappings(this._mappings, this.sourceRoot);
		}

		return this.__originalMappings;
	}
});

SourceMapConsumer.prototype._charIsMappingSeparator =
	function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		var c = aStr.charAt(index);
		return c === ";" || c === ",";
	};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
	function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		throw new Error("Subclasses must implement _parseMappings");
	};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
	function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		var context = aContext || null;
		var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

		var mappings;
		switch (order) {
		case SourceMapConsumer.GENERATED_ORDER:
			mappings = this._generatedMappings;
			break;
		case SourceMapConsumer.ORIGINAL_ORDER:
			mappings = this._originalMappings;
			break;
		default:
			throw new Error("Unknown order of iteration.");
		}

		var sourceRoot = this.sourceRoot;
		mappings.map(function (mapping) {
			var source = mapping.source === null ? null : this._sources.at(mapping.source);
			source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
			return {
				source: source,
				generatedLine: mapping.generatedLine,
				generatedColumn: mapping.generatedColumn,
				originalLine: mapping.originalLine,
				originalColumn: mapping.originalColumn,
				name: mapping.name === null ? null : this._names.at(mapping.name)
			};
		}, this).forEach(aCallback, context);
	};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
	function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		var line = util.getArg(aArgs, 'line');

		// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
		// returns the index of the closest mapping less than the needle. By
		// setting needle.originalColumn to 0, we thus find the last mapping for
		// the given line, provided such a mapping exists.
		var needle = {
			source: util.getArg(aArgs, 'source'),
			originalLine: line,
			originalColumn: util.getArg(aArgs, 'column', 0)
		};

		needle.source = this._findSourceIndex(needle.source);
		if (needle.source < 0) {
			return [];
		}

		var mappings = [];

		var index = this._findMapping(needle,
																	this._originalMappings,
																	"originalLine",
																	"originalColumn",
																	util.compareByOriginalPositions,
																	binarySearch.LEAST_UPPER_BOUND);
		if (index >= 0) {
			var mapping = this._originalMappings[index];

			if (aArgs.column === undefined) {
				var originalLine = mapping.originalLine;

				// Iterate until either we run out of mappings, or we run into
				// a mapping for a different line than the one we found. Since
				// mappings are sorted, this is guaranteed to find all mappings for
				// the line we found.
				while (mapping && mapping.originalLine === originalLine) {
					mappings.push({
						line: util.getArg(mapping, 'generatedLine', null),
						column: util.getArg(mapping, 'generatedColumn', null),
						lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
					});

					mapping = this._originalMappings[++index];
				}
			} else {
				var originalColumn = mapping.originalColumn;

				// Iterate until either we run out of mappings, or we run into
				// a mapping for a different line than the one we were searching for.
				// Since mappings are sorted, this is guaranteed to find all mappings for
				// the line we are searching for.
				while (mapping &&
							 mapping.originalLine === line &&
							 mapping.originalColumn == originalColumn) {
					mappings.push({
						line: util.getArg(mapping, 'generatedLine', null),
						column: util.getArg(mapping, 'generatedColumn', null),
						lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
					});

					mapping = this._originalMappings[++index];
				}
			}
		}

		return mappings;
	};

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	var sourceMap = aSourceMap;
	if (typeof aSourceMap === 'string') {
		sourceMap = util.parseSourceMapInput(aSourceMap);
	}

	var version = util.getArg(sourceMap, 'version');
	var sources = util.getArg(sourceMap, 'sources');
	// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	// requires the array) to play nice here.
	var names = util.getArg(sourceMap, 'names', []);
	var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	var mappings = util.getArg(sourceMap, 'mappings');
	var file = util.getArg(sourceMap, 'file', null);

	// Once again, Sass deviates from the spec and supplies the version as a
	// string rather than a number, so we use loose equality checking here.
	if (version != this._version) {
		throw new Error('Unsupported version: ' + version);
	}

	if (sourceRoot) {
		sourceRoot = util.normalize(sourceRoot);
	}

	sources = sources
		.map(String)
		// Some source maps produce relative source paths like "./foo.js" instead of
		// "foo.js".  Normalize these first so that future comparisons will succeed.
		// See bugzil.la/1090768.
		.map(util.normalize)
		// Always ensure that absolute sources are internally stored relative to
		// the source root, if the source root is absolute. Not doing this would
		// be particularly problematic when the source root is a prefix of the
		// source (valid, but why??). See github issue #199 and bugzil.la/1188982.
		.map(function (source) {
			return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
				? util.relative(sourceRoot, source)
				: source;
		});

	// Pass `true` below to allow duplicate names and sources. While source maps
	// are intended to be compressed and deduplicated, the TypeScript compiler
	// sometimes generates source maps with duplicates in them. See Github issue
	// #72 and bugzil.la/889492.
	this._names = ArraySet.fromArray(names.map(String), true);
	this._sources = ArraySet.fromArray(sources, true);

	this._absoluteSources = this._sources.toArray().map(function (s) {
		return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	});

	this.sourceRoot = sourceRoot;
	this.sourcesContent = sourcesContent;
	this._mappings = mappings;
	this._sourceMapURL = aSourceMapURL;
	this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	var relativeSource = aSource;
	if (this.sourceRoot != null) {
		relativeSource = util.relative(this.sourceRoot, relativeSource);
	}

	if (this._sources.has(relativeSource)) {
		return this._sources.indexOf(relativeSource);
	}

	// Maybe aSource is an absolute URL as returned by |sources|.  In
	// this case we can't simply undo the transform.
	var i;
	for (i = 0; i < this._absoluteSources.length; ++i) {
		if (this._absoluteSources[i] == aSource) {
			return i;
		}
	}

	return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
	function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
		var smc = Object.create(BasicSourceMapConsumer.prototype);

		var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		smc.sourceRoot = aSourceMap._sourceRoot;
		smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
																														smc.sourceRoot);
		smc.file = aSourceMap._file;
		smc._sourceMapURL = aSourceMapURL;
		smc._absoluteSources = smc._sources.toArray().map(function (s) {
			return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
		});

		// Because we are modifying the entries (by converting string sources and
		// names to indices into the sources and names ArraySets), we have to make
		// a copy of the entry or else bad things happen. Shared mutable state
		// strikes again! See github issue #191.

		var generatedMappings = aSourceMap._mappings.toArray().slice();
		var destGeneratedMappings = smc.__generatedMappings = [];
		var destOriginalMappings = smc.__originalMappings = [];

		for (var i = 0, length = generatedMappings.length; i < length; i++) {
			var srcMapping = generatedMappings[i];
			var destMapping = new Mapping;
			destMapping.generatedLine = srcMapping.generatedLine;
			destMapping.generatedColumn = srcMapping.generatedColumn;

			if (srcMapping.source) {
				destMapping.source = sources.indexOf(srcMapping.source);
				destMapping.originalLine = srcMapping.originalLine;
				destMapping.originalColumn = srcMapping.originalColumn;

				if (srcMapping.name) {
					destMapping.name = names.indexOf(srcMapping.name);
				}

				destOriginalMappings.push(destMapping);
			}

			destGeneratedMappings.push(destMapping);
		}

		quickSort(smc.__originalMappings, util.compareByOriginalPositions);

		return smc;
	};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	get: function () {
		return this._absoluteSources.slice();
	}
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
	this.generatedLine = 0;
	this.generatedColumn = 0;
	this.source = null;
	this.originalLine = null;
	this.originalColumn = null;
	this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
	function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		var generatedLine = 1;
		var previousGeneratedColumn = 0;
		var previousOriginalLine = 0;
		var previousOriginalColumn = 0;
		var previousSource = 0;
		var previousName = 0;
		var length = aStr.length;
		var index = 0;
		var cachedSegments = {};
		var temp = {};
		var originalMappings = [];
		var generatedMappings = [];
		var mapping, str, segment, end, value;

		while (index < length) {
			if (aStr.charAt(index) === ';') {
				generatedLine++;
				index++;
				previousGeneratedColumn = 0;
			}
			else if (aStr.charAt(index) === ',') {
				index++;
			}
			else {
				mapping = new Mapping();
				mapping.generatedLine = generatedLine;

				// Because each offset is encoded relative to the previous one,
				// many segments often have the same encoding. We can exploit this
				// fact by caching the parsed variable length fields of each segment,
				// allowing us to avoid a second parse if we encounter the same
				// segment again.
				for (end = index; end < length; end++) {
					if (this._charIsMappingSeparator(aStr, end)) {
						break;
					}
				}
				str = aStr.slice(index, end);

				segment = cachedSegments[str];
				if (segment) {
					index += str.length;
				} else {
					segment = [];
					while (index < end) {
						base64VLQ.decode(aStr, index, temp);
						value = temp.value;
						index = temp.rest;
						segment.push(value);
					}

					if (segment.length === 2) {
						throw new Error('Found a source, but no line and column');
					}

					if (segment.length === 3) {
						throw new Error('Found a source and line, but no column');
					}

					cachedSegments[str] = segment;
				}

				// Generated column.
				mapping.generatedColumn = previousGeneratedColumn + segment[0];
				previousGeneratedColumn = mapping.generatedColumn;

				if (segment.length > 1) {
					// Original source.
					mapping.source = previousSource + segment[1];
					previousSource += segment[1];

					// Original line.
					mapping.originalLine = previousOriginalLine + segment[2];
					previousOriginalLine = mapping.originalLine;
					// Lines are stored 0-based
					mapping.originalLine += 1;

					// Original column.
					mapping.originalColumn = previousOriginalColumn + segment[3];
					previousOriginalColumn = mapping.originalColumn;

					if (segment.length > 4) {
						// Original name.
						mapping.name = previousName + segment[4];
						previousName += segment[4];
					}
				}

				generatedMappings.push(mapping);
				if (typeof mapping.originalLine === 'number') {
					originalMappings.push(mapping);
				}
			}
		}

		quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
		this.__generatedMappings = generatedMappings;

		quickSort(originalMappings, util.compareByOriginalPositions);
		this.__originalMappings = originalMappings;
	};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
	function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
																				 aColumnName, aComparator, aBias) {
		// To return the position we are searching for, we must first find the
		// mapping for the given position and then return the opposite position it
		// points to. Because the mappings are sorted, we can use binary search to
		// find the best mapping.

		if (aNeedle[aLineName] <= 0) {
			throw new TypeError('Line must be greater than or equal to 1, got '
													+ aNeedle[aLineName]);
		}
		if (aNeedle[aColumnName] < 0) {
			throw new TypeError('Column must be greater than or equal to 0, got '
													+ aNeedle[aColumnName]);
		}

		return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
	function SourceMapConsumer_computeColumnSpans() {
		for (var index = 0; index < this._generatedMappings.length; ++index) {
			var mapping = this._generatedMappings[index];

			// Mappings do not contain a field for the last generated columnt. We
			// can come up with an optimistic estimate, however, by assuming that
			// mappings are contiguous (i.e. given two consecutive mappings, the
			// first mapping ends where the second one starts).
			if (index + 1 < this._generatedMappings.length) {
				var nextMapping = this._generatedMappings[index + 1];

				if (mapping.generatedLine === nextMapping.generatedLine) {
					mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
					continue;
				}
			}

			// The last mapping for each line spans the entire line.
			mapping.lastGeneratedColumn = Infinity;
		}
	};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
	function SourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util.getArg(aArgs, 'line'),
			generatedColumn: util.getArg(aArgs, 'column')
		};

		var index = this._findMapping(
			needle,
			this._generatedMappings,
			"generatedLine",
			"generatedColumn",
			util.compareByGeneratedPositionsDeflated,
			util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
		);

		if (index >= 0) {
			var mapping = this._generatedMappings[index];

			if (mapping.generatedLine === needle.generatedLine) {
				var source = util.getArg(mapping, 'source', null);
				if (source !== null) {
					source = this._sources.at(source);
					source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
				}
				var name = util.getArg(mapping, 'name', null);
				if (name !== null) {
					name = this._names.at(name);
				}
				return {
					source: source,
					line: util.getArg(mapping, 'originalLine', null),
					column: util.getArg(mapping, 'originalColumn', null),
					name: name
				};
			}
		}

		return {
			source: null,
			line: null,
			column: null,
			name: null
		};
	};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	function BasicSourceMapConsumer_hasContentsOfAllSources() {
		if (!this.sourcesContent) {
			return false;
		}
		return this.sourcesContent.length >= this._sources.size() &&
			!this.sourcesContent.some(function (sc) { return sc == null; });
	};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
	function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		if (!this.sourcesContent) {
			return null;
		}

		var index = this._findSourceIndex(aSource);
		if (index >= 0) {
			return this.sourcesContent[index];
		}

		var relativeSource = aSource;
		if (this.sourceRoot != null) {
			relativeSource = util.relative(this.sourceRoot, relativeSource);
		}

		var url;
		if (this.sourceRoot != null
				&& (url = util.urlParse(this.sourceRoot))) {
			// XXX: file:// URIs and absolute paths lead to unexpected behavior for
			// many users. We can help them out when they expect file:// URIs to
			// behave like it would if they were running a local HTTP server. See
			// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
			var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
			if (url.scheme == "file"
					&& this._sources.has(fileUriAbsPath)) {
				return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
			}

			if ((!url.path || url.path == "/")
					&& this._sources.has("/" + relativeSource)) {
				return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
			}
		}

		// This function is used recursively from
		// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
		// don't want to throw if we can't find the source - we just want to
		// return null, so we provide a flag to exit gracefully.
		if (nullOnMissing) {
			return null;
		}
		else {
			throw new Error('"' + relativeSource + '" is not in the SourceMap.');
		}
	};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
	function SourceMapConsumer_generatedPositionFor(aArgs) {
		var source = util.getArg(aArgs, 'source');
		source = this._findSourceIndex(source);
		if (source < 0) {
			return {
				line: null,
				column: null,
				lastColumn: null
			};
		}

		var needle = {
			source: source,
			originalLine: util.getArg(aArgs, 'line'),
			originalColumn: util.getArg(aArgs, 'column')
		};

		var index = this._findMapping(
			needle,
			this._originalMappings,
			"originalLine",
			"originalColumn",
			util.compareByOriginalPositions,
			util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
		);

		if (index >= 0) {
			var mapping = this._originalMappings[index];

			if (mapping.source === needle.source) {
				return {
					line: util.getArg(mapping, 'generatedLine', null),
					column: util.getArg(mapping, 'generatedColumn', null),
					lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
				};
			}
		}

		return {
			line: null,
			column: null,
			lastColumn: null
		};
	};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	var sourceMap = aSourceMap;
	if (typeof aSourceMap === 'string') {
		sourceMap = util.parseSourceMapInput(aSourceMap);
	}

	var version = util.getArg(sourceMap, 'version');
	var sections = util.getArg(sourceMap, 'sections');

	if (version != this._version) {
		throw new Error('Unsupported version: ' + version);
	}

	this._sources = new ArraySet();
	this._names = new ArraySet();

	var lastOffset = {
		line: -1,
		column: 0
	};
	this._sections = sections.map(function (s) {
		if (s.url) {
			// The url field will require support for asynchronicity.
			// See https://github.com/mozilla/source-map/issues/16
			throw new Error('Support for url field in sections not implemented.');
		}
		var offset = util.getArg(s, 'offset');
		var offsetLine = util.getArg(offset, 'line');
		var offsetColumn = util.getArg(offset, 'column');

		if (offsetLine < lastOffset.line ||
				(offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
			throw new Error('Section offsets must be ordered and non-overlapping.');
		}
		lastOffset = offset;

		return {
			generatedOffset: {
				// The offset fields are 0-based, but we use 1-based indices when
				// encoding/decoding from VLQ.
				generatedLine: offsetLine + 1,
				generatedColumn: offsetColumn + 1
			},
			consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
		}
	});
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	get: function () {
		var sources = [];
		for (var i = 0; i < this._sections.length; i++) {
			for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
				sources.push(this._sections[i].consumer.sources[j]);
			}
		}
		return sources;
	}
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
	function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util.getArg(aArgs, 'line'),
			generatedColumn: util.getArg(aArgs, 'column')
		};

		// Find the section containing the generated position we're trying to map
		// to an original position.
		var sectionIndex = binarySearch.search(needle, this._sections,
			function(needle, section) {
				var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
				if (cmp) {
					return cmp;
				}

				return (needle.generatedColumn -
								section.generatedOffset.generatedColumn);
			});
		var section = this._sections[sectionIndex];

		if (!section) {
			return {
				source: null,
				line: null,
				column: null,
				name: null
			};
		}

		return section.consumer.originalPositionFor({
			line: needle.generatedLine -
				(section.generatedOffset.generatedLine - 1),
			column: needle.generatedColumn -
				(section.generatedOffset.generatedLine === needle.generatedLine
				 ? section.generatedOffset.generatedColumn - 1
				 : 0),
			bias: aArgs.bias
		});
	};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		return this._sections.every(function (s) {
			return s.consumer.hasContentsOfAllSources();
		});
	};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
	function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		for (var i = 0; i < this._sections.length; i++) {
			var section = this._sections[i];

			var content = section.consumer.sourceContentFor(aSource, true);
			if (content) {
				return content;
			}
		}
		if (nullOnMissing) {
			return null;
		}
		else {
			throw new Error('"' + aSource + '" is not in the SourceMap.');
		}
	};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
	function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		for (var i = 0; i < this._sections.length; i++) {
			var section = this._sections[i];

			// Only consider this section if the requested source is in the list of
			// sources of the consumer.
			if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
				continue;
			}
			var generatedPosition = section.consumer.generatedPositionFor(aArgs);
			if (generatedPosition) {
				var ret = {
					line: generatedPosition.line +
						(section.generatedOffset.generatedLine - 1),
					column: generatedPosition.column +
						(section.generatedOffset.generatedLine === generatedPosition.line
						 ? section.generatedOffset.generatedColumn - 1
						 : 0)
				};
				return ret;
			}
		}

		return {
			line: null,
			column: null
		};
	};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
	function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		this.__generatedMappings = [];
		this.__originalMappings = [];
		for (var i = 0; i < this._sections.length; i++) {
			var section = this._sections[i];
			var sectionMappings = section.consumer._generatedMappings;
			for (var j = 0; j < sectionMappings.length; j++) {
				var mapping = sectionMappings[j];

				var source = section.consumer._sources.at(mapping.source);
				source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
				this._sources.add(source);
				source = this._sources.indexOf(source);

				var name = null;
				if (mapping.name) {
					name = section.consumer._names.at(mapping.name);
					this._names.add(name);
					name = this._names.indexOf(name);
				}

				// The mappings coming from the consumer for the section have
				// generated positions relative to the start of the section, so we
				// need to offset them to be relative to the start of the concatenated
				// generated file.
				var adjustedMapping = {
					source: source,
					generatedLine: mapping.generatedLine +
						(section.generatedOffset.generatedLine - 1),
					generatedColumn: mapping.generatedColumn +
						(section.generatedOffset.generatedLine === mapping.generatedLine
						? section.generatedOffset.generatedColumn - 1
						: 0),
					originalLine: mapping.originalLine,
					originalColumn: mapping.originalColumn,
					name: name
				};

				this.__generatedMappings.push(adjustedMapping);
				if (typeof adjustedMapping.originalLine === 'number') {
					this.__originalMappings.push(adjustedMapping);
				}
			}
		}

		quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
		quickSort(this.__originalMappings, util.compareByOriginalPositions);
	};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":21,"./base64-vlq":22,"./binary-search":24,"./quick-sort":26,"./util":30}],28:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
	if (!aArgs) {
		aArgs = {};
	}
	this._file = util.getArg(aArgs, 'file', null);
	this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	this._sources = new ArraySet();
	this._names = new ArraySet();
	this._mappings = new MappingList();
	this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
	function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
		var sourceRoot = aSourceMapConsumer.sourceRoot;
		var generator = new SourceMapGenerator({
			file: aSourceMapConsumer.file,
			sourceRoot: sourceRoot
		});
		aSourceMapConsumer.eachMapping(function (mapping) {
			var newMapping = {
				generated: {
					line: mapping.generatedLine,
					column: mapping.generatedColumn
				}
			};

			if (mapping.source != null) {
				newMapping.source = mapping.source;
				if (sourceRoot != null) {
					newMapping.source = util.relative(sourceRoot, newMapping.source);
				}

				newMapping.original = {
					line: mapping.originalLine,
					column: mapping.originalColumn
				};

				if (mapping.name != null) {
					newMapping.name = mapping.name;
				}
			}

			generator.addMapping(newMapping);
		});
		aSourceMapConsumer.sources.forEach(function (sourceFile) {
			var sourceRelative = sourceFile;
			if (sourceRoot !== null) {
				sourceRelative = util.relative(sourceRoot, sourceFile);
			}

			if (!generator._sources.has(sourceRelative)) {
				generator._sources.add(sourceRelative);
			}

			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				generator.setSourceContent(sourceFile, content);
			}
		});
		return generator;
	};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
	function SourceMapGenerator_addMapping(aArgs) {
		var generated = util.getArg(aArgs, 'generated');
		var original = util.getArg(aArgs, 'original', null);
		var source = util.getArg(aArgs, 'source', null);
		var name = util.getArg(aArgs, 'name', null);

		if (!this._skipValidation) {
			this._validateMapping(generated, original, source, name);
		}

		if (source != null) {
			source = String(source);
			if (!this._sources.has(source)) {
				this._sources.add(source);
			}
		}

		if (name != null) {
			name = String(name);
			if (!this._names.has(name)) {
				this._names.add(name);
			}
		}

		this._mappings.add({
			generatedLine: generated.line,
			generatedColumn: generated.column,
			originalLine: original != null && original.line,
			originalColumn: original != null && original.column,
			source: source,
			name: name
		});
	};

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
	function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
		var source = aSourceFile;
		if (this._sourceRoot != null) {
			source = util.relative(this._sourceRoot, source);
		}

		if (aSourceContent != null) {
			// Add the source content to the _sourcesContents map.
			// Create a new _sourcesContents map if the property is null.
			if (!this._sourcesContents) {
				this._sourcesContents = Object.create(null);
			}
			this._sourcesContents[util.toSetString(source)] = aSourceContent;
		} else if (this._sourcesContents) {
			// Remove the source file from the _sourcesContents map.
			// If the _sourcesContents map is empty, set the property to null.
			delete this._sourcesContents[util.toSetString(source)];
			if (Object.keys(this._sourcesContents).length === 0) {
				this._sourcesContents = null;
			}
		}
	};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
	function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
		var sourceFile = aSourceFile;
		// If aSourceFile is omitted, we will use the file property of the SourceMap
		if (aSourceFile == null) {
			if (aSourceMapConsumer.file == null) {
				throw new Error(
					'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
					'or the source map\'s "file" property. Both were omitted.'
				);
			}
			sourceFile = aSourceMapConsumer.file;
		}
		var sourceRoot = this._sourceRoot;
		// Make "sourceFile" relative if an absolute Url is passed.
		if (sourceRoot != null) {
			sourceFile = util.relative(sourceRoot, sourceFile);
		}
		// Applying the SourceMap can add and remove items from the sources and
		// the names array.
		var newSources = new ArraySet();
		var newNames = new ArraySet();

		// Find mappings for the "sourceFile"
		this._mappings.unsortedForEach(function (mapping) {
			if (mapping.source === sourceFile && mapping.originalLine != null) {
				// Check if it can be mapped by the source map, then update the mapping.
				var original = aSourceMapConsumer.originalPositionFor({
					line: mapping.originalLine,
					column: mapping.originalColumn
				});
				if (original.source != null) {
					// Copy mapping
					mapping.source = original.source;
					if (aSourceMapPath != null) {
						mapping.source = util.join(aSourceMapPath, mapping.source)
					}
					if (sourceRoot != null) {
						mapping.source = util.relative(sourceRoot, mapping.source);
					}
					mapping.originalLine = original.line;
					mapping.originalColumn = original.column;
					if (original.name != null) {
						mapping.name = original.name;
					}
				}
			}

			var source = mapping.source;
			if (source != null && !newSources.has(source)) {
				newSources.add(source);
			}

			var name = mapping.name;
			if (name != null && !newNames.has(name)) {
				newNames.add(name);
			}

		}, this);
		this._sources = newSources;
		this._names = newNames;

		// Copy sourcesContents of applied map.
		aSourceMapConsumer.sources.forEach(function (sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aSourceMapPath != null) {
					sourceFile = util.join(aSourceMapPath, sourceFile);
				}
				if (sourceRoot != null) {
					sourceFile = util.relative(sourceRoot, sourceFile);
				}
				this.setSourceContent(sourceFile, content);
			}
		}, this);
	};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
	function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
																							aName) {
		// When aOriginal is truthy but has empty values for .line and .column,
		// it is most likely a programmer error. In this case we throw a very
		// specific error message to try to guide them the right way.
		// For example: https://github.com/Polymer/polymer-bundler/pull/519
		if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
				throw new Error(
						'original.line and original.column are not numbers -- you probably meant to omit ' +
						'the original mapping entirely and only map the generated position. If so, pass ' +
						'null for the original mapping instead of an object with empty or null values.'
				);
		}

		if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
				&& aGenerated.line > 0 && aGenerated.column >= 0
				&& !aOriginal && !aSource && !aName) {
			// Case 1.
			return;
		}
		else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
						 && aOriginal && 'line' in aOriginal && 'column' in aOriginal
						 && aGenerated.line > 0 && aGenerated.column >= 0
						 && aOriginal.line > 0 && aOriginal.column >= 0
						 && aSource) {
			// Cases 2 and 3.
			return;
		}
		else {
			throw new Error('Invalid mapping: ' + JSON.stringify({
				generated: aGenerated,
				source: aSource,
				original: aOriginal,
				name: aName
			}));
		}
	};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
	function SourceMapGenerator_serializeMappings() {
		var previousGeneratedColumn = 0;
		var previousGeneratedLine = 1;
		var previousOriginalColumn = 0;
		var previousOriginalLine = 0;
		var previousName = 0;
		var previousSource = 0;
		var result = '';
		var next;
		var mapping;
		var nameIdx;
		var sourceIdx;

		var mappings = this._mappings.toArray();
		for (var i = 0, len = mappings.length; i < len; i++) {
			mapping = mappings[i];
			next = ''

			if (mapping.generatedLine !== previousGeneratedLine) {
				previousGeneratedColumn = 0;
				while (mapping.generatedLine !== previousGeneratedLine) {
					next += ';';
					previousGeneratedLine++;
				}
			}
			else {
				if (i > 0) {
					if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
						continue;
					}
					next += ',';
				}
			}

			next += base64VLQ.encode(mapping.generatedColumn
																 - previousGeneratedColumn);
			previousGeneratedColumn = mapping.generatedColumn;

			if (mapping.source != null) {
				sourceIdx = this._sources.indexOf(mapping.source);
				next += base64VLQ.encode(sourceIdx - previousSource);
				previousSource = sourceIdx;

				// lines are stored 0-based in SourceMap spec version 3
				next += base64VLQ.encode(mapping.originalLine - 1
																	 - previousOriginalLine);
				previousOriginalLine = mapping.originalLine - 1;

				next += base64VLQ.encode(mapping.originalColumn
																	 - previousOriginalColumn);
				previousOriginalColumn = mapping.originalColumn;

				if (mapping.name != null) {
					nameIdx = this._names.indexOf(mapping.name);
					next += base64VLQ.encode(nameIdx - previousName);
					previousName = nameIdx;
				}
			}

			result += next;
		}

		return result;
	};

SourceMapGenerator.prototype._generateSourcesContent =
	function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
		return aSources.map(function (source) {
			if (!this._sourcesContents) {
				return null;
			}
			if (aSourceRoot != null) {
				source = util.relative(aSourceRoot, source);
			}
			var key = util.toSetString(source);
			return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
				? this._sourcesContents[key]
				: null;
		}, this);
	};

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
	function SourceMapGenerator_toJSON() {
		var map = {
			version: this._version,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings()
		};
		if (this._file != null) {
			map.file = this._file;
		}
		if (this._sourceRoot != null) {
			map.sourceRoot = this._sourceRoot;
		}
		if (this._sourcesContents) {
			map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
		}

		return map;
	};

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
	function SourceMapGenerator_toString() {
		return JSON.stringify(this.toJSON());
	};

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":21,"./base64-vlq":22,"./mapping-list":25,"./util":30}],29:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	this.children = [];
	this.sourceContents = {};
	this.line = aLine == null ? null : aLine;
	this.column = aColumn == null ? null : aColumn;
	this.source = aSource == null ? null : aSource;
	this.name = aName == null ? null : aName;
	this[isSourceNode] = true;
	if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
	function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
		// The SourceNode we want to fill with the generated code
		// and the SourceMap
		var node = new SourceNode();

		// All even indices of this array are one line of the generated code,
		// while all odd indices are the newlines between two adjacent lines
		// (since `REGEX_NEWLINE` captures its match).
		// Processed fragments are accessed by calling `shiftNextLine`.
		var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		var remainingLinesIndex = 0;
		var shiftNextLine = function() {
			var lineContents = getNextLine();
			// The last line of a file might not have a newline.
			var newLine = getNextLine() || "";
			return lineContents + newLine;

			function getNextLine() {
				return remainingLinesIndex < remainingLines.length ?
						remainingLines[remainingLinesIndex++] : undefined;
			}
		};

		// We need to remember the position of "remainingLines"
		var lastGeneratedLine = 1, lastGeneratedColumn = 0;

		// The generate SourceNodes we need a code range.
		// To extract it current and last mapping is used.
		// Here we store the last mapping.
		var lastMapping = null;

		aSourceMapConsumer.eachMapping(function (mapping) {
			if (lastMapping !== null) {
				// We add the code from "lastMapping" to "mapping":
				// First check if there is a new line in between.
				if (lastGeneratedLine < mapping.generatedLine) {
					// Associate first line with "lastMapping"
					addMappingWithCode(lastMapping, shiftNextLine());
					lastGeneratedLine++;
					lastGeneratedColumn = 0;
					// The remaining code is added without mapping
				} else {
					// There is no new line in between.
					// Associate the code between "lastGeneratedColumn" and
					// "mapping.generatedColumn" with "lastMapping"
					var nextLine = remainingLines[remainingLinesIndex] || '';
					var code = nextLine.substr(0, mapping.generatedColumn -
																				lastGeneratedColumn);
					remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
																							lastGeneratedColumn);
					lastGeneratedColumn = mapping.generatedColumn;
					addMappingWithCode(lastMapping, code);
					// No more remaining code, continue
					lastMapping = mapping;
					return;
				}
			}
			// We add the generated code until the first mapping
			// to the SourceNode without any mapping.
			// Each line is added as separate string.
			while (lastGeneratedLine < mapping.generatedLine) {
				node.add(shiftNextLine());
				lastGeneratedLine++;
			}
			if (lastGeneratedColumn < mapping.generatedColumn) {
				var nextLine = remainingLines[remainingLinesIndex] || '';
				node.add(nextLine.substr(0, mapping.generatedColumn));
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
			}
			lastMapping = mapping;
		}, this);
		// We have processed all mappings.
		if (remainingLinesIndex < remainingLines.length) {
			if (lastMapping) {
				// Associate the remaining code in the current line with "lastMapping"
				addMappingWithCode(lastMapping, shiftNextLine());
			}
			// and add the remaining lines without any mapping
			node.add(remainingLines.splice(remainingLinesIndex).join(""));
		}

		// Copy sourcesContent into SourceNode
		aSourceMapConsumer.sources.forEach(function (sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aRelativePath != null) {
					sourceFile = util.join(aRelativePath, sourceFile);
				}
				node.setSourceContent(sourceFile, content);
			}
		});

		return node;

		function addMappingWithCode(mapping, code) {
			if (mapping === null || mapping.source === undefined) {
				node.add(code);
			} else {
				var source = aRelativePath
					? util.join(aRelativePath, mapping.source)
					: mapping.source;
				node.add(new SourceNode(mapping.originalLine,
																mapping.originalColumn,
																source,
																code,
																mapping.name));
			}
		}
	};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
	if (Array.isArray(aChunk)) {
		aChunk.forEach(function (chunk) {
			this.add(chunk);
		}, this);
	}
	else if (aChunk[isSourceNode] || typeof aChunk === "string") {
		if (aChunk) {
			this.children.push(aChunk);
		}
	}
	else {
		throw new TypeError(
			"Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
		);
	}
	return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	if (Array.isArray(aChunk)) {
		for (var i = aChunk.length-1; i >= 0; i--) {
			this.prepend(aChunk[i]);
		}
	}
	else if (aChunk[isSourceNode] || typeof aChunk === "string") {
		this.children.unshift(aChunk);
	}
	else {
		throw new TypeError(
			"Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
		);
	}
	return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	var chunk;
	for (var i = 0, len = this.children.length; i < len; i++) {
		chunk = this.children[i];
		if (chunk[isSourceNode]) {
			chunk.walk(aFn);
		}
		else {
			if (chunk !== '') {
				aFn(chunk, { source: this.source,
										 line: this.line,
										 column: this.column,
										 name: this.name });
			}
		}
	}
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
	var newChildren;
	var i;
	var len = this.children.length;
	if (len > 0) {
		newChildren = [];
		for (i = 0; i < len-1; i++) {
			newChildren.push(this.children[i]);
			newChildren.push(aSep);
		}
		newChildren.push(this.children[i]);
		this.children = newChildren;
	}
	return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	var lastChild = this.children[this.children.length - 1];
	if (lastChild[isSourceNode]) {
		lastChild.replaceRight(aPattern, aReplacement);
	}
	else if (typeof lastChild === 'string') {
		this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	}
	else {
		this.children.push(''.replace(aPattern, aReplacement));
	}
	return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
	function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
		this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
	function SourceNode_walkSourceContents(aFn) {
		for (var i = 0, len = this.children.length; i < len; i++) {
			if (this.children[i][isSourceNode]) {
				this.children[i].walkSourceContents(aFn);
			}
		}

		var sources = Object.keys(this.sourceContents);
		for (var i = 0, len = sources.length; i < len; i++) {
			aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
		}
	};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
	var str = "";
	this.walk(function (chunk) {
		str += chunk;
	});
	return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	var generated = {
		code: "",
		line: 1,
		column: 0
	};
	var map = new SourceMapGenerator(aArgs);
	var sourceMappingActive = false;
	var lastOriginalSource = null;
	var lastOriginalLine = null;
	var lastOriginalColumn = null;
	var lastOriginalName = null;
	this.walk(function (chunk, original) {
		generated.code += chunk;
		if (original.source !== null
				&& original.line !== null
				&& original.column !== null) {
			if(lastOriginalSource !== original.source
				 || lastOriginalLine !== original.line
				 || lastOriginalColumn !== original.column
				 || lastOriginalName !== original.name) {
				map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
			}
			lastOriginalSource = original.source;
			lastOriginalLine = original.line;
			lastOriginalColumn = original.column;
			lastOriginalName = original.name;
			sourceMappingActive = true;
		} else if (sourceMappingActive) {
			map.addMapping({
				generated: {
					line: generated.line,
					column: generated.column
				}
			});
			lastOriginalSource = null;
			sourceMappingActive = false;
		}
		for (var idx = 0, length = chunk.length; idx < length; idx++) {
			if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
				generated.line++;
				generated.column = 0;
				// Mappings end at eol
				if (idx + 1 === length) {
					lastOriginalSource = null;
					sourceMappingActive = false;
				} else if (sourceMappingActive) {
					map.addMapping({
						source: original.source,
						original: {
							line: original.line,
							column: original.column
						},
						generated: {
							line: generated.line,
							column: generated.column
						},
						name: original.name
					});
				}
			} else {
				generated.column++;
			}
		}
	});
	this.walkSourceContents(function (sourceFile, sourceContent) {
		map.setSourceContent(sourceFile, sourceContent);
	});

	return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":28,"./util":30}],30:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
	if (aName in aArgs) {
		return aArgs[aName];
	} else if (arguments.length === 3) {
		return aDefaultValue;
	} else {
		throw new Error('"' + aName + '" is a required argument.');
	}
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
	var match = aUrl.match(urlRegexp);
	if (!match) {
		return null;
	}
	return {
		scheme: match[1],
		auth: match[2],
		host: match[3],
		port: match[4],
		path: match[5]
	};
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
	var url = '';
	if (aParsedUrl.scheme) {
		url += aParsedUrl.scheme + ':';
	}
	url += '//';
	if (aParsedUrl.auth) {
		url += aParsedUrl.auth + '@';
	}
	if (aParsedUrl.host) {
		url += aParsedUrl.host;
	}
	if (aParsedUrl.port) {
		url += ":" + aParsedUrl.port
	}
	if (aParsedUrl.path) {
		url += aParsedUrl.path;
	}
	return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
	var path = aPath;
	var url = urlParse(aPath);
	if (url) {
		if (!url.path) {
			return aPath;
		}
		path = url.path;
	}
	var isAbsolute = exports.isAbsolute(path);

	var parts = path.split(/\/+/);
	for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		part = parts[i];
		if (part === '.') {
			parts.splice(i, 1);
		} else if (part === '..') {
			up++;
		} else if (up > 0) {
			if (part === '') {
				// The first part is blank if the path is absolute. Trying to go
				// above the root is a no-op. Therefore we can remove all '..' parts
				// directly after the root.
				parts.splice(i + 1, up);
				up = 0;
			} else {
				parts.splice(i, 2);
				up--;
			}
		}
	}
	path = parts.join('/');

	if (path === '') {
		path = isAbsolute ? '/' : '.';
	}

	if (url) {
		url.path = path;
		return urlGenerate(url);
	}
	return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
	if (aRoot === "") {
		aRoot = ".";
	}
	if (aPath === "") {
		aPath = ".";
	}
	var aPathUrl = urlParse(aPath);
	var aRootUrl = urlParse(aRoot);
	if (aRootUrl) {
		aRoot = aRootUrl.path || '/';
	}

	// `join(foo, '//www.example.org')`
	if (aPathUrl && !aPathUrl.scheme) {
		if (aRootUrl) {
			aPathUrl.scheme = aRootUrl.scheme;
		}
		return urlGenerate(aPathUrl);
	}

	if (aPathUrl || aPath.match(dataUrlRegexp)) {
		return aPath;
	}

	// `join('http://', 'www.example.com')`
	if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		aRootUrl.host = aPath;
		return urlGenerate(aRootUrl);
	}

	var joined = aPath.charAt(0) === '/'
		? aPath
		: normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	if (aRootUrl) {
		aRootUrl.path = joined;
		return urlGenerate(aRootUrl);
	}
	return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
	return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
	if (aRoot === "") {
		aRoot = ".";
	}

	aRoot = aRoot.replace(/\/$/, '');

	// It is possible for the path to be above the root. In this case, simply
	// checking whether the root is a prefix of the path won't work. Instead, we
	// need to remove components from the root one by one, until either we find
	// a prefix that fits, or we run out of components to remove.
	var level = 0;
	while (aPath.indexOf(aRoot + '/') !== 0) {
		var index = aRoot.lastIndexOf("/");
		if (index < 0) {
			return aPath;
		}

		// If the only part of the root that is left is the scheme (i.e. http://,
		// file:///, etc.), one or more slashes (/), or simply nothing at all, we
		// have exhausted all components, so the path is not relative to the root.
		aRoot = aRoot.slice(0, index);
		if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
			return aPath;
		}

		++level;
	}

	// Make sure we add a "../" for each component we removed from the root.
	return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
	var obj = Object.create(null);
	return !('__proto__' in obj);
}());

function identity (s) {
	return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
	if (isProtoString(aStr)) {
		return '$' + aStr;
	}

	return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
	if (isProtoString(aStr)) {
		return aStr.slice(1);
	}

	return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
	if (!s) {
		return false;
	}

	var length = s.length;

	if (length < 9 /* "__proto__".length */) {
		return false;
	}

	if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
			s.charCodeAt(length - 2) !== 95  /* '_' */ ||
			s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
			s.charCodeAt(length - 4) !== 116 /* 't' */ ||
			s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
			s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
			s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
			s.charCodeAt(length - 8) !== 95  /* '_' */ ||
			s.charCodeAt(length - 9) !== 95  /* '_' */) {
		return false;
	}

	for (var i = length - 10; i >= 0; i--) {
		if (s.charCodeAt(i) !== 36 /* '$' */) {
			return false;
		}
	}

	return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	var cmp = strcmp(mappingA.source, mappingB.source);
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.originalLine - mappingB.originalLine;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.originalColumn - mappingB.originalColumn;
	if (cmp !== 0 || onlyCompareOriginal) {
		return cmp;
	}

	cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.generatedLine - mappingB.generatedLine;
	if (cmp !== 0) {
		return cmp;
	}

	return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	var cmp = mappingA.generatedLine - mappingB.generatedLine;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	if (cmp !== 0 || onlyCompareGenerated) {
		return cmp;
	}

	cmp = strcmp(mappingA.source, mappingB.source);
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.originalLine - mappingB.originalLine;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.originalColumn - mappingB.originalColumn;
	if (cmp !== 0) {
		return cmp;
	}

	return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
	if (aStr1 === aStr2) {
		return 0;
	}

	if (aStr1 === null) {
		return 1; // aStr2 !== null
	}

	if (aStr2 === null) {
		return -1; // aStr1 !== null
	}

	if (aStr1 > aStr2) {
		return 1;
	}

	return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	var cmp = mappingA.generatedLine - mappingB.generatedLine;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = strcmp(mappingA.source, mappingB.source);
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.originalLine - mappingB.originalLine;
	if (cmp !== 0) {
		return cmp;
	}

	cmp = mappingA.originalColumn - mappingB.originalColumn;
	if (cmp !== 0) {
		return cmp;
	}

	return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
	return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	sourceURL = sourceURL || '';

	if (sourceRoot) {
		// This follows what Chrome does.
		if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
			sourceRoot += '/';
		}
		// The spec says:
		//   Line 4: An optional source root, useful for relocating source
		//   files on a server or removing repeated values in the
		//   sources entry.  This value is prepended to the individual
		//   entries in the source field.
		sourceURL = sourceRoot + sourceURL;
	}

	// Historically, SourceMapConsumer did not take the sourceMapURL as
	// a parameter.  This mode is still somewhat supported, which is why
	// this code block is conditional.  However, it's preferable to pass
	// the source map URL to SourceMapConsumer, so that this function
	// can implement the source URL resolution algorithm as outlined in
	// the spec.  This block is basically the equivalent of:
	//    new URL(sourceURL, sourceMapURL).toString()
	// ... except it avoids using URL, which wasn't available in the
	// older releases of node still supported by this library.
	//
	// The spec says:
	//   If the sources are not absolute URLs after prepending of the
	//   sourceRoot, the sources are resolved relative to the
	//   SourceMap (like resolving script src in a html document).
	if (sourceMapURL) {
		var parsed = urlParse(sourceMapURL);
		if (!parsed) {
			throw new Error("sourceMapURL could not be parsed");
		}
		if (parsed.path) {
			// Strip the last path component, but keep the "/".
			var index = parsed.path.lastIndexOf('/');
			if (index >= 0) {
				parsed.path = parsed.path.substring(0, index + 1);
			}
		}
		sourceURL = join(urlGenerate(parsed), sourceURL);
	}

	return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],31:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":27,"./lib/source-map-generator":28,"./lib/source-node":29}],"livescript":[function(require,module,exports){
// Generated by LiveScript 1.6.1
var LiveScript;
LiveScript = require('./index');
LiveScript.stab = function(code, callback, filename){
	var e;
	try {
		LiveScript.run(code, {
			filename: filename,
			map: 'embedded'
		});
	} catch (e$) {
		e = e$;
	}
	if (typeof callback == 'function') {
		callback(e);
	}
};
LiveScript.load = async function(url, callback){
	fetch(url)
	.then(res => {
		if (res.status === 200 || res.status === 0) {
			return res.text();
		} else {
			if (typeof callback == "function") {
				callback(Error(url + ": " + res.status + " " + res.statusText));
			}
		}
	})
	.then(text => {
		LiveScript.stab(text, callback, url);
	});
};
LiveScript.go = async function(){
	var type, sink, i$, ref$, len$, script;
	type = /^(?:text\/|application\/)?ls$/i;
	sink = function(error){
		error && setTimeout(function(){
			throw error;
		});
	};
	for (i$ = 0, len$ = (ref$ = document.getElementsByTagName('script')).length; i$ < len$; ++i$) {
		script = ref$[i$];
		if (type.test(script.type)) {
			if (script.src) {
				await LiveScript.load(script.src, sink);
			} else {
				LiveScript.stab(script.text, sink, script.id);
			}
		}
	}
};
module.exports = LiveScript;
},{"./index":2}]},{},[]);

if (isNode) {
	module.exports = require('livescript');
} else {
	window.livescript = require('livescript');
	window.addEventListener('DOMContentLoaded', livescript.go, {once: true});
}

})();
